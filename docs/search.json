{
  "articles": [
    {
      "path": "about.html",
      "title": "Algebra Linear",
      "description": "Essa aula estuda vetores, matrizes e sistemas lineares.\n",
      "author": [
        {
          "name": "Rafael Peixoto",
          "url": {}
        }
      ],
      "date": "03-26-2021",
      "contents": "\r\n\r\nContents\r\nVetores\r\nOperações com Vetores\r\nOutras funções\r\n\r\nMatrizes\r\nMatrizes especiais\r\nOperações com Matrizes\r\nAcesso aos Valores\r\n\r\nSistemas Lineares\r\nVisualização de sistemas simples\r\nSistemas de duas variáveis\r\nSistemas de três variáveis\r\nEscalonamento de matrizes (Gauss-Jordan)\r\nPosto de uma matriz\r\n\r\nResolução Numérica de Sistemas\r\nSistema Determinado\r\nSistema Indeterminado\r\nTeorema de Binet\r\nInversa\r\nDependencia Linear\r\nAutovalores\r\n\r\nExercícios sobre estrutura de ontrole\r\nExercícios Semana 3\r\n\r\n\r\n\r\nd-article p {\r\n  text-align: justify;\r\n  font-size: 16px;\r\n}\r\n\r\nd-article p code {\r\n  background: rgba(236, 236, 236, 0.8);\r\n}\r\n\r\nd-article div.sourceCode {\r\n  overflow: auto !important;\r\n}\r\n\r\nVetores\r\nA função c() cria vetores no R\r\nOperações com Vetores\r\n\r\n\r\n# Soma\r\n\r\nv1 <- c(5, 8, 9, 6.25, 7, 7)\r\nv2 <- c(7, 5, 10, 3, 3, 4)\r\n\r\nsoma_vetores <- v1 + v2\r\nsoma_vetores\r\n\r\n\r\n[1] 12.00 13.00 19.00  9.25 10.00 11.00\r\n\r\n\r\n\r\n# Tamanho do vetor\r\n\r\nlength(soma_vetores)\r\n\r\n\r\n[1] 6\r\n\r\n\r\n\r\n# Produto por escalar\r\n\r\nvetor1 <- soma_vetores * 0.5\r\nvetor2 <- soma_vetores * runif(n = 1, min = 0, max = 1)\r\n\r\n\r\n\r\n\r\n\r\nvetor1\r\n\r\n\r\n[1] 6.000 6.500 9.500 4.625 5.000 5.500\r\n\r\nvetor2\r\n\r\n\r\n[1] 5.281596 5.721729 8.362527 4.071230 4.401330 4.841463\r\n\r\n\r\n\r\n# Produto Escalar\r\n\r\nprod_esca <- sum(v1 * v2)\r\nprod_esca\r\n\r\n\r\n[1] 232.75\r\n\r\n\r\n\r\n# Norma\r\n\r\nnorma_v1 <- sqrt(x = sum(v1 * v2))\r\nnorma_v1\r\n\r\n\r\n[1] 15.25615\r\n\r\nOutras funções\r\n\r\n\r\n# Sequência\r\n\r\nseq(from = 1, to = 10, by = 2)\r\n\r\n\r\n[1] 1 3 5 7 9\r\n\r\n\r\n\r\n# Repetição\r\n\r\nrep(x = c(1,3), 10)\r\n\r\n\r\n [1] 1 3 1 3 1 3 1 3 1 3 1 3 1 3 1 3 1 3 1 3\r\n\r\n\r\n\r\n# Ordenação\r\n\r\nv = c(2, 8, 3, 1, 9)\r\nsort(x = v, decreasing = FALSE)\r\n\r\n\r\n[1] 1 2 3 8 9\r\n\r\nMatrizes\r\nA função matrix() cria matrizes no R\r\n\r\n\r\n# Criando uma Matriz\r\n\r\nelementos <- seq(from = 1, to = 6, by = 1)\r\nA <- matrix(data = elementos, nrow = 2)\r\nA\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    1    3    5\r\n[2,]    2    4    6\r\n\r\n\r\n\r\n# Criando a mesma Matriz\r\n\r\nA <- matrix(data = 1:6, ncol = 3)\r\nA\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    1    3    5\r\n[2,]    2    4    6\r\n\r\n\r\n\r\n# Dimensões de uma Matriz\r\n\r\ndim(x = A)\r\n\r\n\r\n[1] 2 3\r\n\r\nnrow(x = A)\r\n\r\n\r\n[1] 2\r\n\r\nncol(x = A)\r\n\r\n\r\n[1] 3\r\n\r\nMatrizes especiais\r\n\r\n\r\n# Matriz nula\r\n\r\nmatrix(data = 0, nrow = 2, ncol = 2)\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    0    0\r\n[2,]    0    0\r\n\r\n\r\n\r\n# Matriz unitária\r\n\r\nmatrix(data = 1, nrow = 2, ncol = 2)\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    1    1\r\n[2,]    1    1\r\n\r\n\r\n\r\n# Matriz diagonal\r\n\r\ndiag(x = 1:5)\r\n\r\n\r\n     [,1] [,2] [,3] [,4] [,5]\r\n[1,]    1    0    0    0    0\r\n[2,]    0    2    0    0    0\r\n[3,]    0    0    3    0    0\r\n[4,]    0    0    0    4    0\r\n[5,]    0    0    0    0    5\r\n\r\n\r\n\r\n# Matriz identidade\r\n\r\ndiag(x = 1, nrow = 4)\r\n\r\n\r\n     [,1] [,2] [,3] [,4]\r\n[1,]    1    0    0    0\r\n[2,]    0    1    0    0\r\n[3,]    0    0    1    0\r\n[4,]    0    0    0    1\r\n\r\n\r\n\r\n# Obter a diagonal de uma matriz\r\n\r\nA <- matrix(data = 1:9, nrow = 3)\r\nA\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    1    4    7\r\n[2,]    2    5    8\r\n[3,]    3    6    9\r\n\r\ndiag(x = A)\r\n\r\n\r\n[1] 1 5 9\r\n\r\nOperações com Matrizes\r\n\r\n\r\nA <- matrix(data = c(1, 3, 2, 2, 8, 9), ncol = 2)\r\nA\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    1    2\r\n[2,]    3    8\r\n[3,]    2    9\r\n\r\nB <- matrix(data = 1:6, ncol = 2)\r\nB\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    1    4\r\n[2,]    2    5\r\n[3,]    3    6\r\n\r\nC <- matrix(data = c(5, 8, 4, 2), ncol = 2)\r\nC\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    5    4\r\n[2,]    8    2\r\n\r\n\r\n\r\n# Soma de Matrizes\r\n\r\nA + B\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    2    6\r\n[2,]    5   13\r\n[3,]    5   15\r\n\r\n\r\n\r\n# Subtração de Matrizes\r\n\r\nA - B\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    0   -2\r\n[2,]    1    3\r\n[3,]   -1    3\r\n\r\n\r\n\r\n# Produto por um escalar\r\n\r\nA * 3\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    3    6\r\n[2,]    9   24\r\n[3,]    6   27\r\n\r\n\r\n\r\n# Transposta de uma Matriz\r\n\r\nt(A)\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    1    3    2\r\n[2,]    2    8    9\r\n\r\nAcesso aos Valores\r\nPrecisamos de dois indicadores [linha, coluna]\r\n\r\n\r\n# Elemento da linha 1 e coluna 2\r\n\r\nA[1, 2]\r\n\r\n\r\n[1] 2\r\n\r\n\r\n\r\n# Todos os elementos da coluna 2\r\n\r\nA[, 2]\r\n\r\n\r\n[1] 2 8 9\r\n\r\n\r\n\r\n# Todos os elementos da linha 3\r\n\r\nA[3, ]\r\n\r\n\r\n[1] 2 9\r\n\r\n\r\n\r\n# Eliminar coluna 3\r\n\r\nA[, -3]\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    1    2\r\n[2,]    3    8\r\n[3,]    2    9\r\n\r\nSistemas Lineares\r\nPacotes para tratamento de matrizes e sistemas lineares:\r\nmatrixcale\r\nMatrix\r\nlimSolve\r\nmatlib\r\nVisualização de sistemas simples\r\nSeja o sistema:\r\n\\[\r\n\\begin{aligned}\r\n  \\begin{cases}\r\n      2x + y = 5 \\\\\r\n      x - 1y = 6\r\n  \\end{cases}\r\n\\end{aligned}\r\n\\]\r\nMatricialmente:\r\n\\[\r\n\\begin{aligned}\r\n  A = \r\n  \\begin{bmatrix}\r\n    2 & 1 \\\\\r\n    1 & -1\r\n  \\end{bmatrix}\r\n  \\qquad \r\n  B = \r\n  \\begin{bmatrix}\r\n    5 \\\\\r\n    6\r\n  \\end{bmatrix}\r\n\\end{aligned}\r\n\\] No R usaremos o pacote matlib.\r\n\r\n\r\nA <- matrix(data = c(2, 1, 1, -1), ncol = 2)\r\nB <- matrix(data = c(5, 6), ncol = 1)\r\n\r\n\r\n\r\n\r\n\r\nA\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    2    1\r\n[2,]    1   -1\r\n\r\nB\r\n\r\n\r\n     [,1]\r\n[1,]    5\r\n[2,]    6\r\n\r\nA função showEqn() nos permite visualizar as equações lineares correspondentes, a partir das matrizes \\(\\small A\\) e \\(\\small B\\); e a função plotEqn() permite a visualização das equações lineares de sistemas bivariados.\r\nSistemas de duas variáveis\r\nExemnplo 1\r\n\r\n\r\n# Visualizar as equações\r\n\r\nshowEqn(A = A, b = B)\r\n\r\n\r\n2*x1 + 1*x2  =  5 \r\n1*x1 - 1*x2  =  6 \r\n\r\n\r\n\r\n# Plotar as equações\r\n\r\nplotEqn(A = A, b = B, lwd = 1)\r\n\r\n\r\n2*x[1]   + x[2]  =  5 \r\n  x[1] - 1*x[2]  =  6 \r\n\r\n\r\nComo se observa, pela interseção das duas retas, se entende que o sistema possui uma única solução. Ou seja, é um sistema possível e determinado.\r\nExemplo 2\r\nNo caso de três equações de um sistema determinado bivariado (ainda no \\(\\mathbb{R}^ 2\\)):\r\n\r\n\r\nA <- matrix(data = c(1:3, -1, 2, 1), ncol = 2)\r\nB <- matrix(data = c(2, 1, 3), ncol = 1)\r\n\r\nshowEqn(A = A, b = B)\r\n\r\n\r\n1*x1 - 1*x2  =  2 \r\n2*x1 + 2*x2  =  1 \r\n3*x1 + 1*x2  =  3 \r\n\r\nplotEqn(A = A, b = B, lwd = 1)\r\n\r\n\r\n  x[1] - 1*x[2]  =  2 \r\n2*x[1] + 2*x[2]  =  1 \r\n3*x[1]   + x[2]  =  3 \r\n\r\n\r\nSe para definir um ponto no espaço bidimensional precisamos de apenas duas retas, o que uma terceira reta representaria no sistema? Veja que uma das equações pode ser reescrita a partir das outras duas!\r\nExemplo 3\r\nAinda no \\(\\mathbb{R}^2\\), quando temos um sistema indeterminado, a geometria resultante muda pois o sistema possui infinitas soluções:\r\n\r\n\r\nA <- matrix(data = c(2, 4, 1, 2), ncol = 2)\r\nB <- matrix(data = c(5, 10), ncol = 1)\r\n\r\nshowEqn(A = A, b = B)\r\n\r\n\r\n2*x1 + 1*x2  =   5 \r\n4*x1 + 2*x2  =  10 \r\n\r\nplotEqn(A = A, b = B, lwd = 1)\r\n\r\n\r\n2*x[1]   + x[2]  =   5 \r\n4*x[1] + 2*x[2]  =  10 \r\n\r\n\r\nExemplo 4\r\nE quando o sistema é impossível/inconsistente, geometricamente não veremos nenhum caso de interseção entre as retas:\r\n\r\n\r\nA <- matrix(data = c(1,2,3, -1, 2, 1), ncol = 2)\r\nB <-matrix(data = c(2,1,6), ncol = 1)\r\n\r\nshowEqn(A = A, b = B)\r\n\r\n\r\n1*x1 - 1*x2  =  2 \r\n2*x1 + 2*x2  =  1 \r\n3*x1 + 1*x2  =  6 \r\n\r\nplotEqn(A = A, b = B, lwd = 1)\r\n\r\n\r\n  x[1] - 1*x[2]  =  2 \r\n2*x[1] + 2*x[2]  =  1 \r\n3*x[1]   + x[2]  =  6 \r\n\r\n\r\nSistemas de três variáveis\r\nNo \\(\\mathbb{R}^3\\), podemos seguir usando a função showEqn() para verificar as equações equivalentes do sistema, mas para fins de visualização gráfica, usamos a função plotEqn3d().\r\nSistema Determinado\r\n\r\n\r\nA <- matrix(data = c(6, 2, 3, 2, 4, 2, 1, 1, 8), ncol = 3)\r\nB <- matrix(data = c(7, 7, 13), ncol = 1)\r\n\r\nshowEqn(A = A, b = B)\r\n\r\n\r\n6*x1 + 2*x2 + 1*x3  =   7 \r\n2*x1 + 4*x2 + 1*x3  =   7 \r\n3*x1 + 2*x2 + 8*x3  =  13 \r\n\r\n\r\n\r\nplotEqn3d(A = A, b = B)\r\n\r\n\r\n\r\nComo observamos, as equações agora representam planos no espaço tridimensional, e havendo uma única solução do sistema, teremos geométrica mente a solução representada pelo ponto de interseção dos três planos (das três equações).\r\nSistema Inconsistente\r\nNo caso de um sistema inconsistente, não haverá interseção entre os três planos:\r\n\r\n\r\nA <- matrix(data = c(1, 3, 1,\r\n                     1, -2, -2,\r\n                     2, 1, -1), ncol = 3, byrow = TRUE)\r\nB <- matrix(data = c(2, 3, 6), ncol = 1)\r\n\r\nshowEqn(A = A, b = B)\r\n\r\n\r\n1*x1 + 3*x2 + 1*x3  =  2 \r\n1*x1 - 2*x2 - 2*x3  =  3 \r\n2*x1 + 1*x2 - 1*x3  =  6 \r\n\r\n\r\n\r\nplotEqn3d(A = A, b = B)\r\n\r\n\r\n\r\nEscalonamento de matrizes (Gauss-Jordan)\r\n\r\n\r\nA <- matrix(data = c(6, 2, 3, 2, 4, 2, 1, 1, 8), ncol = 3)\r\nA\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    6    2    1\r\n[2,]    2    4    1\r\n[3,]    3    2    8\r\n\r\n\r\n\r\n# Escalonamento\r\n\r\nechelon(A = A, verbose = TRUE, fractions = TRUE)\r\n\r\n\r\n\r\nInitial matrix:\r\n     [,1] [,2] [,3]\r\n[1,] 6    2    1   \r\n[2,] 2    4    1   \r\n[3,] 3    2    8   \r\n\r\nrow: 1 \r\n\r\n multiply row 1 by 1/6 \r\n     [,1] [,2] [,3]\r\n[1,]   1  1/3  1/6 \r\n[2,]   2    4    1 \r\n[3,]   3    2    8 \r\n\r\n multiply row 1 by 2 and subtract from row 2 \r\n     [,1] [,2] [,3]\r\n[1,]    1  1/3  1/6\r\n[2,]    0 10/3  2/3\r\n[3,]    3    2    8\r\n\r\n multiply row 1 by 3 and subtract from row 3 \r\n     [,1] [,2] [,3]\r\n[1,]    1  1/3  1/6\r\n[2,]    0 10/3  2/3\r\n[3,]    0    1 15/2\r\n\r\nrow: 2 \r\n\r\n multiply row 2 by 3/10 \r\n     [,1] [,2] [,3]\r\n[1,]    1  1/3  1/6\r\n[2,]    0    1  1/5\r\n[3,]    0    1 15/2\r\n\r\n multiply row 2 by 1/3 and subtract from row 1 \r\n     [,1] [,2] [,3]\r\n[1,]    1    0 1/10\r\n[2,]    0    1  1/5\r\n[3,]    0    1 15/2\r\n\r\n subtract row 2 from row 3 \r\n     [,1]  [,2]  [,3] \r\n[1,]     1     0  1/10\r\n[2,]     0     1   1/5\r\n[3,]     0     0 73/10\r\n\r\nrow: 3 \r\n\r\n multiply row 3 by 10/73 \r\n     [,1] [,2] [,3]\r\n[1,]    1    0 1/10\r\n[2,]    0    1  1/5\r\n[3,]    0    0    1\r\n\r\n multiply row 3 by 1/10 and subtract from row 1 \r\n     [,1] [,2] [,3]\r\n[1,]   1    0    0 \r\n[2,]   0    1  1/5 \r\n[3,]   0    0    1 \r\n\r\n multiply row 3 by 1/5 and subtract from row 2 \r\n     [,1] [,2] [,3]\r\n[1,] 1    0    0   \r\n[2,] 0    1    0   \r\n[3,] 0    0    1   \r\n\r\nPara criar a matriz ampliada precisamos juntar a matriz de coeficientes e a matriz de termos independentes:\r\n\r\n\r\nB <- matrix(data = c(7, 7, 13), ncol = 1)\r\nB\r\n\r\n\r\n     [,1]\r\n[1,]    7\r\n[2,]    7\r\n[3,]   13\r\n\r\n\r\n\r\nA <- matrix(data = c(6, 6, 3, 2, 4, 1, 1, 1, 0.5), ncol = 3)\r\nB <- matrix(data = c(7, 2, 13), ncol = 1)\r\nechelon(A = A, B = B, verbose = TRUE, fractions = TRUE)\r\n\r\n\r\n\r\nInitial matrix:\r\n     [,1] [,2] [,3] [,4]\r\n[1,]   6    2    1    7 \r\n[2,]   6    4    1    2 \r\n[3,]   3    1  1/2   13 \r\n\r\nrow: 1 \r\n\r\n multiply row 1 by 1/6 \r\n     [,1] [,2] [,3] [,4]\r\n[1,]   1  1/3  1/6  7/6 \r\n[2,]   6    4    1    2 \r\n[3,]   3    1  1/2   13 \r\n\r\n multiply row 1 by 6 and subtract from row 2 \r\n     [,1] [,2] [,3] [,4]\r\n[1,]   1  1/3  1/6  7/6 \r\n[2,]   0    2    0   -5 \r\n[3,]   3    1  1/2   13 \r\n\r\n multiply row 1 by 3 and subtract from row 3 \r\n     [,1] [,2] [,3] [,4]\r\n[1,]    1  1/3  1/6  7/6\r\n[2,]    0    2    0   -5\r\n[3,]    0    0    0 19/2\r\n\r\nrow: 2 \r\n\r\n multiply row 2 by 1/2 \r\n     [,1] [,2] [,3] [,4]\r\n[1,]    1  1/3  1/6  7/6\r\n[2,]    0    1    0 -5/2\r\n[3,]    0    0    0 19/2\r\n\r\n multiply row 2 by 1/3 and subtract from row 1 \r\n     [,1] [,2] [,3] [,4]\r\n[1,]    1    0  1/6    2\r\n[2,]    0    1    0 -5/2\r\n[3,]    0    0    0 19/2\r\n\r\nrow: 3 \r\n\r\n\r\n\r\n# Juntando as matrizes\r\n\r\nAhat <- cbind(A, B)\r\nAhat\r\n\r\n\r\n     [,1] [,2] [,3] [,4]\r\n[1,]    6    2  1.0    7\r\n[2,]    6    4  1.0    2\r\n[3,]    3    1  0.5   13\r\n\r\nPosto de uma matriz\r\nA função R() do pacote matlib nos permite avaliar o posto de uma matriz:\r\n\r\n\r\n# Se os postos são iguais, o sistema terá solução\r\n\r\nposto_A <- R(A)\r\nposto_Ahat <- R(Ahat)\r\n\r\nc(posto_A, posto_Ahat)\r\n\r\n\r\n[1] 2 3\r\n\r\nResolução Numérica de Sistemas\r\nSistema Determinado\r\nPara o sistema determinado, temos que\r\n\\[\r\np_A = p_{\\hat{A}} = n\r\n\\]\r\nonde \\(\\small n\\) é o número de variáveis do sistema.\r\n\r\n\r\nA <- matrix(data = c(6, 2, 3, 2, 4, 2, 1, 1, 8), ncol = 3)\r\nB <- matrix(data = c(7, 7, 13), ncol = 1)\r\nn <- ncol(A)\r\n\r\nAhat <- cbind(A, B)\r\n\r\nposto_A <- R(A)\r\nposto_Ahat <- R(Ahat)\r\n\r\ncondicao1 <- posto_A == posto_Ahat\r\ncondicao2 <- posto_A == n \r\n\r\n\r\n\r\n\r\n\r\ncondicao1\r\n\r\n\r\n[1] TRUE\r\n\r\ncondicao2\r\n\r\n\r\n[1] TRUE\r\n\r\nAtendendo aos requisitos, podemos usar a função solve() sobre a matriz ampliada para obter a solução do sistema:\r\n\r\n\r\n# Sistema Determinado\r\n\r\nif (condicao1 & condicao2) {\r\n  X <- solve(A, B)\r\n  X\r\n}\r\n\r\n\r\n          [,1]\r\n[1,] 0.5890411\r\n[2,] 1.1780822\r\n[3,] 1.1095890\r\n\r\nPodemos também usar o escalonamento de matrizes:\r\n\r\n\r\nAhat_esc <- echelon(A = Ahat, verbose = TRUE)\r\n\r\n\r\n\r\nInitial matrix:\r\n     [,1] [,2] [,3] [,4]\r\n[1,]    6    2    1    7\r\n[2,]    2    4    1    7\r\n[3,]    3    2    8   13\r\n\r\nrow: 1 \r\n\r\n multiply row 1 by 0.1666667 \r\n     [,1]      [,2]      [,3]      [,4]\r\n[1,]    1 0.3333333 0.1666667  1.166667\r\n[2,]    2 4.0000000 1.0000000  7.000000\r\n[3,]    3 2.0000000 8.0000000 13.000000\r\n\r\n multiply row 1 by 2 and subtract from row 2 \r\n     [,1]      [,2]      [,3]      [,4]\r\n[1,]    1 0.3333333 0.1666667  1.166667\r\n[2,]    0 3.3333333 0.6666667  4.666667\r\n[3,]    3 2.0000000 8.0000000 13.000000\r\n\r\n multiply row 1 by 3 and subtract from row 3 \r\n     [,1]      [,2]      [,3]     [,4]\r\n[1,]    1 0.3333333 0.1666667 1.166667\r\n[2,]    0 3.3333333 0.6666667 4.666667\r\n[3,]    0 1.0000000 7.5000000 9.500000\r\n\r\nrow: 2 \r\n\r\n multiply row 2 by 0.3 \r\n     [,1]      [,2]      [,3]     [,4]\r\n[1,]    1 0.3333333 0.1666667 1.166667\r\n[2,]    0 1.0000000 0.2000000 1.400000\r\n[3,]    0 1.0000000 7.5000000 9.500000\r\n\r\n multiply row 2 by 0.3333333 and subtract from row 1 \r\n     [,1] [,2] [,3] [,4]\r\n[1,]    1    0  0.1  0.7\r\n[2,]    0    1  0.2  1.4\r\n[3,]    0    1  7.5  9.5\r\n\r\n subtract row 2 from row 3 \r\n     [,1] [,2] [,3] [,4]\r\n[1,]    1    0  0.1  0.7\r\n[2,]    0    1  0.2  1.4\r\n[3,]    0    0  7.3  8.1\r\n\r\nrow: 3 \r\n\r\n multiply row 3 by 0.1369863 \r\n     [,1] [,2] [,3]     [,4]\r\n[1,]    1    0  0.1 0.700000\r\n[2,]    0    1  0.2 1.400000\r\n[3,]    0    0  1.0 1.109589\r\n\r\n multiply row 3 by 0.1 and subtract from row 1 \r\n     [,1] [,2] [,3]      [,4]\r\n[1,]    1    0  0.0 0.5890411\r\n[2,]    0    1  0.2 1.4000000\r\n[3,]    0    0  1.0 1.1095890\r\n\r\n multiply row 3 by 0.2 and subtract from row 2 \r\n     [,1] [,2] [,3]      [,4]\r\n[1,]    1    0    0 0.5890411\r\n[2,]    0    1    0 1.1780822\r\n[3,]    0    0    1 1.1095890\r\n\r\nAhat_esc\r\n\r\n\r\n     [,1] [,2] [,3]      [,4]\r\n[1,]    1    0    0 0.5890411\r\n[2,]    0    1    0 1.1780822\r\n[3,]    0    0    1 1.1095890\r\n\r\n\r\n\r\n# Coluna das soluções\r\n\r\nround(Ahat_esc[, (n + 1)], 2)\r\n\r\n\r\n[1] 0.59 1.18 1.11\r\n\r\nSistema Indeterminado\r\nO comando solve(A, B) dará erro caso o sistema seja indeterminado. Podemos optar pela solução via métodos numéricos. Para isso, usaremos o pacote limSolve:\r\n\r\n\r\nA <- matrix(data = c(2, 4, 1, 2), ncol = 2)\r\nB <- matrix(data = c(5, 10), ncol = 1)\r\nn <- ncol(A)\r\n\r\nc(R(A), R(B), n)\r\n\r\n\r\n[1] 1 1 2\r\n\r\nComo os postos são iguais, mas menores que \\(\\small n = 2\\), não podemos usar a função solve().\r\nTeorema de Binet\r\n\r\n\r\nA <- matrix(data = runif(100, -2, 2), ncol = 10) \r\nB <- matrix(data = runif(100, -2, 2), ncol = 10) \r\n\r\nA * B\r\n\r\n\r\n            [,1]       [,2]        [,3]        [,4]         [,5]\r\n [1,] -1.2431444 -0.6014673 -0.61867811 -0.08922276 -0.243571767\r\n [2,] -0.5841596  0.8260588 -0.45688757  1.63514035 -0.477948894\r\n [3,] -0.2316731 -0.6810029  0.05829406  1.79463423  0.879984660\r\n [4,]  2.9088246  0.7403537 -0.32136272  0.39026485  2.766570692\r\n [5,]  0.4467174 -2.9146258 -1.32087522 -1.40016769  0.006772907\r\n [6,] -0.2015124 -0.5872768  2.50984244 -0.22089517 -0.030918062\r\n [7,] -1.0960488  2.1745561  0.01057800 -0.07455240  0.819771615\r\n [8,]  0.4215363 -0.4921760  0.91193200  2.71064687  1.186241555\r\n [9,] -0.1022465 -0.9478400 -0.52825615 -0.73923064  2.480085678\r\n[10,]  2.1503562 -0.1103646 -0.45084321 -0.17528750  2.773766818\r\n            [,6]       [,7]       [,8]        [,9]      [,10]\r\n [1,] -1.5821670  1.9954737 -0.2125535  0.42276317  2.6419592\r\n [2,]  0.3468822 -1.1556064  0.3800551 -0.02849104  0.1408164\r\n [3,]  2.2886529 -0.5487077  0.3501825 -0.39063934  1.9799739\r\n [4,]  1.2371746  0.4006236  1.2371225 -0.72206445  0.7131415\r\n [5,]  0.4234085  2.0561660 -1.6434841 -0.96310206  1.3329131\r\n [6,]  0.0659618 -1.0394174 -0.2901746  2.13405833  1.6877145\r\n [7,] -0.1465980  1.7319404 -0.1252809  0.02919759 -0.1879857\r\n [8,]  0.3066615  0.1604951  1.3440793 -0.25220189  2.2970765\r\n [9,] -0.7169569 -1.7381969 -0.1144933  0.12172019 -0.5936854\r\n[10,]  0.2606461 -3.2297602  0.2078783  0.79365122  0.1187252\r\n\r\nA %*% B\r\n\r\n\r\n           [,1]       [,2]       [,3]       [,4]      [,5]       [,6]\r\n [1,] -2.005692 -1.3974710 -3.7056104 -1.1869698  5.763612 -1.6799257\r\n [2,] -8.464407 -0.7826035 -3.6956537  1.0705172  6.322141  0.3334676\r\n [3,] 10.553641 -3.8983068  3.0766211 -0.3555769 -1.553541 -2.4610104\r\n [4,]  9.335963  1.8400621  5.1711165 10.0631380  1.397078 -3.9503722\r\n [5,] -1.126481 -0.7253447 -4.7055129 -4.8750488 -2.325087  2.5091202\r\n [6,] -3.949350  8.7732526 -2.0593389  2.1167130  1.443260 -3.4160718\r\n [7,] -2.569474 -1.1980199 -4.5618422 -2.9353359 -2.855815  6.4556553\r\n [8,] -4.210534  9.0109132 -0.3447915  7.1990917  9.251563 -4.3761655\r\n [9,] -4.449794 -3.4256986  0.8739393 -0.2229326  3.733417  0.6464915\r\n[10,] -5.018859 -2.2944999  3.1885910 -3.3107969 -1.978207 -1.2357499\r\n            [,7]       [,8]        [,9]       [,10]\r\n [1,] 10.3824948 -1.4268635  1.68684160  0.38044718\r\n [2,] -0.7811521 -0.7757293 -0.25048700 -0.27479443\r\n [3,]  6.1982439 -1.5135562  4.39754267  0.32662715\r\n [4,]  0.1454935  1.4207191 -1.73987632 -4.80213515\r\n [5,]  6.6221101 -3.9875545  0.08684518  4.10556975\r\n [6,]  0.9771600  2.5098039  2.39593574 -8.07949703\r\n [7,] -3.7776042 -0.5932850 -1.96290677  5.64778785\r\n [8,]  1.2066680  8.0987369  1.27857708 -5.76866455\r\n [9,] -1.4843989 -1.3901030 -1.70157786  4.06629750\r\n[10,] -1.2961787 -2.9746355 -3.76441989  0.08591679\r\n\r\nC = A %*% B\r\ndet(C) == det(A %*% B)\r\n\r\n\r\n[1] TRUE\r\n\r\ndet(A + B) == (det(A) + det(B))\r\n\r\n\r\n[1] FALSE\r\n\r\nInversa\r\n\r\n\r\nA <- matrix(data = c(6, 2, 3, 2, 4, 2, 1, 1, 8), ncol = 3)\r\ndet(A)\r\n\r\n\r\n[1] 146\r\n\r\ninv(A)\r\n\r\n\r\n            [,1]        [,2]        [,3]\r\n[1,]  0.20547945 -0.09589041 -0.01369863\r\n[2,] -0.08904110  0.30821918 -0.02739726\r\n[3,] -0.05479452 -0.04109589  0.13698630\r\n\r\nDependencia Linear\r\n\r\n\r\nv1 <- c(1, -1, 0, 0)\r\nv2 <- c(0, 0, 1, 1)\r\nv3 <- c(-2, 2, 1, 1)\r\nv4 <- c(1, 0, 0, 0)\r\n\r\nA <- matrix(data = cbind(v1, v2, v3, v4), ncol = 4)\r\n# Se o determinante de A for 0, os vetores são linearmente dependentes\r\ndet(A)\r\n\r\n\r\n[1] 0\r\n\r\nv5 <- c(2, -3, 2, 2)\r\nAhat <- cbind(A, v5)\r\nAhat\r\n\r\n\r\n               v5\r\n[1,]  1 0 -2 1  2\r\n[2,] -1 0  2 0 -3\r\n[3,]  0 1  1 0  2\r\n[4,]  0 1  1 0  2\r\n\r\n# Como os postos são iguais (p = 3), o sistema é possivel.\r\n# Como o número de variáveis é maior que o posto (n > p), o sistema é indetemrinado.\r\n# Assim, v5 é combinação linear dos outros vetores.\r\nechelon(Ahat)\r\n\r\n\r\n              v5\r\n[1,] 1 0 -2 0  3\r\n[2,] 0 1  1 0  2\r\n[3,] 0 0  0 1 -1\r\n[4,] 0 0  0 0  0\r\n\r\nAutovalores\r\n\r\n\r\neigen(A)\r\n\r\n\r\neigen() decomposition\r\n$values\r\n[1]  2.2469796 -0.8019377  0.5549581  0.0000000\r\n\r\n$vectors\r\n           [,1]       [,2]       [,3]          [,4]\r\n[1,]  0.3913958 -0.2354615 -0.8346812 -8.164966e-01\r\n[2,] -0.6086042  0.7645385  0.1653188  4.082483e-01\r\n[3,] -0.4880626 -0.4242869 -0.3714681 -4.082483e-01\r\n[4,] -0.4880626 -0.4242869 -0.3714681  1.281975e-16\r\n\r\neigen(A)$vectors %>%\r\n  zapsmall(digits = 1)\r\n\r\n\r\n     [,1] [,2] [,3] [,4]\r\n[1,]  0.4 -0.2 -0.8 -0.8\r\n[2,] -0.6  0.8  0.2  0.4\r\n[3,] -0.5 -0.4 -0.4 -0.4\r\n[4,] -0.5 -0.4 -0.4  0.0\r\n\r\neigen(A)$values %>%\r\n  zapsmall(digits = 1)\r\n\r\n\r\n[1]  2.2 -0.8  0.6  0.0\r\n\r\nExercícios sobre estrutura de ontrole\r\nExercício 1\r\nElabore uma função que verifique que uma matriz é quadrada e que seja singular antes de calcular a sua inversa. Não atendendo a uma das condições, a função deverá mostrar uma mensagem alertando o problema. Além de pode usar a estrutura de conotrle if-else, há também uma função chamada ifelse() para processos condicionados curtos.\r\n\r\n\r\nA <- matrix(data = c(1, 5, 0, 0, 4, 2, 0, 0, 2), ncol = 3)\r\nB <- matrix(data = c(1, 5, 0, 0, 4, 2, 0, 0, 0), ncol = 3)\r\nC <- matrix(data = c(1, 5, 0, 0, 4, 2, 0, 0, 2), ncol = 2)\r\ndet(A)\r\n\r\n\r\n[1] 8\r\n\r\ndet(B)\r\n\r\n\r\n[1] 0\r\n\r\ndet(C)\r\n\r\n\r\nError in determinant.matrix(x, logarithm = TRUE, ...): 'x' must be a square matrix\r\n\r\ninversa <- function(A) {\r\n  \r\n  cond1 <- dim(A)[1] == dim(A)[2]\r\n\r\n  if (!cond1) {\r\n    stop(\"Matriz não quadrada\")\r\n  }\r\n  else\r\n    \r\n    cond2 <- det(A) != 0\r\n  \r\n    if (!cond2) {\r\n      stop(\"Matriz singular\")\r\n    }\r\n    else\r\n      matlib::inv(A)\r\n  \r\n}\r\n\r\ninversa(A)\r\n\r\n\r\n      [,1]  [,2] [,3]\r\n[1,]  1.00  0.00  0.0\r\n[2,] -1.25  0.25  0.0\r\n[3,]  1.25 -0.25  0.5\r\n\r\ninversa(B)\r\n\r\n\r\nError in inversa(B): Matriz singular\r\n\r\ninversa(C)\r\n\r\n\r\nError in inversa(C): Matriz não quadrada\r\n\r\nExercício 2\r\nTemos uma lista de n=100 pessoas, cujas notas de desempenho possuem uma média de 500 e um desvio padrão de 20. Com uma nota maior que 500, o candidato é considerado aprovado (“A”) e apto para o emprego, caso contrário, o seu status é de reprovado (“R”). Gere um vetor com as notas e a partir dele, usando a função ifelse(), gere um vetor com o resultado final para cada candidato (“A” ou “R”). O vetor com as notas pode ser produzido com a função rnorm().\r\n\r\n\r\nnotas <- rnorm(n = 100, mean = 500, sd = 20)\r\nnotas\r\n\r\n\r\n  [1] 526.3270 511.4801 516.5246 517.2575 475.5450 512.2344 490.5952\r\n  [8] 488.5419 497.9601 505.1940 531.8196 509.2128 495.6917 504.0212\r\n [15] 533.7617 536.1538 485.2179 511.9729 507.0139 508.2988 503.3499\r\n [22] 501.4606 469.7100 528.9623 514.7226 518.1238 462.0055 495.0727\r\n [29] 520.3872 466.1905 505.3716 528.3601 522.4470 521.4131 475.0385\r\n [36] 543.8303 488.5260 520.0508 514.4851 488.3699 498.4811 499.0524\r\n [43] 478.8888 512.7190 511.7143 516.2719 508.6608 483.7336 495.1102\r\n [50] 492.4429 494.5428 514.7768 485.0872 464.5737 448.4833 509.4191\r\n [57] 492.6039 492.6724 507.4947 501.8425 495.2574 494.3712 536.7571\r\n [64] 496.5883 493.5919 492.4008 468.5105 513.5221 513.2796 506.2140\r\n [71] 497.4249 522.0508 495.6376 486.4058 487.3021 466.7299 486.3172\r\n [78] 465.0135 497.1010 496.4338 508.4171 476.0948 543.1003 504.6420\r\n [85] 520.8046 495.7461 538.2288 532.4704 502.1349 513.3546 490.4029\r\n [92] 479.0554 498.0652 497.9108 459.1602 509.4008 493.6896 475.1451\r\n [99] 515.5652 509.2252\r\n\r\nresultado <- ifelse(test = notas > 500, yes = \"A\", no = \"R\")\r\nresultado\r\n\r\n\r\n  [1] \"A\" \"A\" \"A\" \"A\" \"R\" \"A\" \"R\" \"R\" \"R\" \"A\" \"A\" \"A\" \"R\" \"A\" \"A\" \"A\"\r\n [17] \"R\" \"A\" \"A\" \"A\" \"A\" \"A\" \"R\" \"A\" \"A\" \"A\" \"R\" \"R\" \"A\" \"R\" \"A\" \"A\"\r\n [33] \"A\" \"A\" \"R\" \"A\" \"R\" \"A\" \"A\" \"R\" \"R\" \"R\" \"R\" \"A\" \"A\" \"A\" \"A\" \"R\"\r\n [49] \"R\" \"R\" \"R\" \"A\" \"R\" \"R\" \"R\" \"A\" \"R\" \"R\" \"A\" \"A\" \"R\" \"R\" \"A\" \"R\"\r\n [65] \"R\" \"R\" \"R\" \"A\" \"A\" \"A\" \"R\" \"A\" \"R\" \"R\" \"R\" \"R\" \"R\" \"R\" \"R\" \"R\"\r\n [81] \"A\" \"R\" \"A\" \"A\" \"A\" \"R\" \"A\" \"A\" \"A\" \"A\" \"R\" \"R\" \"R\" \"R\" \"R\" \"A\"\r\n [97] \"R\" \"R\" \"A\" \"A\"\r\n\r\nExercício 3\r\nElabore uma função que calcule o cofator Aij de uma matriz A de ordem n.\r\n\r\n\r\nA <- matrix(data = c(1, 5, 0, 0, 4, 2, 0, 0, 2), ncol = 3)\r\nA\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    1    0    0\r\n[2,]    5    4    0\r\n[3,]    0    2    2\r\n\r\n\r\n\r\nmcof <- function(A) {\r\n  C <- matrix(nrow = dim(A)[1], ncol = dim(A)[2])\r\n  \r\n  for (i in 1:dim(A)[1]) {\r\n    for (j in 1:dim(A)[2]) {\r\n      B <- A[-i, -j]\r\n      C[i, j] <- det(B)*(-1)^outer(X = i, Y = j, FUN = \"+\")\r\n    }\r\n  }\r\n  return(C)\r\n}\r\nmcof(A)\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    8  -10   10\r\n[2,]    0    2   -2\r\n[3,]    0    0    4\r\n\r\n\r\n\r\nmcof <- function(A) {\r\n  C <- matrix(nrow = dim(A)[1], ncol = dim(A)[2])\r\n  \r\n  for (i in 1:dim(A)[1]) {\r\n    for (j in 1:dim(A)[2]) {\r\n      B <- A[-i, -j]\r\n      C[i, j] <- det(B)*(-1)^(i + j)\r\n    }\r\n  }\r\n  return(C)\r\n\r\n}\r\nmcof(A)\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    8  -10   10\r\n[2,]    0    2   -2\r\n[3,]    0    0    4\r\n\r\n\r\n\r\nmcof2 <- function(A) {\r\n  C <- matrix(nrow = dim(A)[1], ncol = dim(A)[2])\r\n  \r\n  for (i in 1:dim(A)[1]) {\r\n    for (j in 1:dim(A)[2]) {\r\n      C[i, j] <- cofactor(A, i, j)\r\n    }\r\n  }\r\n  return(C)\r\n}\r\nmcof2(A)\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    8  -10   10\r\n[2,]    0    2   -2\r\n[3,]    0    0    4\r\n\r\nExercícios Semana 3\r\nExercício 4\r\n\r\n\r\nA <- matrix(data = c(1, 5, 0, 0, 4, 2, 0, 0, 2), ncol = 3)\r\nA\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    1    0    0\r\n[2,]    5    4    0\r\n[3,]    0    2    2\r\n\r\nCalcule o determinante de A:\r\n\r\n\r\ndet(A)\r\n\r\n\r\n[1] 8\r\n\r\nObtenha a diagonal de A e calcule o produto dos seus elementos, usando a função prod().\r\n\r\n\r\ndiag(A)\r\n\r\n\r\n[1] 1 4 2\r\n\r\nprod(diag(A))\r\n\r\n\r\n[1] 8\r\n\r\nCompare os resultados de A) e B)\r\n\r\n\r\nc(det(A), prod(diag(A)))\r\n\r\n\r\n[1] 8 8\r\n\r\nPodemos afirmar que A é inversível?\r\n\r\nSim. Pois \\(det(A) \\ne 0\\)\r\n\r\n\r\ninv(A)\r\n\r\n\r\n      [,1]  [,2] [,3]\r\n[1,]  1.00  0.00  0.0\r\n[2,] -1.25  0.25  0.0\r\n[3,]  1.25 -0.25  0.5\r\n\r\nExercício 5\r\nGere duas matrizes de ordem n = 10, com valores inteiros aleatorios de distribuição uniforme no intervalo [−10, 10]. Verifique o teorema de Binet (a falsidade da propriedade distributiva da soma para o determinante de matrizes).\r\n\r\n\r\nA <- matrix(data = runif(n = 100, min = -10, max = 10), ncol = 10)\r\nB <- matrix(data = runif(n = 100, min = -10, max = 10), ncol = 10)\r\n\r\ndet(A)\r\n\r\n\r\n[1] -45333169666\r\n\r\ndet(B)\r\n\r\n\r\n[1] 73559478181\r\n\r\ndet(A + B)\r\n\r\n\r\n[1] 278527212872\r\n\r\ndet(A + B) == (det(A) + det(B))\r\n\r\n\r\n[1] FALSE\r\n\r\nExercício 6\r\nDetermine os autovalores e autovetores das matrizes a seguir:\r\n\r\n\r\n\r\nA <- matrix(data = c(3, 0, 0, -3, 3, 0, -4, 5, -1), ncol = 3)\r\nA\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    3   -3   -4\r\n[2,]    0    3    5\r\n[3,]    0    0   -1\r\n\r\neigen(A)\r\n\r\n\r\neigen() decomposition\r\n$values\r\n[1]  3  3 -1\r\n\r\n$vectors\r\n     [,1]         [,2]        [,3]\r\n[1,]    1 1.000000e+00  0.03901372\r\n[2,]    0 2.220446e-16 -0.78027431\r\n[3,]    0 0.000000e+00  0.62421945\r\n\r\ncbind(eigen(A)$values, diag(A))\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    3    3\r\n[2,]    3    3\r\n[3,]   -1   -1\r\n\r\nCompare os autovalores obtidos com a diagonal principal da matriz triangular superior. Por que acontece o observado?\r\nR: Porque a matriz é triangular, portanto o produto da diagonal princial é o único termo do determinante que não se anula.\r\n\r\n\r\n\r\nA <- matrix(data = c(-1, 2, 2, -4, -7, -4, 14, 14, 11), ncol = 3)\r\nA\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]   -1   -4   14\r\n[2,]    2   -7   14\r\n[3,]    2   -4   11\r\n\r\neigen(A)\r\n\r\n\r\neigen() decomposition\r\n$values\r\n[1]  9 -3 -3\r\n\r\n$vectors\r\n          [,1]       [,2]        [,3]\r\n[1,] 0.5773503 -0.9622504  0.09350413\r\n[2,] 0.5773503  0.1924501 -0.95370329\r\n[3,] 0.5773503  0.1924501 -0.28584439\r\n\r\ncbind(eigen(A)$values, diag(A))\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    9   -1\r\n[2,]   -3   -7\r\n[3,]   -3   11\r\n\r\nC )\r\n\r\n\r\nA <- matrix(data = c(1, -1, 1, 0, 0, 1, 2, 1, 2), ncol = 3)\r\nA\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    1    0    2\r\n[2,]   -1    0    1\r\n[3,]    1    1    2\r\n\r\neigen(A)\r\n\r\n\r\neigen() decomposition\r\n$values\r\n[1]  3 -1  1\r\n\r\n$vectors\r\n             [,1]       [,2]          [,3]\r\n[1,] 7.071068e-01  0.4082483  7.071068e-01\r\n[2,] 2.840404e-16  0.8164966 -7.071068e-01\r\n[3,] 7.071068e-01 -0.4082483 -1.727306e-16\r\n\r\ncbind(eigen(A)$values, diag(A))\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    3    1\r\n[2,]   -1    0\r\n[3,]    1    2\r\n\r\n\r\n\r\n\r\nA <- matrix(data = c(3, 0, 0, -3, 3, 0, -4, 5, -1), ncol = 3)\r\nB <- matrix(data = c(-1, 2, 2, -4, -7, -4, 14, 14, 11), ncol = 3)\r\nC <- matrix(data = c(1, -1, 1, 0, 0, 1, 2, 1, 2), ncol = 3)\r\n\r\navecA <- eigen(A)$vector\r\navecB <- eigen(B)$vector\r\navecC <- eigen(C)$vector\r\n\r\navecA\r\n\r\n\r\n     [,1]         [,2]        [,3]\r\n[1,]    1 1.000000e+00  0.03901372\r\n[2,]    0 2.220446e-16 -0.78027431\r\n[3,]    0 0.000000e+00  0.62421945\r\n\r\ndet(avecA)\r\n\r\n\r\n[1] 1.386046e-16\r\n\r\navecB\r\n\r\n\r\n          [,1]       [,2]        [,3]\r\n[1,] 0.5773503 -0.9622504  0.09350413\r\n[2,] 0.5773503  0.1924501 -0.95370329\r\n[3,] 0.5773503  0.1924501 -0.28584439\r\n\r\ndet(avecB)\r\n\r\n\r\n[1] 0.4452393\r\n\r\navecC\r\n\r\n\r\n             [,1]       [,2]          [,3]\r\n[1,] 7.071068e-01  0.4082483  7.071068e-01\r\n[2,] 2.840404e-16  0.8164966 -7.071068e-01\r\n[3,] 7.071068e-01 -0.4082483 -1.727306e-16\r\n\r\ndet(avecC)\r\n\r\n\r\n[1] -0.8164966\r\n\r\nOs determinantes são diferentes de 0, portanto os autovetores são linearmente independentes.\r\n\r\n\r\n\r\n",
      "last_modified": "2021-05-25T21:00:48-03:00"
    },
    {
      "path": "cobweb.html",
      "title": "Cobweb",
      "description": "Essa aula estuda o modelo de Cobweb e Expectativas adaptativas.\n",
      "author": [
        {
          "name": "Rafael Peixoto",
          "url": {}
        }
      ],
      "date": "04-23-2021",
      "contents": "\r\n\r\nContents\r\nCobweb\r\nExpectativas Adaptativas\r\nExercícios\r\n\r\n\r\n\r\nd-article p {\r\n  text-align: justify;\r\n  font-size: 16px;\r\n}\r\n\r\nd-article p code {\r\n  background: rgba(236, 236, 236, 0.8);\r\n}\r\n\r\nd-article div.sourceCode {\r\n  overflow: auto !important;\r\n}\r\n\r\nCobweb\r\nSe trata de um modelo cássico de oferta e demanda baseado nas seguintes hipóteses:\r\nFunções lineares;\r\nA oferta reage ao preço com um atraso de um período: a produção requer de um período fixo de tempo (agricultura);\r\nOs produtores acreditam que o preço se manterá no período seguinte e assim, a nova “safra” de produção será iniciada a partir desse preço:\r\n\\[\r\nS_t = a_1 + b_1 p_{t-1}\r\n\\]\r\nA demanda depende do preço atual:\r\n\\[\r\nD_t = a + b p_t\r\n\\]\r\nMarket clearing: a cada período o mercado determina o preço tal que a demanda absorva o produto ofertado:\r\n\\[\r\nD_t = S_t\r\n\\]\r\nCom isso, substituindo as duas primeiras equações na terceira, chegamos a uma equação emdiferença de primeira ordem em p:\r\n\\[\r\na + b p_t = a_1 + b_1 p_{t-1}\r\n\\]\r\nReescrevendo essa equação nos termos que estamos utilizando aqui (\\(p_t = y_t\\)):\r\n\\[\r\ny_{t+1} = \\frac{b_1}{b} \\times y_t + \\frac{a_1 - a}{b}\r\n\\]\r\nEssa equação possui a mesma forma que a equação não-homogêna (sem trend) que vimos anteriormente:\r\n\\[\r\ny_{t+1} = - a_0 \\times y_t + b\r\n\\]\r\nUtilizaremos, portanto, a função orbita:\r\n\r\n\r\n# Função que calcula a orbita de cada Eq em diferença\r\norbita <- function(a0, y0, b, t) {\r\n  \r\n  out <- vector(mode = \"numeric\", length = t)\r\n  out[1] <- y0\r\n  for (i in 1:t) {\r\n    out[i+1] <- ((-a0*out[i]) + b)\r\n  }\r\n  \r\n  return(out[-1])\r\n  \r\n}\r\n\r\n\r\n\r\n\r\n\r\n# Exemplo\r\norbita(a0 = 0.8, y0 = 1, b = 2, t = 20) %>%\r\n  ts() %>%\r\n  autoplot()\r\n\r\n\r\n\r\n\r\nVoltando ao modelo de Cobweb, vejamos um exemplo com os seguintes parâmetros:\r\n\r\n\r\na <- 0.2\r\nb <- -1\r\na1 <- 0.1\r\nb1 <- 0.5\r\np0 <- 1\r\nt <- 20\r\n\r\n\r\n\r\n\r\n\r\n# Plot\r\norbita(a0 = -(b1/b), y0 = p0, b = (a1 - a)/b, t = t) %>%\r\n  ts() %>%\r\n  autoplot()\r\n\r\n\r\n\r\n\r\nLembrando que estamos considerando \\(p_t = y_t\\), portanto esse gráfico diz respeito ao comportamento dos preços. Podemos também analisar o comportamento da oferta e da demanda, incluindo essas na função junto ao preço:\r\n\r\n\r\ncobweb <- function(a, b, a1, b1, p0, t) {\r\n  \r\n  p1 <- (b1/b)*p0 + (a1 - a)/b\r\n  \r\n  p <- vector(mode = \"numeric\", length = t)\r\n  p[1] <- p1\r\n  D <- vector(mode = \"numeric\", length = t)\r\n  D[1] <- a + b*p[1]\r\n  S <- vector(mode = \"numeric\", length = t)\r\n  S[1] <- a1 + b1*p0\r\n  \r\n  for (i in 1:t) {\r\n    p[i+1] <- (b1/b)*p[i] + (a1 - a)/b\r\n    D[i+1] <- a + b*p[i+1]\r\n    S[i+1] <- a1 + b1*p[i]\r\n  }\r\n  \r\n  cobweb <- cbind(p, D, S)\r\n  colnames(cobweb) <- c(\"Preço\", \"Demanda\", \"Oferta\")\r\n  \r\n  return(cobweb)\r\n  \r\n}\r\n\r\n\r\n\r\n\r\n\r\n# Exemplo\r\ncobweb(a = a, b = b, a1 = a1, b1 = b1, p0 = p0, t = t) %>%\r\n  ts() %>%\r\n  autoplot()\r\n\r\n\r\n\r\n\r\nAjustando o gráfico:\r\n\r\n\r\n# Exemplo\r\ncobweb(a = a, b = b, a1 = a1, b1 = b1, p0 = p0, t = t) %>%\r\n  ts() %>%\r\n  autoplot(facets = F) +\r\n    ggtitle(\"Modelo Cobweb\") + \r\n    xlab(\"t\") +\r\n    ylab(\"\") +\r\n    theme_hc() +\r\n    theme(plot.title = element_text(size = 15, hjust = 0.5, colour = \"black\"),\r\n          plot.subtitle = element_text(size = 10, hjust = 0.5, colour = \"black\"),\r\n          legend.position = \"top\") +\r\n    scale_colour_discrete(\"\") +\r\n    scale_x_continuous(breaks = seq(from = 0, to = 20, by = 2)) +\r\n    scale_y_continuous(breaks = seq(from = -1, to = 1, by = 0.2))\r\n\r\n\r\n\r\n\r\nNo gráfico com as três séries juntas, como a demanda e a oferta são iguais (pressuposto do modelo), elas se sobepõem.\r\nExpectativas Adaptativas\r\nNeste caso, como já visto, realizamos um refinamento do modelo anterior. Os produtores têm uma expectativa de preço \\(p^e\\), a partir da qual determinam os seus níveis de produção:\r\n\\[\r\nS_t = a_1 + b_1 \\times p_t^e\r\n\\]\r\nEstas expectativas são ajustadas a cada período de acordo com a discrepância entre o valor observado (realizado) e o valor esperado, com regra de variação dada por:\r\n\\[\r\np_t^e = \\beta p_{t-1} + (1 - \\beta) p_{t-1}^e \r\n\\]\r\nVimos que a solução analítica para \\(p^e_t\\) não é arbitrária. Mas, podemos analisar a dinâmica o modelo por simulação, contemplando assim, a todas as variáveis na análise numérica.\r\nPAra implementar esse modelo, basta adicionarmos essa equação à função cobweb que ja havíamos criado (além de modificar a equação do preço):\r\n\r\n\r\nexpec_adap <- function(a, b, a1, b1, p0, pe0, beta, t) {\r\n  \r\n  pe <- vector(mode = \"numeric\", length = t)\r\n  pe[1] <- pe0\r\n  \r\n  p1 <- (1 + beta*(b1/b - 1))*p0 + (a1 - a)*beta/b\r\n  \r\n  p <- vector(mode = \"numeric\", length = t)\r\n  p[1] <- p1\r\n  D <- vector(mode = \"numeric\", length = t)\r\n  D[1] <- a + b*p[1]\r\n  S <- vector(mode = \"numeric\", length = t)\r\n  S[1] <- a1 + b1*p0\r\n  \r\n  for (i in 1:t) {\r\n    p[i+1] <- (1 + beta*(b1/b - 1))*p[i] + (a1 - a)*beta/b\r\n    pe[i+1] <- beta*p[i] + (1-beta)*pe[i]\r\n    D[i+1] <- a + b*p[i+1]\r\n    S[i+1] <- a1 + b1*pe[i+1]\r\n  }\r\n  \r\n  expec_adap <- cbind(p, pe, D, S)\r\n  colnames(expec_adap) <- c(\"Preço\", \"Exp Preço\", \"Demanda\", \"Oferta\")\r\n  \r\n  return(expec_adap)\r\n  \r\n}\r\n\r\n\r\n\r\nVejamos um exemplo com os seguintes parâmetros:\r\n\r\n\r\na <- 0.2\r\nb <- -1\r\na1 <- 0.1\r\nb1 <- 0.5\r\np0 <- 2\r\nt <- 10\r\npe0 <- 3\r\nbeta <- 0.6\r\n\r\n\r\n\r\n\r\n\r\n# Exemplo\r\nexpec_adap(a = a, b = b, a1 = a1, b1 = b1, p0 = p0, pe0 = pe0, beta = beta, t = t) %>%\r\n  ts() %>%\r\n  autoplot()\r\n\r\n\r\n\r\n\r\nAjustando o gráfico:\r\n\r\n\r\nexpec_adap(a = a, b = b, a1 = a1, b1 = b1, p0 = p0, pe0 = pe0, beta = beta, t = t) %>%\r\n  ts() %>%\r\n  autoplot(facets = F) +\r\n    ggtitle(\"Exepctativas Adaptativas\") + \r\n    xlab(\"t\") +\r\n    ylab(\"\") +\r\n    theme_hc() +\r\n    theme(plot.title = element_text(size = 15, hjust = 0.5, colour = \"black\"),\r\n          plot.subtitle = element_text(size = 10, hjust = 0.5, colour = \"black\"),\r\n          legend.position = \"top\") +\r\n    scale_colour_discrete(\"\") +\r\n    scale_x_continuous(breaks = seq(from = 0, to = t, by = 1)) +\r\n    scale_y_continuous(breaks = seq(from = -1, to = 3, by = 0.5))\r\n\r\n\r\n\r\n\r\nExercícios\r\n1.\r\nSimule o modelo Cobweb considerando o preço normal. Pode por exemplo, testar os valores dos exercícios numéricos do Shone e do Gandolfo.\r\nComo, nesse modelo, o \\(a_0\\) é representado por \\(- \\frac{b_1}{b}\\), essa fração precisa ser menor, em módulo, que 1, para que o sistema não seja explosivo:\r\n\r\n\r\ncobweb(a = 2, b = -2, a1 = 1, b1 = 1.8, p0 = 4, t = 50) %>%\r\n  ts() %>%\r\n  autoplot(facets = F)\r\n\r\n\r\n\r\n\r\n\r\n\r\ncobweb(a = 2, b = -2, a1 = 1, b1 = 2, p0 = 4, t = 50) %>%\r\n  ts() %>%\r\n  autoplot(facets = F)\r\n\r\n\r\n\r\n\r\n\r\n\r\ncobweb(a = 2, b = -2, a1 = 1, b1 = 2.2, p0 = 4, t = 50) %>%\r\n  ts() %>%\r\n  autoplot(facets = F)\r\n\r\n\r\n\r\n\r\n2.\r\nSe sugere analisar as simulações com outros conjuntos de parâmetros e inicializações.\r\n\r\n\r\n\r\n",
      "last_modified": "2021-05-25T21:00:57-03:00"
    },
    {
      "path": "eqdiff.html",
      "title": "Equações em Diferença",
      "description": "Essa aula estuda Equações em Diferença.\n",
      "author": [
        {
          "name": "Rafael Peixoto",
          "url": {}
        }
      ],
      "date": "04-19-2021",
      "contents": "\r\n\r\nContents\r\nEquações Homogêneas\r\nAutomatizando esse processo\r\n\r\nEquações Não Homogêneas\r\nHomogênea x não-Homogênea\r\nExercícios\r\n\r\n\r\n\r\nd-article p {\r\n  text-align: justify;\r\n  font-size: 16px;\r\n}\r\n\r\nd-article p code {\r\n  background: rgba(236, 236, 236, 0.8);\r\n}\r\n\r\nd-article div.sourceCode {\r\n  overflow: auto !important;\r\n}\r\n\r\nEquações Homogêneas\r\nQueremos analisar a dinâmica resultante de uma equação em diferença de ordem 1, analisando valores diversos para o coeficiente \\(a_0\\):\r\n\\[\r\ny_{t+1} + a_0 y_t = 0\r\n\\] Já conhecemos a solução analítica:\r\n\\[\r\ny_t = A(-a_0)^t\r\n\\] tal que, para \\(t = 0\\), \\(A = y_0\\), com \\(y_0\\) representando a condição inicial (se conhecida).\r\nCriando as séries\r\nMas também podemos oferecer a solução numérica via simulação, implementando diretamente a equação que define a dinâmica da sequência de valores (a série temporal):\r\n\r\n\r\n### Parâmetros e Condições iniciais\r\n\r\n# Coeficiente\r\na0 <- c(2, -2, 1/3, -1/3, 1, -1)\r\n\r\n# Número de iterações\r\nt <- 10\r\n\r\n# Valor inicial\r\ny0 <- 0.025\r\n\r\n\r\n\r\n\r\n\r\n### Séries temporais geradas a partir de cada coeficiente\r\n\r\n# Séries\r\ny1 <- (a0[1])^(1:t) * y0\r\ny2 <- (a0[2])^(1:t) * y0\r\ny3 <- (a0[3])^(1:t) * y0\r\ny4 <- (a0[4])^(1:t) * y0\r\ny5 <- (a0[5])^(1:t) * y0\r\ny6 <- (a0[6])^(1:t) * y0\r\n\r\n# Data-Frame (em forma de ts)\r\nydata <- data.frame(y1, y2, y3, y4, y5, y6) %>%\r\n  as.ts()\r\n\r\n\r\n\r\n\r\n\r\n# Plot das séries geradas\r\nautoplot(ydata, facets = F) +\r\n  ggtitle(\"Equações de Ordem 1\") +\r\n  xlab(\"t\") +\r\n  ylab(\"Y\") +\r\n  theme_hc() +\r\n  theme(plot.title = element_text(size = 15, hjust = 0.5, colour = \"black\"),\r\n        plot.subtitle = element_text(size = 10, hjust = 0.5, colour = \"black\"),\r\n        legend.position = \"right\") +\r\n  scale_colour_discrete(\"\") +\r\n  scale_x_continuous(breaks = seq(from = 0, to = t, by = 1)) +\r\n  scale_y_continuous(breaks = seq(from = -15, to = 25, by = 5))\r\n\r\n\r\n\r\n\r\nAutomatizando esse processo\r\n\r\n\r\n# Através de Loop\r\nydata <- ts(matrix(NA, nrow = length(1:t), ncol = length(a0)))\r\n\r\nfor (i in 1:length(a0)) {\r\n  ydata[, i] <- (a0[i])^(1:t) * y0\r\n}\r\n\r\n\r\n\r\n\r\n\r\n# Através de Função\r\nyfunchomo <- function(t, a0, y0) {\r\n  \r\n  ydata <- ts(matrix(NA, nrow = length(1:t), ncol = length(a0)))\r\n  \r\n  for (i in 1:length(a0)) {\r\n    ydata[, i] <- (a0[i])^(1:t) * y0\r\n  }\r\n  \r\n  colnames(ydata) <- c(paste0(rep(\"a0: \"), round(a0, 1)))\r\n  \r\n  ydata <- rbind(y0, ydata) %>% ts(start = 0)\r\n  \r\n  return(ydata)\r\n  \r\n}\r\n\r\n\r\n\r\n\r\n\r\n# Exemplo \r\nyfunchomo(t = 5, a0 = -2:2, y0 = 0.8)\r\n\r\n\r\nTime Series:\r\nStart = 0 \r\nEnd = 5 \r\nFrequency = 1 \r\n  a0: -2 a0: -1 a0: 0 a0: 1 a0: 2\r\n0    0.8    0.8   0.8   0.8   0.8\r\n1   -1.6   -0.8   0.0   0.8   1.6\r\n2    3.2    0.8   0.0   0.8   3.2\r\n3   -6.4   -0.8   0.0   0.8   6.4\r\n4   12.8    0.8   0.0   0.8  12.8\r\n5  -25.6   -0.8   0.0   0.8  25.6\r\n\r\n\r\n\r\n# Exemplo direto do Plot\r\nautoplot(yfunchomo(t = 5, a0 = seq(-1.5, 1.5, 0.5), y0 = 0.8), facets = F) +\r\n  ggtitle(\"Equações de Ordem 1\") +\r\n  xlab(\"t\") +\r\n  ylab(\"Y\") +\r\n  theme_hc() +\r\n  theme(plot.title = element_text(size = 15, hjust = 0.5, colour = \"black\"),\r\n        plot.subtitle = element_text(size = 10, hjust = 0.5, colour = \"black\"),\r\n        legend.position = \"right\") +\r\n  scale_colour_discrete(\"\")\r\n\r\n\r\n\r\n\r\nVoltando ao exemplo do início:\r\n\r\n\r\nydata <- yfunchomo(t = t, a0 = a0, y0 = y0)\r\n\r\n\r\n\r\n\r\n\r\nautoplot(ydata, facets = F) +\r\n  ggtitle(\"Equações de Ordem 1\") +\r\n  xlab(\"t\") +\r\n  ylab(\"Y\") +\r\n  theme_hc() +\r\n  theme(plot.title = element_text(size = 15, hjust = 0.5, colour = \"black\"),\r\n        plot.subtitle = element_text(size = 10, hjust = 0.5, colour = \"black\"),\r\n        legend.position = \"right\") +\r\n  scale_colour_discrete(\"\") +\r\n  scale_x_continuous(breaks = seq(from = 0, to = t, by = 1)) +\r\n  scale_y_continuous(breaks = seq(from = -15, to = 25, by = 5))\r\n\r\n\r\n\r\n\r\nEquações Não Homogêneas\r\nQueremos analisar uma série temporal \\(y_t\\), resultante de uma equação em diferença de ordem 1:\r\n\\[\r\ny_{t+1} + a_0 \\times y_t = b\r\n\\]\r\nOu:\r\n\\[\r\ny_{t+1} = - a_0 \\times y_t + b\r\n\\] Por exemplo:\r\n\\[\r\ny_{t+1} - 1.1 \\times y_t = 2\r\n\\]\r\nPara isso, precisamos antes definir todos os nossos parâmetros iniciais: quantidade de períodos de simulação, as condições iniciais, e demais coeficientes da equação e auxiliares. Neste caso, \\(a_0 = -1.1\\) e a única diferença com relação ao caso homogêneo é o acréscimo de um termo independente \\(g(t) = b = 2\\).\r\nSeria possível reusar a função yfunchomo criada acima caso soubéssemos o \\(\\overset{*}{y}\\) — ou seja, o steady state. Como usualmente a priori não sabemos esse valor, tempos que criar uma função que itere os valores de cada período.\r\n\r\n\r\n# Função que calcula a orbita de cada Eq em diferença\r\norbita <- function(m, y0, b, t) {\r\n  \r\n  out <- vector(mode = \"numeric\", length = t)\r\n  out[1] <- y0\r\n  for (i in 1:t) {\r\n    out[i+1] <- ((-m*out[i]) + b)\r\n  }\r\n  \r\n  return(out[-1])\r\n  \r\n}\r\n\r\n\r\n\r\n\r\n\r\n# Exemplo\r\norbita(m = -1.1, y0 = 1, b = 2, t = 10)\r\n\r\n\r\n [1]  3.10000  5.41000  7.95100 10.74610 13.82071 17.20278 20.92306\r\n [8] 25.01537 29.51690 34.46859\r\n\r\n\r\n\r\n# Função que junta as diversas orbitas\r\nyfunc <- function(t, a0, y0, b) {\r\n  \r\n  ydata <- ts(matrix(NA, nrow = length(1:t), ncol = length(a0)))\r\n  \r\n  for (i in 1:length(a0)) {\r\n    ydata[, i] <- orbita(m = a0[i], y0 = y0, b = b, t = t)\r\n  }\r\n  \r\n  colnames(ydata) <- c(paste0(rep(\"a0: \"), round(a0, 1)))\r\n  \r\n  ydata <- rbind(y0, ydata) %>% ts(start = 0)\r\n  \r\n  return(ydata)\r\n  \r\n}\r\n\r\n\r\n\r\n\r\n\r\n# Exemplo\r\nyfunc(t = 10, a0 = -1:1, y0 = 0.5, b = 2)\r\n\r\n\r\nTime Series:\r\nStart = 0 \r\nEnd = 10 \r\nFrequency = 1 \r\n   a0: -1 a0: 0 a0: 1\r\n 0    0.5   0.5   0.5\r\n 1    2.5   2.0   1.5\r\n 2    4.5   2.0   0.5\r\n 3    6.5   2.0   1.5\r\n 4    8.5   2.0   0.5\r\n 5   10.5   2.0   1.5\r\n 6   12.5   2.0   0.5\r\n 7   14.5   2.0   1.5\r\n 8   16.5   2.0   0.5\r\n 9   18.5   2.0   1.5\r\n10   20.5   2.0   0.5\r\n\r\n\r\n\r\n# Exemplo direto do Plot\r\nautoplot(yfunc(t = 5, a0 = c(-1, 0.5, -0.5, 1), y0 = 0.8, b = 1), facets = F) +\r\n  ggtitle(\"Equações de Ordem 1\") +\r\n  xlab(\"t\") +\r\n  ylab(\"Y\") +\r\n  theme_hc() +\r\n  theme(plot.title = element_text(size = 15, hjust = 0.5, colour = \"black\"),\r\n        plot.subtitle = element_text(size = 10, hjust = 0.5, colour = \"black\"),\r\n        legend.position = \"right\") +\r\n  scale_colour_discrete(\"\")\r\n\r\n\r\n\r\n\r\nHomogênea x não-Homogênea\r\n\r\n\r\n# Exemplo do início da seção\r\nautoplot(object = ts(cbind(yfunc(t = 5, a0 = -1.1, y0 = 1, b = 2),\r\n                           yfunc(t = 5, a0 = -1.1, y0 = 1, b = 0))),\r\n         facets = F) +\r\n  ggtitle(\"Equações de Ordem 1\") +\r\n  xlab(\"t\") +\r\n  ylab(\"Y\") +\r\n  theme_hc() +\r\n  theme(plot.title = element_text(size = 15, hjust = 0.5, colour = \"black\"),\r\n        plot.subtitle = element_text(size = 10, hjust = 0.5, colour = \"black\"),\r\n        legend.position = \"top\") +\r\n  scale_colour_discrete(\"\", labels = c(\"Não-Homogênea\", \"Homogênea\")) +\r\n  scale_x_continuous(breaks = seq(from = 0, to = t, by = 2)) +\r\n  scale_y_continuous(breaks = seq(from = -6, to = 15, by = 2))\r\n\r\n\r\n\r\n\r\nExercícios\r\nA partir das rotinas anteriores, analise a dinâmica e o estado estacionário das séries cujas dinâmicas são resultado das equações a seguir:\r\n1.\r\n\\(y_t + a_0 \\times y_{t-1} = \\frac{1}{4}\\), sendo que \\(y_0 = 2\\) e \\(a_0 = 0.25\\)\r\nR: Pela equação, \\(b = \\frac{1}{4}\\)\r\n\r\n\r\nnaohomo1 <- yfunc(t = 10, a0 = 0.25, y0 = 2, b = 1/4)\r\nhomo1 <- yfunc(t = 10, a0 = 0.25, y0 = 2, b = 0)\r\n\r\n\r\n\r\n\r\n\r\nresult1 <- cbind(naohomo1, homo1)\r\ncolnames(result1) <- c(\"Não-Homogênea\", \"Homogênea\")\r\nresult1\r\n\r\n\r\nTime Series:\r\nStart = 0 \r\nEnd = 10 \r\nFrequency = 1 \r\n   Não-Homogênea     Homogênea\r\n 0     2.0000000  2.000000e+00\r\n 1    -0.2500000 -5.000000e-01\r\n 2     0.3125000  1.250000e-01\r\n 3     0.1718750 -3.125000e-02\r\n 4     0.2070312  7.812500e-03\r\n 5     0.1982422 -1.953125e-03\r\n 6     0.2004395  4.882812e-04\r\n 7     0.1998901 -1.220703e-04\r\n 8     0.2000275  3.051758e-05\r\n 9     0.1999931 -7.629395e-06\r\n10     0.2000017  1.907349e-06\r\n\r\n\r\n\r\nautoplot(result1, facets = F)\r\n\r\n\r\n\r\n\r\nLimpando o gráfico:\r\n\r\n\r\nautoplot(object = result1, facets = F) +\r\n  ggtitle(expression(y[t] + (0.25 %*% y[t-1]) == frac(1,4))) +\r\n  xlab(\"t\") +\r\n  ylab(\"Y\") +\r\n  theme_hc() +\r\n  theme(plot.title = element_text(size = 15, hjust = 0.5, colour = \"black\"),\r\n        plot.subtitle = element_text(size = 10, hjust = 0.5, colour = \"black\"),\r\n        legend.position = \"top\") +\r\n  scale_colour_discrete(\"\") +\r\n  scale_x_continuous(breaks = seq(from = 0, to = 10, by = 2)) +\r\n  scale_y_continuous(breaks = seq(from = -1, to = 2, by = 0.25))\r\n\r\n\r\n\r\n\r\n2.\r\nComo faria para simular a série \\(y_{t+1} = (−a0 \\times y_t) + k_0 + (k_1 \\times t)\\)? Teste para diversas condições inicials e analise o resultado.\r\nR: Primeiramente, devemos mudar nossa função orbita, afim de acomodar o termo \\(k_1 \\times t\\):\r\n\r\n\r\n# Função que calcula a orbita de cada Eq em diferença\r\norbita_trend <- function(m, y0, k0, k1, t) {\r\n  \r\n  out <- vector(mode = \"numeric\", length = t)\r\n  out[1] <- y0\r\n  trend <- rep(x = 0, t)\r\n  trend[1:t] <- 1:t\r\n  for (i in 1:t) {\r\n    out[i+1] <- (-m*out[i] + k0 + k1*trend[i])\r\n  }\r\n  \r\n  return(out[-1])\r\n  \r\n}\r\n\r\n\r\n\r\n\r\n\r\n# Teste Orbita\r\norbita_trend(m = 0.5, y0 = 2, k0 = 0, k1 = 1, t = 20)\r\n\r\n\r\n [1]  0.000000  2.000000  2.000000  3.000000  3.500000  4.250000\r\n [7]  4.875000  5.562500  6.218750  6.890625  7.554688  8.222656\r\n[13]  8.888672  9.555664 10.222168 10.888916 11.555542 12.222229\r\n[19] 12.888885 13.555557\r\n\r\n\r\n\r\n# Teste plot\r\nautoplot(ts(orbita_trend(m = 0.5, y0 = 2, k0 = 0, k1 = 1, t = 20)))\r\n\r\n\r\n\r\n\r\nAgora, voltando a questão, vamos testar para diversos valores de \\(k_0\\) e \\(k_1\\):\r\n\r\n\r\ns1 <- ts(orbita_trend(m = 0.9, y0 = 2, k0 = 0, k1 = 0, t = 20))\r\ns2 <- ts(orbita_trend(m = 0.9, y0 = 2, k0 = 1, k1 = 0, t = 20))\r\ns3 <- ts(orbita_trend(m = 0.9, y0 = 2, k0 = 0, k1 = 1, t = 20))\r\ns4 <- ts(orbita_trend(m = 0.9, y0 = 2, k0 = 1, k1 = 1, t = 20))\r\n\r\nseries <- cbind(s1, s2, s3, s4)\r\ncolnames(series) <- c(\"(0,0)\", \"(1,0)\", \"(0,1)\", \"(1,1)\")\r\n\r\n\r\n\r\n\r\n\r\nautoplot(object = series, facets = F) +\r\n  ggtitle(expression(y[t+1] == (-a[0] %*% y[t]) +k[0] + (k[1] %*%  t)), \r\n          subtitle = expression(list(k[0],k[1]))) +\r\n  xlab(\"t\") +\r\n  ylab(\"Y\") +\r\n  theme_hc() +\r\n  theme(plot.title = element_text(size = 15, hjust = 0.5, colour = \"black\"),\r\n        plot.subtitle = element_text(size = 10, hjust = 0.5, colour = \"black\"),\r\n        legend.position = \"top\") +\r\n  scale_colour_discrete(\"\") +\r\n  scale_x_continuous(breaks = seq(from = 0, to = 20, by = 1)) +\r\n  scale_y_continuous(breaks = seq(from = -1, to = 20, by = 1))\r\n\r\n\r\n\r\n\r\n3.\r\n\\(y{t+1} = 0.9 · y_t + X_t\\); com \\(Xt \\sim N(0, σ^2)\\). Teste para valores diferentes de σ2 e analise o seu efeito sobre a dinâmica da série.\r\nR: Primeiramente, devemos mudar nossa função orbita, afim de acomodar o termo \\(X_t\\):\r\n\r\n\r\n# Função que calcula a orbita de cada Eq em diferença\r\norbita_estoc <- function(m, y0, s2, t) {\r\n  \r\n  out <- vector(mode = \"numeric\", length = t)\r\n  out[1] <- y0\r\n  for (i in 1:t) {\r\n    out[i+1] <- (-m*out[i] + rnorm(n = 1, mean = 0, sd = sqrt(s2)))\r\n  }\r\n  \r\n  return(out[-1])\r\n  \r\n}\r\n\r\n\r\n\r\n\r\n\r\n# Teste Orbita\r\norbita_estoc(m = 0.5, y0 = 2, s2 = 2, t = 20)\r\n\r\n\r\n [1] -2.15713803  1.22362705 -3.00974283 -0.73742478 -0.06063951\r\n [6]  0.07085452  1.57912891 -1.53401160  1.53418156 -1.89196940\r\n[11] -0.49913978  0.11439277  0.66343057  2.44374523 -0.18781859\r\n[16]  1.36782514  0.38482822  1.03862576  0.43882160  2.06115737\r\n\r\n\r\n\r\n# Teste plot\r\nautoplot(ts(orbita_estoc(m = 0.5, y0 = 2, s2 = 2, t = 20)))\r\n\r\n\r\n\r\n\r\nAgora, voltando a questão, vamos testar para diversos valores de \\(s^2\\)\r\n\r\n\r\ns21 <- ts(orbita_estoc(m = 0.5, y0 = 2, s2 = 0, t = 20))\r\ns22 <- ts(orbita_estoc(m = 0.5, y0 = 2, s2 = 2, t = 20))\r\ns23 <- ts(orbita_estoc(m = 0.5, y0 = 2, s2 = 4, t = 20))\r\ns24 <- ts(orbita_estoc(m = 0.5, y0 = 2, s2 = 6, t = 20))\r\n\r\nseriess2 <- cbind(s21, s22, s23, s24)\r\ncolnames(seriess2) <- c(paste0(rep(\"s2: \", 4), seq(0, 6, 2)))\r\n\r\n\r\n\r\n\r\n\r\nautoplot(object = seriess2, facets = F) +\r\n  ggtitle(expression(y[t+1] == (-a[0] %*% y[t]) + X[t])) +\r\n  xlab(\"t\") +\r\n  ylab(\"Y\") +\r\n  theme_hc() +\r\n  theme(plot.title = element_text(size = 15, hjust = 0.5, colour = \"black\"),\r\n        plot.subtitle = element_text(size = 10, hjust = 0.5, colour = \"black\"),\r\n        legend.position = \"top\") +\r\n  scale_colour_discrete(\"\") +\r\n  scale_x_continuous(breaks = seq(from = 0, to = 20, by = 1)) +\r\n  scale_y_continuous(breaks = seq(from = -10, to = 10, by = 1))\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "last_modified": "2021-05-25T21:01:12-03:00"
    },
    {
      "path": "index.html",
      "title": "Economia Matemática",
      "author": [
        {
          "name": "Rafael Peixoto",
          "url": {}
        }
      ],
      "date": "03-26-2021",
      "contents": "\r\n\r\n\r\nd-article p {\r\n  text-align: center;\r\n  font-size: 26px;\r\n}\r\n\r\nd-article p code {\r\n  background: rgba(236, 236, 236, 0.8);\r\n}\r\n\r\nd-article div.sourceCode {\r\n  overflow: auto !important;\r\n}\r\n\r\n\r\nEsse site acompanha as aulas da disciplina Economia Matemática (HO-012).\r\n\r\n\r\n\r\n",
      "last_modified": "2021-05-25T21:01:13-03:00"
    },
    {
      "path": "jdv.html",
      "title": "O Jogo da Vida",
      "description": "Essa aula explora o \"Jogo da Vida\", proposto por John H. Conway na década de 70.\n",
      "author": [
        {
          "name": "Rafael Peixoto",
          "url": {}
        }
      ],
      "date": "04-18-2021",
      "contents": "\r\n\r\nContents\r\nIntrodução\r\nO jogo\r\nVizinhança\r\nAtualização dos estados\r\nAutomatizando o jogo\r\nExemplos\r\n\r\n\r\n\r\n\r\nd-article p {\r\n  text-align: justify;\r\n  font-size: 16px;\r\n}\r\n\r\nd-article p code {\r\n  background: rgba(236, 236, 236, 0.8);\r\n}\r\n\r\nd-article div.sourceCode {\r\n  overflow: auto !important;\r\n}\r\n\r\nIntrodução\r\nO Jogo da Vida consiste em um conjunto de agentes distribuidos em um grid de tamanho n previamente definido. Cada agente, representado em um quadrado desse grid, é caracterizado por um dos dois estados possíveis: morto ou vivo.\r\n\r\n\r\n# Criando o Grid\r\nn <- 5\r\ngridIni <- expand.grid(x = 1:n, y = 1:n)\r\ngridIni$z <- runif(n = n^2, min = 0, max = 1) %>% \r\n  round(digits = 0)\r\n\r\n\r\n\r\n\r\n\r\n# Plotando o Grid\r\nggplot(data = gridIni) +\r\n  aes(x = x, y = y, fill = factor(z)) + \r\n  geom_tile(colour = \"black\", size = 0.8) +\r\n  coord_equal() +\r\n  theme_void() +\r\n  scale_fill_brewer(breaks = c(0, 1), \r\n                    labels = c(\"0 - Morto\", \"1 - Vivo\"),\r\n                    type = \"seq\",\r\n                    direction = 1, \r\n                    palette = 12) + \r\n  labs(title = \"Geração 0\", x = NULL, y = NULL, fill = \"Life\") +\r\n  geom_text(mapping = aes(label = 1:(n^2))) -> plot0\r\n\r\nplot0\r\n\r\n\r\n\r\n\r\nO jogo\r\nO jogo consiste em atualizar os estados dos agentes a cada geração, o que ocorre a partir dos estados de seus vizinhos:\r\nSe o agente tem menos de dois vizinhos vivos, ele morre\r\nSe tem mais de três vizinhos vivos, ele morre\r\nSe tem exatamente dois vizinhos vivos, ele mantêm seu estado atutal (vivo ou morto)\r\nSe tem exatamente três vizinhos vivos, a célula muda seu estado de morto para vivo , ou permanece vivo se já está nesse estado.\r\nVizinhança\r\nAs matrizes construídas a seguir servem para identificar os vizinhos (com seus respectivos estados) de cada agente.\r\n\r\n\r\n# Matriz ampliada\r\nmat <- matrix(data = 1:n^2, nrow = n)\r\nmat.pad <- rbind(NA, cbind(NA, mat, NA), NA)\r\nmat.pad\r\n\r\n\r\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7]\r\n[1,]   NA   NA   NA   NA   NA   NA   NA\r\n[2,]   NA    1    6   11   16   21   NA\r\n[3,]   NA    2    7   12   17   22   NA\r\n[4,]   NA    3    8   13   18   23   NA\r\n[5,]   NA    4    9   14   19   24   NA\r\n[6,]   NA    5   10   15   20   25   NA\r\n[7,]   NA   NA   NA   NA   NA   NA   NA\r\n\r\n\r\n\r\n# Matriz com os vizinhos\r\nind <- 2:(n + 1)\r\nvizinhos <- rbind(N  = as.vector(mat.pad[ind - 1, ind    ]),\r\n                  NE = as.vector(mat.pad[ind - 1, ind + 1]),\r\n                  E  = as.vector(mat.pad[ind    , ind + 1]),\r\n                  SE = as.vector(mat.pad[ind + 1, ind + 1]),\r\n                  S  = as.vector(mat.pad[ind + 1, ind    ]),\r\n                  SO = as.vector(mat.pad[ind + 1, ind - 1]),\r\n                  O  = as.vector(mat.pad[ind    , ind - 1]),\r\n                  NO = as.vector(mat.pad[ind - 1, ind - 1]))\r\n\r\nvizinhos\r\n\r\n\r\n   [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]\r\nN    NA    1    2    3    4   NA    6    7    8     9    NA    11\r\nNE   NA    6    7    8    9   NA   11   12   13    14    NA    16\r\nE     6    7    8    9   10   11   12   13   14    15    16    17\r\nSE    7    8    9   10   NA   12   13   14   15    NA    17    18\r\nS     2    3    4    5   NA    7    8    9   10    NA    12    13\r\nSO   NA   NA   NA   NA   NA    2    3    4    5    NA     7     8\r\nO    NA   NA   NA   NA   NA    1    2    3    4     5     6     7\r\nNO   NA   NA   NA   NA   NA   NA    1    2    3     4    NA     6\r\n   [,13] [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23]\r\nN     12    13    14    NA    16    17    18    19    NA    21    22\r\nNE    17    18    19    NA    21    22    23    24    NA    NA    NA\r\nE     18    19    20    21    22    23    24    25    NA    NA    NA\r\nSE    19    20    NA    22    23    24    25    NA    NA    NA    NA\r\nS     14    15    NA    17    18    19    20    NA    22    23    24\r\nSO     9    10    NA    12    13    14    15    NA    17    18    19\r\nO      8     9    10    11    12    13    14    15    16    17    18\r\nNO     7     8     9    NA    11    12    13    14    NA    16    17\r\n   [,24] [,25]\r\nN     23    24\r\nNE    NA    NA\r\nE     NA    NA\r\nSE    NA    NA\r\nS     25    NA\r\nSO    20    NA\r\nO     19    20\r\nNO    18    19\r\n\r\n\r\n\r\n# Matriz com os estados dos vizinhos\r\nestados.vizinhos <- c()\r\nfor (i in 1:n^2) {\r\n  estados.vizinhos <- cbind(estados.vizinhos, gridIni[vizinhos[, i], 3])\r\n}\r\nestados.vizinhos\r\n\r\n\r\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]\r\n[1,]   NA    0    0    1    1   NA    1    0    1     0    NA     1\r\n[2,]   NA    1    0    1    0   NA    1    0    0     0    NA     0\r\n[3,]    1    0    1    0    0    1    0    0    0     0     0     1\r\n[4,]    0    1    0    0   NA    0    0    0    0    NA     1     1\r\n[5,]    0    1    1    0   NA    0    1    0    0    NA     0     0\r\n[6,]   NA   NA   NA   NA   NA    0    1    1    0    NA     0     1\r\n[7,]   NA   NA   NA   NA   NA    0    0    1    1     0     1     0\r\n[8,]   NA   NA   NA   NA   NA   NA    0    0    1     1    NA     1\r\n     [,13] [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22]\r\n[1,]     0     0     0    NA     0     1     1     1    NA     1\r\n[2,]     1     1     1    NA     1     0     1     1    NA    NA\r\n[3,]     1     1     1     1     0     1     1     0    NA    NA\r\n[4,]     1     1    NA     0     1     1     0    NA    NA    NA\r\n[5,]     0     0    NA     1     1     1     1    NA     0     1\r\n[6,]     0     0    NA     0     0     0     0    NA     1     1\r\n[7,]     1     0     0     1     0     0     0     0     0     1\r\n[8,]     0     1     0    NA     1     0     0     0    NA     0\r\n     [,23] [,24] [,25]\r\n[1,]     0     1     1\r\n[2,]    NA    NA    NA\r\n[3,]    NA    NA    NA\r\n[4,]    NA    NA    NA\r\n[5,]     1     0    NA\r\n[6,]     1     1    NA\r\n[7,]     1     1     1\r\n[8,]     1     1     1\r\n\r\n\r\n\r\n# Trocar os 'NA' por 0\r\nestados.vizinhos0 <- estados.vizinhos\r\nestados.vizinhos0[is.na(estados.vizinhos0)] <- 0\r\nestados.vizinhos0\r\n\r\n\r\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]\r\n[1,]    0    0    0    1    1    0    1    0    1     0     0     1\r\n[2,]    0    1    0    1    0    0    1    0    0     0     0     0\r\n[3,]    1    0    1    0    0    1    0    0    0     0     0     1\r\n[4,]    0    1    0    0    0    0    0    0    0     0     1     1\r\n[5,]    0    1    1    0    0    0    1    0    0     0     0     0\r\n[6,]    0    0    0    0    0    0    1    1    0     0     0     1\r\n[7,]    0    0    0    0    0    0    0    1    1     0     1     0\r\n[8,]    0    0    0    0    0    0    0    0    1     1     0     1\r\n     [,13] [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22]\r\n[1,]     0     0     0     0     0     1     1     1     0     1\r\n[2,]     1     1     1     0     1     0     1     1     0     0\r\n[3,]     1     1     1     1     0     1     1     0     0     0\r\n[4,]     1     1     0     0     1     1     0     0     0     0\r\n[5,]     0     0     0     1     1     1     1     0     0     1\r\n[6,]     0     0     0     0     0     0     0     0     1     1\r\n[7,]     1     0     0     1     0     0     0     0     0     1\r\n[8,]     0     1     0     0     1     0     0     0     0     0\r\n     [,23] [,24] [,25]\r\n[1,]     0     1     1\r\n[2,]     0     0     0\r\n[3,]     0     0     0\r\n[4,]     0     0     0\r\n[5,]     1     0     0\r\n[6,]     1     1     0\r\n[7,]     1     1     1\r\n[8,]     1     1     1\r\n\r\n\r\n\r\n# Número de vizinhos vivos para cada agente\r\nvivos <- c()\r\nfor (i in 1:n^2) {\r\n  vivos <- cbind(vivos, \r\n                 length(estados.vizinhos0[, i][estados.vizinhos0[, i] == 1]))\r\n}\r\nvivos\r\n\r\n\r\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]\r\n[1,]    1    3    2    2    1    1    4    2    3     1     2     5\r\n     [,13] [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22]\r\n[1,]     4     4     2     3     4     4     4     2     1     4\r\n     [,23] [,24] [,25]\r\n[1,]     4     4     3\r\n\r\nAtualização dos estados\r\nSeguindo as quatro regras apontadas anteriormente, assim fica o próximo período:\r\n\r\n\r\n# Criando novo Grid\r\ngridFin <- expand.grid(x = 1:n, y = 1:n)\r\ngridFin$z <- c(NA)\r\n\r\n# Atualizando os estados de cada agente\r\nfor (i in 1:n^2) {\r\n  if (vivos[i] < 2) {\r\n    gridFin$z[i] <- 0\r\n  }\r\n  if (vivos[i] > 3) {\r\n    gridFin$z[i] <- 0\r\n  }\r\n  if (vivos[i] == 2) {\r\n    gridFin$z[i] <- gridIni$z[i]\r\n  }\r\n  if (vivos[i] == 3) {\r\n    gridFin$z[i] <- 1\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n# Plotando novo Grid\r\nggplot(data = gridFin) +\r\n  aes(x = x, y = y, fill = factor(z)) + \r\n  geom_tile(colour = \"black\", size = 0.8) +\r\n  coord_equal() +\r\n  theme_void() +\r\n  scale_fill_brewer(breaks = c(0, 1), \r\n                    labels = c(\"0 - Morto\", \"1 - Vivo\"),\r\n                    type = \"seq\",\r\n                    direction = 1, \r\n                    palette = 12) + \r\n  labs(title = \"Geração 1\", x = NULL, y = NULL, fill = \"Life\") +\r\n  geom_text(mapping = aes(label = 1:(n^2))) -> plot1\r\n\r\nplot1\r\n\r\n\r\n\r\n\r\nComparando as duas gerações:\r\n\r\n\r\n# Plots lado a lado\r\ngrid.arrange(plot0, plot1, ncol = 2)\r\n\r\n\r\n\r\n\r\nAutomatizando o jogo\r\nAgora que conseguimos codificar as regras do jogo, podemos escrever funções que realizam os passos necessários de forma automática.\r\n\r\n\r\n# Função que gera o número de vizinhos vivos de cada agente\r\nnViz <- function(n, gridI) {\r\n  \r\n  mat <- matrix(data = 1:n^2, nrow = n)\r\n  mat.pad <- rbind(NA, cbind(NA, mat, NA), NA)\r\n  ind <- 2:(n + 1)\r\n  vizinhos <- rbind(N  = as.vector(mat.pad[ind - 1, ind    ]),\r\n                    NE = as.vector(mat.pad[ind - 1, ind + 1]),\r\n                    E  = as.vector(mat.pad[ind    , ind + 1]),\r\n                    SE = as.vector(mat.pad[ind + 1, ind + 1]),\r\n                    S  = as.vector(mat.pad[ind + 1, ind    ]),\r\n                    SO = as.vector(mat.pad[ind + 1, ind - 1]),\r\n                    O  = as.vector(mat.pad[ind    , ind - 1]),\r\n                    NO = as.vector(mat.pad[ind - 1, ind - 1]))\r\n  estados.vizinhos <- c()\r\n  for (i in 1:n^2) {\r\n    estados.vizinhos <- cbind(estados.vizinhos, gridI[vizinhos[, i], 3])\r\n  }\r\n  estados.vizinhos0 <- estados.vizinhos\r\n  estados.vizinhos0[is.na(estados.vizinhos0)] <- 0\r\n  vivos <- c()\r\n  for (i in 1:n^2) {\r\n    vivos <- cbind(vivos, \r\n                   length(estados.vizinhos0[, i][estados.vizinhos0[, i] == 1]))\r\n  }\r\n  \r\n  return(vivos)\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n# Função que gera o grid final com os estados dos agentes\r\nintera <- function(n, gridF, vivos) {\r\n  \r\n  for (i in 1:n^2) {\r\n    if (vivos[i] < 2) {\r\n      gridF$z[i] <- 0\r\n    }\r\n    if (vivos[i] > 3) {\r\n      gridF$z[i] <- 0\r\n    }\r\n    if (vivos[i] == 2) {\r\n      gridF$z[i] <- gridIni$z[i]\r\n    }\r\n    if (vivos[i] == 3) {\r\n      gridF$z[i] <- 1\r\n    }\r\n  }\r\n  \r\n  return(gridF)\r\n  \r\n}\r\n\r\n\r\n\r\nExemplos\r\n\r\n\r\n# Criando Grid inicial\r\ngera0 <- gridIni\r\n\r\n# Criando Grids para cada nova geração\r\ngera1 <- intera(n = n, gridF = gera0, vivos = nViz(n = n, gridI = gera0))\r\ngera2 <- intera(n = n, gridF = gera1, vivos = nViz(n = n, gridI = gera1))\r\ngera3 <- intera(n = n, gridF = gera2, vivos = nViz(n = n, gridI = gera2))\r\ngera4 <- intera(n = n, gridF = gera3, vivos = nViz(n = n, gridI = gera3))\r\ngera5 <- intera(n = n, gridF = gera4, vivos = nViz(n = n, gridI = gera4))\r\n\r\n\r\n\r\n\r\n\r\n# Criando Plots para cada novo Grid\r\nggplot(data = gera0) +\r\n  aes(x = x, y = y, fill = factor(z)) + \r\n  geom_tile(colour = \"black\", size = 0.8) +\r\n  coord_equal() +\r\n  theme_void() +\r\n  scale_fill_brewer(breaks = c(0, 1), \r\n                    labels = c(\"0 - Morto\", \"1 - Vivo\"),\r\n                    type = \"seq\",\r\n                    direction = 1, \r\n                    palette = 12) + \r\n  labs(title = \"Geração 0\", x = NULL, y = NULL, fill = \"Life\") +\r\n  geom_text(mapping = aes(label = 1:(n^2)), size = 2.5) -> plotgera0\r\n\r\nggplot(data = gera1) +\r\n  aes(x = x, y = y, fill = factor(z)) + \r\n  geom_tile(colour = \"black\", size = 0.8) +\r\n  coord_equal() +\r\n  theme_void() +\r\n  scale_fill_brewer(breaks = c(0, 1), \r\n                    labels = c(\"0 - Morto\", \"1 - Vivo\"),\r\n                    type = \"seq\",\r\n                    direction = 1, \r\n                    palette = 12) + \r\n  labs(title = \"Geração 1\", x = NULL, y = NULL, fill = \"Life\") +\r\n  geom_text(mapping = aes(label = 1:(n^2)), size = 2.5) -> plotgera1\r\n\r\nggplot(data = gera2) +\r\n  aes(x = x, y = y, fill = factor(z)) + \r\n  geom_tile(colour = \"black\", size = 0.8) +\r\n  coord_equal() +\r\n  theme_void() +\r\n  scale_fill_brewer(breaks = c(0, 1), \r\n                    labels = c(\"0 - Morto\", \"1 - Vivo\"),\r\n                    type = \"seq\",\r\n                    direction = 1, \r\n                    palette = 12) + \r\n  labs(title = \"Geração 2\", x = NULL, y = NULL, fill = \"Life\") +\r\n  geom_text(mapping = aes(label = 1:(n^2)), size = 2.5) -> plotgera2\r\n\r\nggplot(data = gera3) +\r\n  aes(x = x, y = y, fill = factor(z)) + \r\n  geom_tile(colour = \"black\", size = 0.8) +\r\n  coord_equal() +\r\n  theme_void() +\r\n  scale_fill_brewer(breaks = c(0, 1), \r\n                    labels = c(\"0 - Morto\", \"1 - Vivo\"),\r\n                    type = \"seq\",\r\n                    direction = 1, \r\n                    palette = 12) + \r\n  labs(title = \"Geração 3\", x = NULL, y = NULL, fill = \"Life\") +\r\n  geom_text(mapping = aes(label = 1:(n^2)), size = 2.5) -> plotgera3\r\n\r\nggplot(data = gera4) +\r\n  aes(x = x, y = y, fill = factor(z)) + \r\n  geom_tile(colour = \"black\", size = 0.8) +\r\n  coord_equal() +\r\n  theme_void() +\r\n  scale_fill_brewer(breaks = c(0, 1), \r\n                    labels = c(\"0 - Morto\", \"1 - Vivo\"),\r\n                    type = \"seq\",\r\n                    direction = 1, \r\n                    palette = 12) + \r\n  labs(title = \"Geração 4\", x = NULL, y = NULL, fill = \"Life\") +\r\n  geom_text(mapping = aes(label = 1:(n^2)), size = 2.5) -> plotgera4\r\n\r\nggplot(data = gera5) +\r\n  aes(x = x, y = y, fill = factor(z)) + \r\n  geom_tile(colour = \"black\", size = 0.8) +\r\n  coord_equal() +\r\n  theme_void() +\r\n  scale_fill_brewer(breaks = c(0, 1), \r\n                    labels = c(\"0 - Morto\", \"1 - Vivo\"),\r\n                    type = \"seq\",\r\n                    direction = 1, \r\n                    palette = 12) + \r\n  labs(title = \"Geração 5\", x = NULL, y = NULL, fill = \"Life\") +\r\n  geom_text(mapping = aes(label = 1:(n^2)), size = 2.5) -> plotgera5\r\n\r\n\r\n\r\n\r\n\r\n# plotando os Grids lado a lado\r\ngrid.arrange(plotgera0, plotgera1, plotgera2, plotgera3, plotgera4, plotgera5, \r\n             ncol = 2)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "last_modified": "2021-05-25T21:01:24-03:00"
    },
    {
      "path": "ordem2.html",
      "title": "Eq. Ordem 2",
      "description": "Essa aula estuda Equações em Diferença de ordem 2.\n",
      "author": [
        {
          "name": "Rafael Peixoto",
          "url": {}
        }
      ],
      "date": "04-19-2021",
      "contents": "\r\n\r\nContents\r\nEquações Homogêneas\r\nRaízes reais e diferentes\r\nSolução\r\nExemplo\r\n\r\nRaízes reais e iguais\r\nRaízes Complexas\r\n\r\n\r\n\r\nd-article p {\r\n  text-align: justify;\r\n  font-size: 16px;\r\n}\r\n\r\nd-article p code {\r\n  background: rgba(236, 236, 236, 0.8);\r\n}\r\n\r\nd-article div.sourceCode {\r\n  overflow: auto !important;\r\n}\r\n\r\nEquações Homogêneas\r\nUma equação em diferença de ordem 2 traz alguns elementos familiares das equações de ordem 1. No entanto, tendo em vista que agora as raízes do polinômio característico associado podem ser números complexos, temos neste caso, a presença de oscilações e ciclos. Seja a equação em diferença:\r\n\\[\r\ny_t + a_1 \\times y_{t-1} + a_0 \\times y_{t-2} = g(t)\r\n\\]\r\nonde g(t) é o termo independente (de y). A solução particular se determina seguindo o mesmo procedimento visto para o caso das equações de ordem 1.\r\nPara determinar a solução homogênea, precisamos antes identificar as raízes do polinômio característico. Se λ é raíz desse polinômio, temos que:\r\n\\[\r\np(\\lambda) = \\lambda^2 + a_1 \\lambda + a_0 = 0\r\n\\]\r\nLogo, dado que o polinômio é de grau 2, ele terá duas soluções possíveis:\r\n\\[\r\n\\lambda = - \\frac{a_1}{2} \\pm \\frac{\\sqrt{a_1^2 - 4 a_0}}{2}\r\n\\]\r\nSe \\(\\small \\Delta = a_1^2 - 4 a_0\\), temos 3 casos passiveis:\r\nDuas raízes reais e diferentes, no caso em que \\(\\small \\Delta > 0\\).\r\nDuas raízes reais e iguais, se \\(\\small \\Delta = 0\\);\r\nDuas raízes complexas, quando \\(\\small \\Delta < 0\\).\r\nAnalisemos cada caso.\r\nRaízes reais e diferentes\r\nSeja a equação em diferenças:\r\n\\[\r\ny_t - 3y_{t-1} + 2y_{t-2} = 0\r\n\\]\r\ncom \\(\\small y_1 = 1\\) e \\(\\small y_2 = -2\\)\r\nDetermine o polinômio característico e as suas raízes;\r\nDetermine as constantes arbitrárias;\r\nDetermine a trajetória temporal.\r\nSolução\r\nPara o primeiro item, precisamos usar a função polyroot do pacote base. Note que, dado que para gerar o valor da série em t + 2, precisamos dos valores em t + 1 e em t. Logo, para calcular y2, precisamos de dois valores iniciais: y1 e y0.\r\nUtilizando a mesma notação das outras aulas:\r\n\\[\r\na_2 \\times y_{t+2} = -a_1 \\times y_{t+1} - a_0 \\times y_t\r\n\\]\r\nPrimeiramente, vamos criar a função da órbita para uma equação de ordem 2:\r\n\r\n\r\n# Função que calcula a orbita de cada Eq em diferença de ordem 2\r\norbita_2o <- function(a0, y0, a1, y1, t) {\r\n  \r\n  out <- vector(mode = \"numeric\", length = t)\r\n  out[1] <- y0\r\n  out[2] <- y1\r\n  for (i in 1:(t-2)) {\r\n    out[i+2] <- -a1*out[i+1] -a0*out[i]\r\n  }\r\n  \r\n  return(out)\r\n  \r\n}\r\n\r\n\r\n\r\n\r\n\r\n# Exemplo\r\norbita_2o(a0 = -0.9, y0 = 1, a1 = -0.4, y1 = -2, t = 15) %>%\r\n  ts() %>%\r\n  autoplot()\r\n\r\n\r\n\r\n\r\nVejamos um exemplo com os seguintes parâmetros:\r\n\r\n\r\na0 <- 2\r\ny0 <- 1\r\na1 <- -3\r\ny1 <- -2\r\nt <- 10\r\n\r\n\r\n\r\n\r\n\r\n# Plot\r\norbita_2o(a0 = a0, y0 = y0, a1 = a1, y1 = y1, t = t) %>%\r\n  ts() %>%\r\n  autoplot()\r\n\r\n\r\n\r\n\r\nNote que a série se afasta do steady state \\(\\small y^∗ = 0\\) (é uma equação homogênea, certo?). E não há nem oscilações nem ciclos. Logo, o comportamento da série nos leva a inferir que a equação tem duas raízes reais e positivas; e pelo menos uma delas (sendo diferentes) possui módulo maior que um. Para confirmar, podemos primeiro calcular o discriminante (\\(\\small \\Delta\\)) do polinômio característico:\r\n\\[\r\np(\\lambda) = \\lambda^2 - 3 \\lambda + 2\r\n\\]\r\nPela definiçao:\r\n\r\n\r\na2 <- 1\r\na1 <- -3\r\na0 <- 2\r\n# calculando o discriminante\r\ndelta = a1^2 -4*a2*a0\r\ndelta\r\n\r\n\r\n[1] 1\r\n\r\nVeja que \\(\\small \\Delta = 1> 0\\). Logo, as raízes são reais e diferentes (caso 1). Agora, precisamos calcular as raízes do polinômio. Para isso, usamos a função polyroots() do pacote base (instalado e carregado automaticamente):\r\n\r\n\r\n# vetor de coeficientes do polinomio - veja que a ordem deles no vetor\r\n# vai do menor ao maior grau\r\ncoefs <- c(a0, a1, a2)\r\n# raizes\r\nroots <- polyroot(coefs)\r\nroots\r\n\r\n\r\n[1] 1+0i 2-0i\r\n\r\nNote que a função nos dá as raízes no formato mais geral que é o formato dos números complexos. Contudo, a parte imaginária das raízes é zero. Logo, temos duas raízes reais (e no caso, positivas), com \\(\\small (λ1, λ2) = Re(roots)\\).\r\n\r\n\r\nlambda = Re(roots) # a parte real das raizes\r\nlambda\r\n\r\n\r\n[1] 1 2\r\n\r\nCom isso, temos uma raíz de módulo unitário e outra com módulo maior que dois: a série temporal resultante será explosiva.\r\nA solução analítica será dada por:\r\n\\[\r\ny_t = A_1 \\lambda_1^t + A_2 \\lambda_2^t\r\n\\]\r\ncom \\(\\small λ1 = 1\\) e \\(\\small λ2 = 2\\). Dado que as condições iniciais são \\(\\small y_0=1\\) e \\(\\small y_1 =-2\\), temos que\r\n\\[\r\n\\begin{cases}\r\n& 1 = A_1(1)^0 + A_2(2)^0 \\\\\r\n& -2= A_1(1)^1 + A_2(2)^1\r\n\\end{cases}\r\n\\]\r\nque define um sistema linear e determinado. Logo:\r\n\r\n\r\nA <- matrix(data = c(1, lambda[1], 1, lambda[2]), nrow = 2)\r\nB <- c(y0, y1)\r\nX <- solve(A, B)\r\nX \r\n\r\n\r\n[1]  4 -3\r\n\r\nFinalmente, a solução analítica da equação é dada por:\r\n\\[\r\ny_t = 4(1)^t - 3(2)^t\r\n\\]\r\nVeja que essa solução é composta por duas parcelas, a parcela da primeira e da segunda raíz. Podemos analisar a contribuição de cada parcela na solução geral:\r\n\r\n\r\n# Função que calcula a orbita de cada Eq em diferença de ordem 2\r\norbita_parc <- function(X, lambda, t) {\r\n  \r\n  raiz1 <- vector(mode = \"numeric\", length = t)\r\n  raiz2 <- vector(mode = \"numeric\", length = t)\r\n  soma <- vector(mode = \"numeric\", length = t)\r\n  for (i in 1:t) {\r\n    raiz1[i] <- X[1]*lambda[1]^i\r\n    raiz2[i] <- X[2]*lambda[2]^i\r\n    soma[i] <- raiz1[i] + raiz2[i]\r\n  }\r\n  \r\n  out <- cbind(raiz1, raiz2, soma)\r\n  colnames(out) <- c(\"Raiz 1\", \"Raiz 2\", \"y\")\r\n  \r\n  return(out)\r\n  \r\n}\r\n\r\n\r\n\r\n\r\n\r\n# Plot\r\norbita_parc(X = X, lambda = lambda, t = t) %>%\r\n  ts() %>%\r\n  autoplot(facets = F)\r\n\r\n\r\n\r\n\r\nPara rodar essa função aqui foi necessário já possuir os valores de lambda e X, que foram assim encontrados: \\(\\small a_2 \\times y_{t+2} = -a_1 \\times y_{t+1} - a_0 \\times y_t\\). y0 e y1 foram dados: \\(\\small y_0 = 1\\) e \\(\\small y_1 = -2\\)\r\n\r\n\r\n# Vetor de coeficientes do polinomio \r\ncoefs <- c(a0, a1, a2)\r\n# Raizes\r\nroots <- polyroot(coefs)\r\n# A parte real das raizes\r\nlambda = Re(roots)\r\n# Para achar A1 e A2\r\nA <- matrix(data = c(1, lambda[1], 1, lambda[2]), nrow = 2)\r\nB <- c(y0, y1)\r\nX <- solve(A, B)\r\n\r\n\r\n\r\nVeja que o primeiro componente é estável, porém se mantém a uma distância constante do steady state \\(\\small y^∗ = 0\\). Logo, por esse componente ser constante, não podemos dizer que a série é estável. Ainda, o segundo componente explode a medida que t aumenta, e a grandeza dos valores tende a ser muito maior que a contribuição do primeiro componente, o que acaba gerando o comportamento da série \\(\\small y_t\\) no longo prazo.\r\nExemplo\r\nSeja a equação, com \\(\\small y_0 = 1\\) e \\(\\small y_1 = 3\\):\r\n\\[\r\ny_t -0.25y_{t-2} = 0\r\n\\]\r\nou\r\n\\[\r\n1y_{t+2} + 0y_{t+1} -0.25y_{t+0} = 0\r\n\\]\r\ntemos que:\r\n\r\n\r\na2 <- 1\r\na1 <- 0\r\na0 <- -0.25\r\ny0 <- 1\r\ny1 <- 3\r\nt <- 10\r\n\r\n\r\n\r\nSimulando essa série:\r\n\r\n\r\norbita_2o(a0 = a0, y0 = y0, a1 = a1, y1 = y1, t = t) %>%\r\n  ts() %>%\r\n  autoplot()\r\n\r\n\r\n\r\n\r\nUsando a solução analítica:\r\n\r\n\r\n# Vetor de coeficientes do polinomio \r\ncoefs <- c(a0, a1, a2)\r\n# Raizes\r\nroots <- polyroot(coefs)\r\n# A parte real das raizes\r\nlambda = Re(roots)\r\n# Para achar A1 e A2\r\nA <- matrix(data = c(1, lambda[1], 1, lambda[2]), nrow = 2)\r\nB <- c(y0, y1)\r\nX <- solve(A, B)\r\nrbind(X, lambda)\r\n\r\n\r\n       [,1] [,2]\r\nX       3.5 -2.5\r\nlambda  0.5 -0.5\r\n\r\nTemos que:\r\n\\[\r\n\\begin{align}\r\n& y_t = A_1\\lambda_1^t + A_2\\lambda_2^t \\\\\r\n& y_t = 3.5(0.5)^t - 2.5(-0.5)^t\r\n\\end{align}\r\n\\]\r\n\r\n\r\n# Plot\r\norbita_parc(X = X, lambda = lambda, t = t) %>%\r\n  ts() %>%\r\n  autoplot(facets = F)\r\n\r\n\r\n\r\n\r\nRaízes reais e iguais\r\nSeja a equação, com \\(\\small y_0 = 1\\) e \\(\\small y_1 = 3\\):\r\n\\[\r\ny_t - 6y_{t-1} + 9y_{t-2} = 0\r\n\\]\r\ntemos que:\r\n\r\n\r\na2 <- 1\r\na1 <- -6\r\na0 <- 9\r\ny0 <- 1\r\ny1 <- 3\r\nt <- 10\r\n\r\n\r\n\r\nSimulando essa série:\r\n\r\n\r\norbita_2o(a0 = a0, y0 = y0, a1 = a1, y1 = y1, t = t) %>%\r\n  ts() %>%\r\n  autoplot()\r\n\r\n\r\n\r\n\r\nUsando a solução analítica:\r\n\r\n\r\n# Vetor de coeficientes do polinomio \r\ncoefs <- c(a0, a1, a2)\r\n# Raizes\r\nroots <- polyroot(coefs)\r\n# A parte real das raizes\r\nlambda = Re(roots)\r\nlambda\r\n\r\n\r\n[1] 3 3\r\n\r\n# Para achar A1 e A2\r\n# A <- matrix(data = c(1, lambda[1], 1, lambda[2]), nrow = 2)\r\n# B <- c(y0, y1)\r\n# X <- solve(A, B) não pode ser utilizado pois o Delta é igual a zero\r\n\r\n\r\n\r\nPara encontrar a forma analítica da solução, multiplicamos uma das raízes (que são iguais) por t, para que haja diferenciação:\r\n\\[\r\ny_t = (A_1 + A_2 \\times t)\\lambda^t\r\n\\]\r\nPara obter as constantes arbitrárias A1 e A2 a partir das condições inicias, e com isso, analisar os componentes da solução, construimos novamente um sistema linear com duas equações e duas incógnitas:\r\n\\[\r\n\\begin{cases}\r\n& y_0 = (A_1 + A_2 \\times 0) \\times (3)^0 = A_1 \\\\\r\n& y_1 = (A_1 + A_2 \\times 1) \\times (3)^1 = 3A_1 + 3A_2 \r\n\\end{cases}\r\n\\]\r\nNa forma geral, para qualque lambda (qualquer polinômio com raizes iguals):\r\n\\[\r\n\\begin{cases}\r\n& y_0 = A_1 \\\\\r\n& y_1 = A_1\\lambda + A_2\\lambda \r\n\\end{cases}\r\n\\]\r\nLogo,\r\n\\[\r\nA_2 = \\frac{y_1}{\\lambda} - A_1\r\n\\]\r\n\r\n\r\n# identificando as constantes arbitrarias\r\nX = y0\r\nX[2] = y1/lambda[1] - X[1]\r\n\r\n\r\n\r\nComo mudamos a forma funcional da solução, precisamos alterar a função que gera essas séries, acrescentando a multipliação de A2 por t:\r\n\r\n\r\n# Função que calcula a orbita de cada Eq em diferença de ordem 2\r\norbita_parc_delta0 <- function(X, lambda, t) {\r\n  \r\n  raiz1 <- vector(mode = \"numeric\", length = t)\r\n  raiz2 <- vector(mode = \"numeric\", length = t)\r\n  soma <- vector(mode = \"numeric\", length = t)\r\n  for (i in 1:t) {\r\n    raiz1[i] <- X[1]*lambda[1]^i\r\n    raiz2[i] <- X[2]*i*lambda[2]^i\r\n    soma[i] <- raiz1[i] + raiz2[i]\r\n  }\r\n  \r\n  out <- cbind(raiz1, raiz2, soma)\r\n  colnames(out) <- c(\"Raiz 1\", \"Raiz 2\", \"y\")\r\n  \r\n  return(out)\r\n  \r\n}\r\n\r\n\r\n\r\n\r\n\r\n# Plot\r\norbita_parc_delta0(X = X, lambda = lambda, t = t) %>%\r\n  ts() %>%\r\n  autoplot(facets = F)\r\n\r\n\r\n\r\n\r\nRaízes Complexas\r\nPrecisamos utilizar Euler e Moivre para reescrever a solução homogênea.\r\nPor exemplo, seja a equação, com \\(\\small y_0 = 1\\) e \\(\\small y_1 = 3\\)\r\n\\[\r\ny_t - y_{t-1} + \\frac{5}{4}y_{t-2} = 0\r\n\\]\r\nou\r\n\\[\r\n1y_{t+2} - 1y_{t+1} + \\frac{5}{4}y_{t-0} = 0\r\n\\]\r\ntemos que:\r\n\r\n\r\na2 <- 1\r\na1 <- -1\r\na0 <- 5/4\r\ny0 <- 1\r\ny1 <- 3\r\nt <- 20\r\n\r\n\r\n\r\nSimulando essa série:\r\n\r\n\r\norbita_2o(a0 = a0, y0 = y0, a1 = a1, y1 = y1, t = t) %>%\r\n  ts() %>%\r\n  autoplot()\r\n\r\n\r\n\r\n\r\nUsando a solução analítica:\r\n\\[\r\ny_t^h = R^t [(A_1+A_2)\\times cos(\\theta t) + (A_1-A_2) \\times i \\times sin(\\theta t)]\r\n\\]\r\n\r\n\r\n# Vetor de coeficientes do polinomio \r\ncoefs <- c(a0, a1, a2)\r\n# Raizes\r\nroots <- polyroot(coefs)\r\nroots\r\n\r\n\r\n[1] 0.5+1i 0.5-1i\r\n\r\n# A parte real das raizes\r\n# lambda = Re(roots)\r\n# lambda\r\n# Para achar A1 e A2\r\n# A <- matrix(data = c(1, lambda[1], 1, lambda[2]), nrow = 2)\r\n# B <- c(y0, y1)\r\n# X <- solve(A, B) não pode ser utilizado pois o Delta é igual a zero\r\n\r\n\r\n\r\nComo as raízes apresentam componentes imaginários:\r\nPrimeira Raiz\r\n\r\n\r\n# Módulo do complexo\r\nR <- Mod(roots[1]) %>% round(digits = 2)\r\n# Argumento do complexo\r\ntheta <- Arg(roots[1]) %>% round(digits = 2)\r\nrbind(R, theta)\r\n\r\n\r\n      [,1]\r\nR     1.12\r\ntheta 1.11\r\n\r\n\\[\r\ny_t = (1.12)^t \\times (A_1 cos(1.11t) + A_2 sin(1.11t))\r\n\\]\r\nComo o módulo dessa raiz é maior que a unidade, \\(\\small R = 1.12 > 1\\), teremos uma série temporal com ciclos explosivos no longo prazo\r\n\r\n\r\n# Função que calcula a orbita de cada Eq em diferença de ordem 2\r\norbita_parc_complx <- function(R, theta, t) {\r\n  \r\n  out <- vector(mode = \"numeric\", length = t)\r\n  out[1] <- y0\r\n  out[2] <- y1\r\n  for (i in 1:t) {\r\n    out[i+2] <- R^t\r\n  }\r\n  \r\n  return(out)\r\n  \r\n}\r\n\r\n\r\n\r\nPorque não mostrar o gráfico com as duas raízes e a soma delas, igual para os outros casos? Porque para isso seria necessário entrar no campo do complexos, o que foge do campo de interesse das análises econômicas.\r\n\r\n\r\n\r\n",
      "last_modified": "2021-05-25T21:01:31-03:00"
    },
    {
      "path": "ordemsup.html",
      "title": "Eq. Ordem Superior",
      "description": "Essa aula estuda Equações em Diferença de ordem superior.\n",
      "author": [
        {
          "name": "Rafael Peixoto",
          "url": {}
        }
      ],
      "date": "04-30-2021",
      "contents": "\r\n\r\nContents\r\nEquações de Ordem Superior\r\nExercício 1\r\nExercício 2\r\n\r\nO Modelo de Hansen-Samuelson\r\nAnálise das raízes\r\nAnálise qualitativa\r\n\r\nO modelo de Hicks\r\nAnálise de estabilidade\r\n\r\n\r\n\r\n\r\nd-article p {\r\n  text-align: justify;\r\n  font-size: 16px;\r\n}\r\n\r\nd-article p code {\r\n  background: rgba(236, 236, 236, 0.8);\r\n}\r\n\r\nd-article div.sourceCode {\r\n  overflow: auto !important;\r\n}\r\n\r\n\r\nEquações de Ordem Superior\r\nComo já vimos, a equação linear em diferença de ordem n terá a sua solução analítica e estabilidade dependentes das n raízes do seu polinômio característico. Ainda, a condição do módulo de todas as raízes ser menor que a unidade continua a ser necessária para garantir a estabilidade da série no longo prazo.\r\nExercício 1\r\nSeja a equação de ordem 3, com \\(\\small y_0 = 400\\), \\(\\small y_1 = 420\\), \\(\\small y_2 = 450\\):\r\n\\[\r\n1y_{t+3} -4y_{t+2} +4.8y_{t+1} -1.6y_{t+0} = 100\r\n\\]\r\nEla possuirá três raízes características. Simulando, notamos que a série \\(\\small y_t\\) apresenta uma trajetória explosiva não oscilatória e sem ciclos. Logo, as raízes serão reais e positivas e haverá ao menos uma raíz com módulo maior que a unidade.\r\nTemos que:\r\n\r\n\r\na3 <- 1\r\na2 <- -4\r\na1 <- 4.8\r\na0 <- -1.6\r\ny0 <- 400\r\ny1 <- 420\r\ny2 <- 450\r\ng <- 100\r\nt <- 10\r\n\r\n\r\n\r\nPara simular essa série vamos, antes, construir a função de órbita de terceira ordem:\r\n\r\n\r\n# Função que calcula a orbita de cada Eq em diferença de ordem 3\r\norbita_3o <- function(a2, a1, a0, y0, y1, y2, g, t) {\r\n  \r\n  out <- vector(mode = \"numeric\", length = t)\r\n  out[1] <- y0\r\n  out[2] <- y1\r\n  out[3] <- y2\r\n  for (i in 1:(t-3)) {\r\n    out[i+3] <- -a2*out[i+2] -a1*out[i+1] -a0*out[i+0] + g\r\n  }\r\n  \r\n  return(out)\r\n  \r\n}\r\n\r\n\r\n\r\nSimulando a série:\r\n\r\n\r\norbita_3o(a2 = a2, a1 = a1, a0 = a0, y0 = y0, y1 = y1, y2 = y2, g = g, t = t) %>%\r\n  ts() %>%\r\n  autoplot() +\r\n  theme_hc() +\r\n  scale_x_continuous(breaks = 1:10) +\r\n  scale_y_continuous(breaks = seq(0, 18000, 2500))\r\n\r\n\r\n\r\n\r\nAnalisando as raízes (do polinômio característico):\r\n\r\n\r\n# Vetor de coeficientes do polinomio \r\ncoefs <- c(a0, a1, a2, a3)\r\n# Raizes\r\nroots <- polyroot(coefs) %>% round(digits = 3)\r\nroots\r\n\r\n\r\n[1] 0.553+0i 1.447+0i 2.000+0i\r\n\r\n# A parte real das raizes\r\nlambda = Re(roots)\r\nlambda\r\n\r\n\r\n[1] 0.553 1.447 2.000\r\n\r\nO steady state é dado por:\r\n\r\n\r\nyp <- g / (a0 + a1 + a2 + a3)\r\nyp\r\n\r\n\r\n[1] 500\r\n\r\nComo há 2 raízes maiores que a unidade, a série é explosiva. Logo, o ponto fixo é um repulsor. Além disso, as três raízes são reais e positivas, o que descarta a existência de oscilações ou de ciclos (como já havíamos previsto, dado o comportamento do gráfico).\r\nAssim, a solução explícita será dada pela combinação linear dos termos exponenciais tal que:\r\n\\[\r\n\\begin{align}\r\n& y_t = A_1(\\lambda_1)^t + A_2(\\lambda_2)^t + A_3(\\lambda_3)^t + g \\\\\r\n& y_t = A_1(0.553)^t + A_2(1.447)^t + A_3(2.000)^t + 500\r\n\\end{align}\r\n\\]\r\nonde os \\(\\small \\lambda_i\\) são as raízes. Com as três condições iniciais, determinamos as constantes arbitrárias A1, A2 e A3, por meio do sistema determinado resultante da substituição de y0, y1, y2 para t = 0, 1, 2 na solução explícita:\r\n\\[\r\n\\begin{cases}\r\ny_0 = A_1(0.553)^0+A_2(1.447)^0+A_3(2.000)^0 + 500 \\\\\r\ny_1 = A_1(0.553)^1+A_2(1.447)^1+A_3(2.000)^1 + 500 \\\\\r\ny_2 = A_1(0.553)^2+A_2(1.447)^2+A_3(2.000)^2 + 500 \\\\\r\n\\end{cases}\r\n\\]\r\nou\r\n\\[\r\n\\begin{equation}\r\n  \\begin{bmatrix}\r\n    y_0 \\\\\r\n    y_1 \\\\\r\n    y_2\r\n  \\end{bmatrix}\r\n  =\r\n  \\begin{bmatrix}\r\n    A_1 \\\\\r\n    A_2 \\\\\r\n    A_3\r\n  \\end{bmatrix}\r\n  \\cdot\r\n \\begin{bmatrix}\r\n    \\lambda_1^0 & \\lambda_2^0 & \\lambda_3^0  \\\\\r\n    \\lambda_1^1 & \\lambda_2^1 & \\lambda_3^1  \\\\\r\n    \\lambda_1^2 & \\lambda_2^2 & \\lambda_3^2  \\\\\r\n  \\end{bmatrix}\r\n\\end{equation}\r\n\\]\r\n\r\n\r\n# Para achar A1, A2 e A3\r\nv <- c(lambda[1]^0, lambda[1]^1, lambda[1]^2, \r\n       lambda[2]^0, lambda[2]^1, lambda[2]^2,\r\n       lambda[3]^0, lambda[3]^1, lambda[3]^2)\r\n# L: matrix com os lambdas\r\nL <- matrix(data = v, ncol = 3)\r\n# B: vetor com as condições inicias\r\nB <- c(y0, y1, y2) - yp\r\n# X: Vetor com os A_i \r\nX <- solve(L, B)\r\nX\r\n\r\n\r\n[1] -49.19536 -88.27182  37.46718\r\n\r\nPortanto:\r\n\\[\r\n\\begin{equation}\r\n  \\begin{bmatrix}\r\n    A_1 \\\\\r\n    A_2 \\\\\r\n    A_3\r\n  \\end{bmatrix}\r\n    =\r\n  \\begin{bmatrix}\r\n    -49.19 \\\\\r\n    -88.27 \\\\\r\n    37.46\r\n  \\end{bmatrix}\r\n\\end{equation}\r\n\\]\r\nSimulando os três componentes de forma independente:\r\n\r\n\r\n# Função que calcula a orbita de cada Eq em diferença de ordem 3\r\norbita_parc_3 <- function(X, lambda, t) {\r\n  \r\n  raiz1 <- vector(mode = \"numeric\", length = t)\r\n  raiz2 <- vector(mode = \"numeric\", length = t)\r\n  raiz3 <- vector(mode = \"numeric\", length = t)\r\n  soma <- vector(mode = \"numeric\", length = t)\r\n  for (i in 1:t) {\r\n    raiz1[i] <- X[1]*lambda[1]^i\r\n    raiz2[i] <- X[2]*lambda[2]^i\r\n    raiz3[i] <- X[3]*lambda[3]^i\r\n    soma[i] <- raiz1[i] + raiz2[i] + raiz3[i]\r\n  }\r\n  \r\n  out <- cbind(raiz1, raiz2, raiz3, soma)\r\n  colnames(out) <- c(\"Raiz 1\", \"Raiz 2\", \"Raiz 3\", \"y\")\r\n  \r\n  return(out)\r\n  \r\n}\r\n\r\n\r\n\r\n\r\n\r\norbita_parc_3(X = X, lambda = lambda, t = t) %>%\r\n  ts() %>%\r\n  autoplot(facets = F) +\r\n  theme_hc() +\r\n  scale_x_continuous(breaks = 1:10) +\r\n  scale_y_continuous(breaks = seq(-5000, 40000, 5000)) +\r\n  scale_colour_discrete(\"\") +\r\n  theme(legend.position = \"top\")\r\n\r\n\r\n\r\n\r\nExercício 2\r\nSeja a seguinte equação em diferença (também de ordem 3), com \\(\\small y_0 = 0\\), \\(\\small y_1 = 2\\), \\(\\small y_2 = 4\\):\r\n\\[\r\n1y_{t+3} - 1y_{t+2} - 2y_{t+1} +2y_{t+0} = 0 \r\n\\]\r\nTemos que:\r\n\r\n\r\na3 <- 1\r\na2 <- -1\r\na1 <- -2\r\na0 <- 2\r\ny0 <- 0\r\ny1 <- 2\r\ny2 <- 4\r\ng <- 0\r\nt <- 10\r\n\r\n\r\n\r\nComo já possuímos a função de órbita de terceira ordem, basta usá-la:\r\n\r\n\r\norbita_3o(a2 = a2, a1 = a1, a0 = a0, y0 = y0, y1 = y1, y2 = y2, g = g, t = t) %>%\r\n  ts() %>%\r\n  autoplot() +\r\n  theme_hc() +\r\n  scale_x_continuous(breaks = 1:10) +\r\n  scale_y_continuous(breaks = seq(0, 100, 10))\r\n\r\n\r\n\r\n\r\nO gráfico nos leva a inferir que temos novamente uma série explosiva e sem oscilações nem ciclos, o que indica a presença de raízes reais; e ao menos uma raíz unitária (maior que 1).\r\nAnalisando as raízes (do polinômio característico):\r\n\r\n\r\n# Vetor de coeficientes do polinomio \r\ncoefs <- c(a0, a1, a2, a3)\r\n# Raizes\r\nroots <- polyroot(coefs) %>% round(digits = 3)\r\nroots\r\n\r\n\r\n[1]  1.000+0i -1.414+0i  1.414+0i\r\n\r\n\r\n\r\n# A parte real das raizes\r\nlambda = Re(roots)\r\nlambda\r\n\r\n\r\n[1]  1.000 -1.414  1.414\r\n\r\nNote que temos uma raiz com módulo unitário e outras duas com módulo maior que a unidade. Além disso, temos uma raiz negativa, o que produziria oscilações (e explosivas). Mas esas oscilações não aparecem no gráfico. Haveria uma explicação?\r\nComo a equação é homogêna (\\(\\small g(t) = 0\\)), o steady state é 0, portanto:\r\n\r\n\r\n# Para achar A1, A2 e A3\r\nv <- c(lambda[1]^0, lambda[1]^1, lambda[1]^2, \r\n       lambda[2]^0, lambda[2]^1, lambda[2]^2,\r\n       lambda[3]^0, lambda[3]^1, lambda[3]^2)\r\n# L: matrix com os lambdas\r\nL <- matrix(data = v, ncol = 3)\r\n# B: vetor com as condições inicias\r\nB <- c(y0, y1, y2) # yp = 0 (steady state)\r\n# X: Vetor com os A_i \r\nX <- solve(L, B)\r\nX\r\n\r\n\r\n[1] -4.0024175 -0.1212868  4.1237043\r\n\r\nPara simular os três componentes de forma independente, usamos a função orbita_parc_3, que construimos anteriormente:\r\n\r\n\r\norbita_parc_3(X = X, lambda = lambda, t = t) %>%\r\n  ts() %>%\r\n  autoplot(facets = F) +\r\n  theme_hc() +\r\n  scale_x_continuous(breaks = 1:10) +\r\n  scale_y_continuous(breaks = seq(-20, 130, 10)) +\r\n  scale_color_discrete(\"\") +\r\n  theme(legend.position = \"top\")\r\n\r\n\r\n\r\n\r\nVemos que a raíz 2 de fato oscila. Contudo, como a série é explosiva, esse comportamento é pouco identificável no comportamento da série.\r\nO Modelo de Hansen-Samuelson\r\nO Modelo econômico de Hansen-Samuelson é dado pelas equações:\r\n\\[\r\n\\begin{align}\r\n& C_t = bY_{t-1} \\\\\r\n& I_t = k(C_t-C_{t-1}) \\\\\r\n& G_t = G>0 \\\\\r\n& Y_t = C_t + I_t + G_t\r\n\\end{align}\r\n\\]\r\nonde,\r\n\\(\\small b \\in (0,1)\\): propensão marginal a consumir\r\n\\(\\small k\\): coeficiente de aceleração do investimento\r\n\\(\\small G\\): gastos públicos (consumo autônomo)\r\nPodemos analisar o comportamento da renda nacional e por substituição, do consumo das famílias \\(\\small C_t\\) e dos investimentos \\(\\small I_t\\) nessa economia hipotética.\r\nPrimeiramente, definimos os parâmetros (como dentre as equações acima aparece um termo \\(\\small Y_{t-1}\\) e um \\(\\small C_{t-1}\\), esses devem ser fornecidos para a inicialização do modelo):\r\n\r\n\r\nb <- 0.9\r\nk <- 0.7\r\nG <- 10\r\nt <- 100\r\nY0 <- 10\r\nC0 <- 2\r\n\r\n\r\n\r\nSabemos que esses são os parâmetros que servem de input para a função que vamos construir para analisar esse modelo que, por sua vez, retorna os valores das séries para \\(\\small C_t\\), \\(\\small I_t\\) e \\(\\small Y_t\\). Adicionalmente, construiremos, também, uma série para os valores de \\(\\small I = I_{ind} + G\\) (na função a seguir, Iind corresponde ao \\(\\small I_t\\) nas equações do modelo acima):\r\n\r\n\r\n# Função que calcula a orbita do modelo de Hansen-Samuelson\r\norbita_HS <- function(b, k, G, Y0, C0, t) {\r\n  \r\n  Y <- vector(mode = \"numeric\", length = t)\r\n  C <- vector(mode = \"numeric\", length = t)\r\n  I <- vector(mode = \"numeric\", length = t)\r\n  Iind <- vector(mode = \"numeric\", length = t)\r\n  \r\n  C[1] <- b * Y0\r\n  Iind[1] <- k * (C[1] - C0)\r\n  Y[1] <- C[1] + Iind[1] + G\r\n\r\n  for (i in 2:t) {\r\n    C[i] <- b * Y[i-1]\r\n    Iind[i] <- k * (C[i] - C[i-1])\r\n    Y[i] <- C[i] + Iind[i] + G\r\n    I[i] <- Iind[i] + G\r\n  }\r\n  \r\n  out <- cbind(C, I, Iind, Y)\r\n  \r\n  return(out)\r\n  \r\n}\r\n\r\n\r\n\r\n\r\n\r\norbita_HS(b = b, k = k, G = G, Y0 = Y0, C0 = C0, t = t) %>%\r\n  ts() %>%\r\n  autoplot(facets = F) +\r\n  theme_hc() +\r\n  scale_x_continuous(breaks = seq(0, 100, 10)) +\r\n  scale_y_continuous(breaks = seq(0, 110, 10)) +\r\n  scale_color_discrete(\"\") +\r\n  theme(legend.position = \"top\")\r\n\r\n\r\n\r\n\r\nObservando o gráfico e a evolução as séries podemos inferir um padrão estável. Para validar tal inferência, podemos analisar o estado estacionário, em que \\(\\small Y_t = Y_{t−1}\\) e portanto, se espera que que \\(\\small C_t = C_{t−1}\\), \\(\\small I_t = I_{t−1}\\) etc. Olhando novamente as equações do sistema no longo prazo:\r\n\\[\r\n\\begin{cases}\r\nC^* = b\\cdot Y^* \\\\\r\nI_{ind}^* = 0 \\\\\r\nI^* = G \\\\\r\nY^* = C^* + I^*\r\n\\end{cases}\r\n\\]\r\nSubstituindo \\(\\small C^*\\) e \\(\\small I^*\\) em \\(\\small Y^*\\):\r\n\\[\r\nY^* = b \\cdot Y^* + G\r\n\\]\r\nLogo,\r\n\\[\r\nY^* = \\frac{G}{1-b}\r\n\\]\r\nSubstituindo os valores atribuídos aos parâmetros na simulação, temos que:\r\n\\[\r\n\\begin{cases}\r\nY^* = 100 \\\\\r\nI^* = 10 \\\\\r\nC^* = 90\r\n\\end{cases}\r\n\\]\r\nque são justamente os valores para os quais as séries convergiram. Portanto, podemos afirmar que se trata de um modelo estável.\r\nAnálise das raízes\r\nManipulando as equações que definem o modelo de Hansen-Samuelson, obtemos uma equação em diferença de ordem 2 em \\(\\small Y_t\\), que como já vimos, deve produzir uma série com comportamento convergente no longo prazo a \\(\\small Y^∗ = 100\\) (o atrator):\r\n\\[\r\nY_t - b\\cdot (k+1)\\cdot Y_{t-1} + b \\cdot k \\cdot Y_{t-2} = G\r\n\\]\r\nPara realizar a análise dinâmica, precisamos avaliar as raízes do polinômio característico:\r\n\\[\r\np(\\lambda) = \\lambda^2 + a_1\\lambda + a_0 = 0\r\n\\]\r\nonde,\r\n\\[\r\n\\begin{cases}\r\na_2 = 1 \\\\\r\na_1 = -b(k+1) \\\\\r\na_0 = bk\r\n\\end{cases}\r\n\\]\r\nA análise qualitativa a partir dos coeficientes considera as três restrições (para que o sistema seja estável) a seguir:\r\n\\[\r\n\\begin{cases}\r\n a_0 + a_1 +  1 & > 0 \\\\\r\n a_0 - a_1 + 1 & > 0 \\\\\r\n a_0 & < 1\r\n\\end{cases}\r\n\\]\r\nAntes de fazer essa análise qualitativa, entretanto, vamos analisar essas raízes de forma quantitativa, igual feito nos exercícios anteriores:\r\n\r\n\r\na2 <- 1\r\na1 <- -b * (k + 1)\r\na0 <- b * k\r\n\r\n\r\n\r\n\r\n\r\n# Vetor de coeficientes do polinomio \r\ncoefs <- c(a0, a1, a2)\r\ncoefs\r\n\r\n\r\n[1]  0.63 -1.53  1.00\r\n\r\n# Raizes\r\nroots <- polyroot(coefs) %>% round(digits = 3)\r\nroots\r\n\r\n\r\n[1] 0.765+0.212i 0.765-0.212i\r\n\r\nComo as raízes apresentam componentes complexos, vamos calcular o módulo e o ângulo (só é preciso usar uma das raízes pois as raízes complexas sempre aparecem em conjuntos de 2 e essas possuem o mesmo módulo):\r\n\r\n\r\nR <- Mod(roots[1])\r\ntheta <- Arg(roots[1])\r\nrbind(R, theta) %>% round(digits = 3)\r\n\r\n\r\n       [,1]\r\nR     0.794\r\ntheta 0.270\r\n\r\nComo o módulo é menor que a unidade, as séries apresentam ciclos amortecidos (não explosivos).\r\nAnálise qualitativa\r\nVoltando, agora, à análise qualitativa das raízes, vamos ver se satisfazem as restrições apontadas. Relembrando que:\r\n\\(\\small \\Delta > 0\\): Raízes reais e diferentes\r\n\\(\\small \\Delta = 0\\): Raízes reais e iguais\r\n\\(\\small \\Delta < 0\\): Raízes complexas\r\nIndependente da natureza das raízes, a estabilidade é garantida quando as raízes não são maiores que a unidade.\r\nPorém, a partir do polinômio característico, é possível estabelecer condições de estabilidade para o caso de raízes reais a partir da análise dos coeficientes:\r\n\\(\\small \\Delta = 0 \\implies a_0 < 1\\)\r\n\\(\\small \\Delta > 0 \\implies a_1-2 < \\pm \\sqrt{\\Delta} < a_1+2\\):\r\n\\(a_0 > a_1 -1\\)\r\n\\(a_0 > -a_1 -1\\)\r\n\r\n\\(\\small \\Delta < 0 \\implies a_0 < 1\\)\r\nJuntando:\r\n\\[\r\n\\begin{equation}\r\n\\begin{cases}\r\n a_0 + a_1 +  1 & > 0 \\\\\r\n a_0 - a_1 + 1 & > 0 \\\\\r\n a_0 & < 1\r\n\\end{cases}\r\n\\end{equation}\r\n\\]\r\n\r\n\r\nrest1 <- 1 + a1 + a0 > 0\r\nrest2 <- 1- a1 + a0 > 0\r\nrest3 <- a0 < 1\r\ncbind(rest1, rest2, rest3)\r\n\r\n\r\n     rest1 rest2 rest3\r\n[1,]  TRUE  TRUE  TRUE\r\n\r\nComo podemos ver, as três condições são atendidas.\r\nPorém, esse é o caso para os b e k definidos no início do exercício. Podemos analisar essas condições de forma geral, para quaisquer b e k. Como já mostrado:\r\n\\[\r\n\\begin{cases}\r\na_2 = 1 \\\\\r\na_1 = -b(k+1) \\\\\r\na_0 = bk\r\n\\end{cases}\r\n\\]\r\nJuntando essas restrições e condições, temos que para o sistema ser estável:\r\n\\[\r\nb < \\frac{1}{k}\r\n\\]\r\nDo polinômio característico, temos que as raízes são tais que:\r\n\\[\r\n\\lambda_1, \\lambda_2 = \\frac{b(k+1)}{2} \\pm \\frac{\\sqrt{\\Delta}}{2}\r\n\\]\r\nonde \\(\\small \\Delta = b^2(k+1)^2 - 4bk\\).\r\nPara identificar a características dinâmicas da renda, precisamos analisar \\(\\small \\Delta\\):\r\n\\[\r\n\\Delta = b^2(k+1)^2 - 4bk \\gtreqqless 0\r\n\\]\r\nisolando b:\r\n\\[\r\nb \\gtreqqless \\frac{4k}{(k+1)^2}\r\n\\]\r\nAssim, para analisar essas condições sobre b, podemos plotar as seguintes equações:\r\n\\[\r\n\\begin{cases}\r\nb = \\frac{1}{k} \\\\\r\nb = \\frac{4k}{(k+1)^2}\r\n\\end{cases}\r\n\\]\r\n\r\n\r\nfunc1 <- function(x) 1 / x\r\nfunc2 <- function(x) (4 * x) / (x + 1)^2\r\n\r\n\r\n\r\n\r\n\r\nggplot(data = data.frame(x = 0)) +\r\n  aes(x = x) +\r\n  xlim(0, 4) + \r\n  xlab(\"k\") +\r\n  ylim(0, 1.6) +\r\n  ylab(\"b\") +\r\n  ggtitle(\"Localização das raízes\") +\r\n  stat_function(fun = func1, aes(colour = \"func1\")) +\r\n  stat_function(fun = func2, aes(colour = \"func2\")) +\r\n  geom_hline(yintercept = 1, linetype = \"dashed\") +\r\n  geom_vline(xintercept = 1, linetype = \"dashed\") +\r\n  annotate(\"text\", x = 0, y = 0.9, label = \"A\", size = 5) +\r\n  annotate(\"text\", x = 1.2, y = 0.5, label = \"B\", size = 5) +\r\n  annotate(\"text\", x = 2.4, y = 0.7, label = \"C\", size = 5) +\r\n  annotate(\"text\", x = 3.2, y = 0.9, label = \"D\", size = 5) +\r\n  theme_hc() +\r\n  scale_y_continuous(breaks = seq(0, 1.6, 0.2), limits = c(0, 1.6)) +\r\n  scale_color_manual(\"\", values = c(\"red\", \"blue\"), \r\n                     labels = c(~frac(1,k),~frac(4*k,(k+1)^2))) +\r\n  theme(plot.title = element_text(size = 18, hjust = 0.5, colour = \"black\"),\r\n        legend.position = \"top\") \r\n\r\n\r\n\r\n\r\nComo apontado no gráfico, há 4 regiões possíveis:\r\nA: \\(\\small b < \\frac{1}{k}\\) e \\(\\small b > \\frac{4k}{(1+k)^2}\\)\r\nB: \\(\\small b < \\frac{1}{k}\\) e \\(\\small b < \\frac{4k}{(1+k)^2}\\)\r\nC: \\(\\small b > \\frac{1}{k}\\) e \\(\\small b < \\frac{4k}{(1+k)^2}\\)\r\nD: \\(\\small b > \\frac{1}{k}\\) e \\(\\small b > \\frac{4k}{(1+k)^2}\\)\r\nComo havíamos dito, a primeira restrição para a estabilidade do sistema é que \\(\\small b < \\frac{1}{k}\\), critério que apenas as regiões A e B atendem. Na região A, em que \\(\\small \\Delta > 0\\), as condições de estabilidade são que \\(\\small a_0 > a_1 - 1\\) e \\(\\small a_0 > -a_1 - 1\\). Na região B, em que \\(\\small \\Delta < 0\\), a condição de estabilidade é que \\(\\small a_0 < 1\\).\r\nO modelo de Hicks\r\nO modelo de Hicks é uma alteração do modelo de Hansen-Samuelson (HS), e é dado pelas seguintes equações:\r\n\\[\r\n\\begin{align}\r\n& Y_t = C_t + I_t  \\\\\r\n& C_t = bY_{t-1} \\\\\r\n& I_t = I'_t + I''_t \\\\\r\n& I'_t = k(Y_{t-1}-Y_{t-2}) \\\\\r\n& I''_t = A_0(1+g)^2 \\\\\r\n\\end{align}\r\n\\]\r\nonde,\r\n\\(\\small I''\\): Investimento autônomo, que cresce a uma taxa exógena \\(\\small g\\)\r\n\\(\\small I'\\): Investimento induzido pelo acelerador e dependente da demanda agregada.\r\n\\(\\small k < 1\\): condição de estabilidade\r\nAssim como para o modelo de HS, primeiramente definimos os parâmetros de inicialização da simulação:\r\n\r\n\r\nb <- 0.5  # propensão marginal a consumir\r\nk <- 0.2  # acelerador do investimento\r\ng <- 0.05 # taxa de investimento autônomo\r\nA0 <- 1\r\nY0 <- 20\r\nY1 <- 5\r\nt <- 80\r\n\r\n\r\n\r\nSabemos que esses são os parâmetros que servem de input para a função que vamos construir para analisar esse modelo que, por sua vez, retorna os valores das séries para \\(\\small C_t\\), \\(\\small I_t\\) e \\(\\small Y_t\\). Adicionalmente, construiremos, também, séries para os valores de \\(\\small I' = I_{ind}\\) e \\(\\small I'' = I_{aut}\\).\r\n\r\n\r\n# Função que calcula a orbita do modelo de Hicks\r\norbita_hicks <- function(b, k, g, A0, Y0, Y1, t) {\r\n  \r\n  C <- vector(mode = \"numeric\", length = t)\r\n  Iind <- vector(mode = \"numeric\", length = t)\r\n  Iaut <- vector(mode = \"numeric\", length = t)\r\n  I <- vector(mode = \"numeric\", length = t)\r\n  Y <- vector(mode = \"numeric\", length = t)\r\n  \r\n  C[1] <- b * Y0\r\n  Iind[1] <- k * (Y1 - Y0)\r\n  Iaut[1] <- A0 * (1 + g)^1\r\n  I[1] <- Iind[1] + Iaut[1]\r\n  Y[1] <- C[1] + I[1]\r\n  \r\n  C[2] <- b * Y1\r\n  Iind[2] <- k * (Y[1] - Y1)\r\n  Iaut[2] <- A0 * (1 + g)^2\r\n  I[2] <- Iind[2] + Iaut[2]\r\n  Y[2] <- C[2] + I[2]\r\n  \r\n  for (i in 3:t) {\r\n    C[i] <- b * Y[i-1]\r\n    Iind[i] <- k * (Y[i-1] - Y[i-2])\r\n    Iaut[i] <- A0 * (1 + g)^i\r\n    I[i] <- Iind[i] + Iaut[i]\r\n    Y[i] <- C[i] + I[i]\r\n  }\r\n  \r\n  out <- cbind(C, I, Iind, Iaut, Y)\r\n  \r\n  return(out)\r\n  \r\n}\r\n\r\n\r\n\r\n\r\n\r\norbita_hicks(b = b, k = k, g = g, A0 = A0, Y0 = Y0, Y1 = Y1, t = t) %>%\r\n  ts() %>%\r\n  autoplot(facets = F) +\r\n  theme_hc() +\r\n  scale_x_continuous(breaks = seq(0, 80, 10)) +\r\n  scale_y_continuous(breaks = seq(0, 100, 10)) +\r\n  scale_color_discrete(\"\") +\r\n  theme(legend.position = \"top\")\r\n\r\n\r\n\r\n\r\nNote que as séries parecem explodir. Contudo, devemos considerar que \\(\\small I_t = A0 \\cdot (1 + g)^t\\) cresce exponencialmente a uma taxa g constante. Logo, havendo um padrão de convergência, não podemos esperar que o equilíbrio seja fixo, pois todas as variáveis interagem entre si.\r\nAnálise de estabilidade\r\nPor substituição, obtemos a equação em diferenças de ordem 2 em \\(\\small Y_t\\):\r\n\\[\r\n1Y_t − (b + k)Y_{t−1} + kY_{t−2} = A_0(1 + g)^t\r\n\\]\r\ncujo polinômio característico é dado por:\r\n\\[\r\n\\lambda^2 - (b+k)\\lambda + k = 0\r\n\\]\r\nAssim:\r\n\\[\r\n\\begin{cases}\r\na_2 = 1 \\\\\r\na_1 = -(b+k) \\\\\r\na_0 = k\r\n\\end{cases}\r\n\\]\r\nSejam as condições de estabilidade:\r\n\\[\r\n\\begin{equation}\r\n\\begin{cases}\r\n a_0 + a_1 +  1 & > 0 \\\\\r\n a_0 - a_1 + 1 & > 0 \\\\\r\n a_0 & < 1\r\n\\end{cases}\r\n\\end{equation}\r\n\\]\r\nAplicando os valores do exercícios:\r\n\r\n\r\na2 <- 1\r\na1 <- -(b+k)\r\na0 <- k\r\n\r\n\r\n\r\n\r\n\r\nrest1 <- 1 + a1 + a0 > 0\r\nrest2 <- 1- a1 + a0 > 0\r\nrest3 <- a0 < 1\r\ncbind(rest1, rest2, rest3)\r\n\r\n\r\n     rest1 rest2 rest3\r\n[1,]  TRUE  TRUE  TRUE\r\n\r\nLogo, para o conjunto de valores dos parâmetros usados na simulação, teremos um sistema estável, com um equilíbrio móvel, dada a forma de \\(\\small g(t)=A_0(1+g)^t\\).\r\nCalculando o discriminante e as raízes temos que:\r\n\r\n\r\n# Vetor de coeficientes do polinomio \r\ncoefs <- c(a0, a1, a2)\r\ncoefs\r\n\r\n\r\n[1]  0.2 -0.7  1.0\r\n\r\n\r\n\r\n# Raizes\r\nroots <- polyroot(coefs) %>% round(digits = 3)\r\nroots\r\n\r\n\r\n[1] 0.35+0.278i 0.35-0.278i\r\n\r\nComo as raízes apresentam componentes complexos, vamos calcular o módulo e o ângulo:\r\n\r\n\r\nR <- Mod(roots[1])\r\ntheta <- Arg(roots[1])\r\nrbind(R, theta) %>% round(digits = 3)\r\n\r\n\r\n       [,1]\r\nR     0.447\r\ntheta 0.671\r\n\r\nComo o módulo é menor que a unidade, as séries apresentam ciclos amortecidos (não explosivos)\r\nA solução particular será dada por:\r\n\\[\r\nY^p_t = K(1 + g)^t\r\n\\]\r\nSubstituindo \\(\\small Y^p_t\\), \\(\\small Y^p_{t−1}\\) e \\(\\small Y^p_{t−2}\\) na eq. em diferenças, temos que:\r\n\\[\r\nK = \\frac{A_0(1+g)^2}{(1 + g)^2 − (b + k)(1 + g) + k}\r\n\\]\r\ncondicionado a um denominador positivo \\(\\small \\forall t\\). Assim, neste caso, temos a solução homogênea e particular dadas por:\r\n\r\n\r\n# Calculando K\r\nK <- (A0 * (1 + g)^2) / ((1 + g)^2 - (b + k) * (1 + g) + k)\r\nK\r\n\r\n\r\n[1] 1.942731\r\n\r\n\r\n\r\n# Talvez usar Y[1] e Y[2] mesmo\r\nA3 <- Y0 - K\r\nA4 <- (1 / sin(theta)) * ((Y1 - K * (1 + g)) / R - A3 * cos(theta))\r\nrbind(A3, A4)\r\n\r\n\r\n        [,1]\r\nA3  18.05727\r\nA4 -12.08601\r\n\r\n\r\n\r\norbita_hicks_analitica <- function(A3, A4, R, theta, t) {\r\n    \r\n  Yh <- vector(mode = \"numeric\", length = t)\r\n  Yp <- vector(mode = \"numeric\", length = t)\r\n  Y2 <- vector(mode = \"numeric\", length = t)\r\n  \r\n  for (i in 1:t) {\r\n    Yh[i] <- (R^i) * (A3 * cos(theta * i) + A4 * sin(theta * i))\r\n    Yp[i] <- K * (1 + g)^i\r\n    Y2[i] <- Yh[i] + Yp[i]\r\n  }\r\n  \r\n  out <- cbind(Yh, Yp, Y2)\r\n  \r\n  return(out)\r\n} \r\n\r\n\r\n\r\n\r\n\r\norbita_hicks_analitica(A3 = A3, A4 = A4, R = R, theta = theta, t = t) %>%\r\n  ts() %>%\r\n  autoplot(facets = F) +\r\n  theme_hc() +\r\n  scale_x_continuous(breaks = seq(0, 80, 10)) +\r\n  scale_y_continuous(breaks = seq(0, 100, 10)) +\r\n  scale_color_discrete(\"\") +\r\n  theme(legend.position = \"top\")\r\n\r\n\r\n\r\n\r\nComparando os dois resultados (simulação e analítico) para Y:\r\n\r\n\r\nY <- orbita_hicks(b = b, k = k, g = g, A0 = A0, Y0 = Y0, Y1 = Y1, t = t)[,5]\r\nanalit <- orbita_hicks_analitica(A3 = A3, A4 = A4, R = R, theta = theta, t = t)\r\n\r\nresult <- cbind(analit, Y)\r\nhead(result, n = 10)\r\n\r\n\r\n                Yh       Yp        Y2        Y\r\n [1,]  2.960132159 2.039868 5.0000000 8.050000\r\n [2,] -1.535460863 2.141861 0.6064004 4.212500\r\n [3,] -1.666209648 2.248954 0.5827446 2.496375\r\n [4,] -0.859586240 2.361402 1.5018158 2.120469\r\n [5,] -0.268828340 2.479472 2.2106438 2.261335\r\n [6,] -0.016448261 2.603446 2.5869975 2.498936\r\n [7,]  0.042193819 2.733618 2.7758118 2.704089\r\n [8,]  0.032821772 2.870299 2.9031207 2.870530\r\n [9,]  0.014545591 3.013814 3.0283594 3.019882\r\n[10,]  0.003624649 3.164505 3.1681292 3.168706\r\n\r\nresult %>%\r\n  ts() %>%\r\n  autoplot(facets = F) +\r\n  theme_hc() +\r\n  scale_x_continuous(breaks = seq(0, 80, 10)) +\r\n  scale_y_continuous(breaks = seq(0, 100, 10)) +\r\n  scale_color_discrete(\"\") +\r\n  theme(legend.position = \"top\")\r\n\r\n\r\n\r\n\r\nUtilizando Y[1] e Y[2] ao invés de Y0 e Y1:\r\n\r\n\r\nY <- orbita_hicks(b = b, k = k, g = g, A0 = A0, Y0 = Y0, Y1 = Y1, t = t)[,5]\r\n\r\nA3 <- Y[1] - K\r\nA4 <- (1 / sin(theta)) * ((Y[2] - K * (1 + g)) / R - A3 * cos(theta))\r\nrbind(A3, A4)\r\n\r\n\r\n        [,1]\r\nA3 6.1072687\r\nA4 0.1262162\r\n\r\n\r\n\r\nanalit <- orbita_hicks_analitica(A3 = A3, A4 = A4, R = R, theta = theta, t = t)\r\n\r\nresult <- cbind(analit, Y)\r\nhead(result, n = 10)\r\n\r\n\r\n                 Yh       Yp       Y2        Y\r\n [1,]  2.1726321586 2.039868 4.212500 8.050000\r\n [2,]  0.3007079366 2.141861 2.442569 4.212500\r\n [3,] -0.2235615876 2.248954 2.025393 2.496375\r\n [4,] -0.2165697457 2.361402 2.144832 2.120469\r\n [5,] -0.1069347938 2.479472 2.372537 2.261335\r\n [6,] -0.0315871856 2.603446 2.571859 2.498936\r\n [7,] -0.0007471691 2.733618 2.732871 2.704089\r\n [8,]  0.0057875959 2.870299 2.876086 2.870530\r\n [9,]  0.0042005896 3.013814 3.018014 3.019882\r\n[10,]  0.0017841436 3.164505 3.166289 3.168706\r\n\r\nresult %>%\r\n  ts() %>%\r\n  autoplot(facets = F) +\r\n  theme_hc() +\r\n  scale_x_continuous(breaks = seq(0, 80, 10)) +\r\n  scale_y_continuous(breaks = seq(0, 100, 10)) +\r\n  scale_color_discrete(\"\") +\r\n  theme(legend.position = \"top\")\r\n\r\n\r\n\r\n\r\nEm ambos os casos, a séries de Y da simulação e da forma analítica se sobrepôem, mesmo que apresente valoris inicias divergentes.\r\n\r\n\r\n\r\n",
      "last_modified": "2021-05-25T21:01:46-03:00"
    },
    {
      "path": "sist1.html",
      "title": "Sistema de Ordem 1",
      "description": "Essa aula estuda sistemas de Equações em Diferença de ordem 1.\n",
      "author": [
        {
          "name": "Rafael Peixoto",
          "url": {}
        }
      ],
      "date": "04-30-2021",
      "contents": "\r\n\r\nContents\r\nAutovalores e Autovetores\r\nRaízes reais e diferentes\r\nRaízes reais e Iguais\r\nSolução Analítica\r\n\r\nRaízes Complexas\r\nSolução Analítica\r\n\r\nModelo de Cournot\r\nDuas Firmas\r\nMais de duas firmas\r\n\r\n\r\n\r\n\r\nd-article p {\r\n  text-align: justify;\r\n  font-size: 16px;\r\n}\r\n\r\nd-article p code {\r\n  background: rgba(230, 230, 230, 1);\r\n}\r\n\r\nspan.math.inline {\r\n  background: rgba(230, 230, 230, 1);\r\n  font-size: 15px;\r\n}\r\n\r\nd-article div.sourceCode {\r\n  overflow: auto !important;\r\n}\r\n\r\n\r\nAutovalores e Autovetores\r\nSeja a matriz:\r\n\\[\r\n\\begin{equation}\r\n  A = \r\n  \\begin{bmatrix}\r\n    2 & 1 \\\\\r\n    1 & 2\r\n  \\end{bmatrix}\r\n\\end{equation}\r\n\\]\r\nPara identificarmos seus autovalores e autovetores:\r\n\r\n\r\n# Criando Matriz A\r\nA <- matrix(c(2, 1, 1, 2), ncol = 2)\r\n\r\n# objeto contendo os autovalres e autovetores de A\r\nr <- eigen(A)\r\nr\r\n\r\n\r\neigen() decomposition\r\n$values\r\n[1] 3 1\r\n\r\n$vectors\r\n          [,1]       [,2]\r\n[1,] 0.7071068 -0.7071068\r\n[2,] 0.7071068  0.7071068\r\n\r\n\r\n\r\nlambda <- r$values\r\nP <- r$vectors\r\n\r\n\r\n\r\nPara verificar a independência dos autovetores, basta observar que P é uma matriz quadrada de ordem \\(\\small n = 2\\). Logo, havendo independência linear entre as suas colunas (ou linhas) , o seu determinante deverá ser diferente de zero (matriz não singular). E esse ponto é importante pois para obter a solução analítica de um sistema de ordem n, precisamos da matriz P e da sua inversa:\r\n\r\n\r\ndet(P)\r\n\r\n\r\n[1] 1\r\n\r\nComo o determinante é diferente de 0, podemos calcular a inversa da matriz. Com \\(\\small P\\) e \\(\\small P^{-1}\\), podemos calcular a matriz diagonal D:\r\n\r\n\r\nD <- inv(P) %*% A %*% P\r\nD\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    3    0\r\n[2,]    0    1\r\n\r\nAo transformar a matriz A via \\(\\small P^{−1}AP\\), obtemos a a matriz diagonal D, cuja diagonal principal é composta pelos autovalores de A. Dai o nome do processo de diagonalização de matrizes.\r\nHavendo multiplicidade, precisamos verificar se é possível obter a matriz P. Obter a matriz P implica ter uma matriz A diagonalizável. Isto porque o fato de um autovalor ter multiplicidade k não necessariamente anula a possibilidade de, para o mesmo autovalor, obter k autovetores L.I. Tudo dependerá do posto da matriz \\(\\small (A − \\lambda I)\\).\r\nExemplo 1:\r\nSeja a matriz:\r\n\\[\r\n\\begin{equation}\r\n  A = \r\n  \\begin{bmatrix}\r\n    1 & 2 & 3 \\\\\r\n    0 & 1 & 2 \\\\\r\n    0 & 0 & 1\r\n  \\end{bmatrix}\r\n\\end{equation}\r\n\\]\r\nAnalisando os seus autovalores, observamos que a matriz possui três raízes reais e repetidas:\r\n\r\n\r\nA <- matrix(c(1, 0, 0, 2, 1, 0, 3, 2, 1), ncol = 3)\r\nr <- eigen(A)\r\nlambda <- r$values\r\nP <- r$vectors %>% zapsmall()\r\nlambda\r\n\r\n\r\n[1] 1 1 1\r\n\r\nOu seja, \\(\\small \\lambda = 1\\) possui multiplicidade \\(\\small k = 3\\).\r\nVejamos se P é inversível (possui determinante diferente de zero):\r\n\r\n\r\ndet(P)\r\n\r\n\r\n[1] 0\r\n\r\nP não é inversível, portanto não podemos diagonizar A.\r\nExemplo 2:\r\nSeja a matriz:\r\n\\[\r\n\\begin{equation}\r\n  A = \r\n  \\begin{bmatrix}\r\n    1 & 3 & 3 \\\\\r\n    0 & 4 & 0 \\\\\r\n    -3 & 3 & 1\r\n  \\end{bmatrix}\r\n\\end{equation}\r\n\\]\r\nCalculamos os seus autovalores e autovetores:\r\n\r\n\r\nA <- matrix( c(1, 0, -3, 3, 4, 3, -3, 0, 1), ncol = 3)\r\nr <- eigen(A)\r\nlambda = r$values\r\nP <- r$vectors %>% zapsmall()\r\nlambda\r\n\r\n\r\n[1]  4  4 -2\r\n\r\nDe onde temos que \\(\\small \\lambda_1 = \\lambda_2 = 4\\) e \\(\\small \\lambda_3 = -2\\). Logo, temos um autovalor com multiplicidade \\(\\small k = 2\\).\r\nVejamos se P é inversível (possui determinante diferente de zero):\r\n\r\n\r\ndet(P)\r\n\r\n\r\n[1] -0.7559289\r\n\r\nP é inversível, portanto podemos diagonizar A.\r\nRaízes reais e diferentes\r\nSeja o sistema homogêneo:\r\n\\[\r\n\\begin{cases}\r\nx_{t+1} = y_t \\\\\r\ny_{t+1} = 0.125x_t + 0.25y_t\r\n\\end{cases}\r\n\\]\r\nMatricialmente, podemos reescrever o sistema tal que\r\n\\[\r\nZ_{t+1} = A \\cdot Z_t\r\n\\]\r\nonde:\r\n\\[\r\n\\begin{align}\r\nA = \r\n  \\begin{bmatrix}\r\n    0 & 1 \\\\\r\n    0.125 & 0.25\r\n  \\end{bmatrix}; \\qquad\r\nZ_t = \r\n  \\begin{bmatrix}\r\n    x_t \\\\\r\n    y_t\r\n  \\end{bmatrix} \r\n\\end{align}\r\n\\]\r\nO processo de diagonalização feito a seguir é derivado da seguinte transformação do sistema:\r\n\\[\r\n\\bar{Z}_{t+1} = D \\cdot \\bar{Z}_t\r\n\\]\r\nou:\r\n\\[\r\n\\begin{align}\r\n  \\begin{bmatrix}\r\n    \\bar{x}_{t+1} \\\\\r\n    \\bar{y}_{t+1}\r\n  \\end{bmatrix}\r\n = \r\n  \\begin{bmatrix}\r\n    \\lambda_1 & 0 \\\\\r\n    0 & \\lambda_2\r\n  \\end{bmatrix}\r\n\\cdot\r\n  \\begin{bmatrix}\r\n    \\bar{x}_{t} \\\\\r\n    \\bar{y}_{t}\r\n  \\end{bmatrix}\r\n\\end{align}\r\n\\]\r\nou seja:\r\n\\[\r\n\\bar{x}_{t+1} = \\lambda_1 \\bar{x}_{t} \\quad \\Rightarrow \\quad \\bar{x}_{t} = A_1(\\lambda_1)^t \\\\\r\n\\bar{y}_{t+1} = \\lambda_2 \\bar{y}_{t} \\quad \\Rightarrow \\quad \\bar{y}_{t} = A_2(\\lambda_2)^t\r\n\\]\r\nCalculando os autovalores e autovetores da matriz A:\r\n\r\n\r\nA <- matrix( c(0, 0.125, 1, 0.25), ncol = 2)\r\nr <- eigen(A)\r\nlambda = r$values\r\nP <- r$vectors\r\nr\r\n\r\n\r\neigen() decomposition\r\n$values\r\n[1]  0.50 -0.25\r\n\r\n$vectors\r\n           [,1]       [,2]\r\n[1,] -0.8944272 -0.9701425\r\n[2,] -0.4472136  0.2425356\r\n\r\ntemos o caso de um sistema com autovalores reais e diferentes. Logo, é possível diagonalizar A e determinar a seguir a sua forma analítica, a partir dos seus autovetores L. I.:\r\n\r\n\r\ndet(P)\r\n\r\n\r\n[1] -0.6507914\r\n\r\nP é inversível, portanto podemos diagonalizar A.\r\nPara fins de análise de estabilidade, veja que como \\(\\small |\\lambda_1| = 0.5 < 1\\) e \\(\\small |\\lambda_2| = −0.25 < 1\\), logo, esperamos uma trajetória estável; e como \\(\\small |\\lambda_2| < 0\\) esperamos observar oscilações amortecidas nas tarjetórias de \\(\\small x_y\\) e \\(\\small y_t\\). Para validar a análise, podemos simular o sistema, dada uma condição inicial:\r\n\\[\r\n\\begin{align}\r\nZ_0 =\r\n  \\begin{bmatrix}\r\n    x_0 \\\\\r\n    y_0\r\n  \\end{bmatrix}\r\n  =\r\n  \\begin{bmatrix}\r\n    1 \\\\\r\n    0.1\r\n  \\end{bmatrix}\r\n\\end{align}\r\n\\]\r\nAssim, temos que:\r\n\r\n\r\nZ0 <- c(1, 0.1)\r\nt <- 20\r\n\r\n\r\n\r\nPara simular essa série vamos, antes, construir a função de órbita de um sistema de ordem 1:\r\n\r\n\r\n# Função que calcula a orbita de um sistema de Eq em diferença de ordem 1\r\norbita_sis_1 <- function(A, Z0, t) {\r\n  \r\n  Z <- matrix(data = 0, nrow = 2, ncol = t)\r\n  Z[, 1] <- Z0\r\n  \r\n  for (i in 1:(t-1)) {\r\n    Z[, i+1] <- A %*% Z[, i]\r\n  }\r\n  \r\n  Z <- t(Z)\r\n  colnames(Z) <- c(\"x\", \"y\")\r\n  \r\n  return(Z)\r\n  \r\n}\r\n\r\n\r\n\r\n\r\n\r\norbita_sis_1(A = A, Z0 = Z0, t = t) %>% \r\n  ts() %>%\r\n  autoplot(facets = F) +\r\n  theme_hc() +\r\n  scale_x_continuous(breaks = seq(0, 20, 2)) +\r\n  scale_y_continuous(breaks = seq(0, 1, 0.1)) +\r\n  scale_color_discrete(\"\") +\r\n  theme(legend.position = \"top\")\r\n\r\n\r\n\r\n\r\nLembre do efeito da condição inicial e da janela de tempo considerada na simulação. Observe também que a raíz negativa possui um módulo pequeno (−0.25), que é atenuado rapidamente a medida que t aumenta. Analisando cada componente (referente à parte de cada autovalor e autovetor), podemos ter uma melhor compreensão da dinâmica observada neste caso. Primeiro, identificamos os valores das constantes arbitrárias, \\(\\small A_1\\) e \\(\\small A_2\\), considerando que \\(\\small Z_0 = A_1v_1 + A_2v_2 = P \\cdot X\\). Logo, \\(\\small X = (A_1, A_2) = P^{−1} \\cdot Z_0\\).\r\nVamos construir a função de órbita dos componentes:\r\n\r\n\r\n# Função que calcula a orbita dos componentes um sistema de Eq em diferença de ordem 1\r\norbita_sis_comp_1 <- function(A, Z0, t) {\r\n  \r\n  Z1 <- matrix(data = 0, nrow = 2, ncol = t)\r\n  Z2 <- matrix(data = 0, nrow = 2, ncol = t)\r\n  \r\n  r <- eigen(A)\r\n  lambda = r$values\r\n  P <- r$vectors\r\n  X <- inv(P) %*% Z0\r\n  \r\n  A1 <- X[1]\r\n  A2 <- X[2]\r\n  v1 <- P[, 1]\r\n  v2 <- P[, 2]\r\n  \r\n  for (i in 0:(t-1)) {\r\n    Z1[, i+1] <- A1 * v1 * lambda[1]^i\r\n    Z2[, i+1] <- A2 * v2 * lambda[2]^i\r\n  }\r\n  \r\n  out <- rbind(Z1, Z2) %>% \r\n    t()\r\n  colnames(out) <- c(\"X-Comp.1\", \"Y-Comp.1\", \"X-Comp.2\", \"Y-Comp.2\")\r\n\r\n  return(out)\r\n  \r\n}\r\n\r\n\r\n\r\n\r\n\r\norbita_sis_comp_1(A = A, Z0 = Z0, t = t) %>%\r\n  ts() %>%\r\n  autoplot(facets = F) +\r\n  theme_hc() +\r\n  scale_x_continuous(breaks = seq(0, 20, 2)) +\r\n  scale_y_continuous(breaks = seq(-1, 1, 0.1)) +\r\n  scale_color_discrete(\"\") +\r\n  theme(legend.position = \"top\")\r\n\r\n\r\n\r\n\r\nRaízes reais e Iguais\r\nSeja a matriz:\r\n\\[\r\n\\begin{equation}\r\n  A = \r\n  \\begin{bmatrix}\r\n    4 & 1 \\\\\r\n    -1 & 2  \r\n  \\end{bmatrix}\r\n\\end{equation}\r\n\\]\r\nCalculamos os seus autovalores e autovetores:\r\n\r\n\r\nA <- matrix(c(4, -1, 1, 2), nrow=2)\r\nr <- eigen(A)\r\nP <- r$vectors %>% zapsmall()\r\nlambda <- r$values\r\nr\r\n\r\n\r\neigen() decomposition\r\n$values\r\n[1] 3 3\r\n\r\n$vectors\r\n           [,1]       [,2]\r\n[1,]  0.7071068 -0.7071068\r\n[2,] -0.7071068  0.7071068\r\n\r\nA simulação do sistema sai da mesma forma como antes:\r\n\r\n\r\nA <- matrix(c(4, -1, 1, 2), nrow=2)\r\nZ0 <- c(2, -1)\r\nt <- 10\r\n\r\n\r\n\r\n\r\n\r\norbita_sis_1(A = A, Z0 = Z0, t = t) %>% \r\n  ts() %>%\r\n  autoplot(facets = F) +\r\n  theme_hc() +\r\n  scale_x_continuous(breaks = seq(0, 10, 1)) +\r\n  scale_color_discrete(\"\") +\r\n  theme(legend.position = \"top\")\r\n\r\n\r\n\r\n\r\nSolução Analítica\r\nVamos agora para a forma analítica.\r\nVejamos se P é inversível (determinante diferente de zero):\r\n\r\n\r\ndet(P)\r\n\r\n\r\n[1] 0\r\n\r\nComo P não é inversível, não podemos diagonalizar A. Assim, não temos como transformar o sistema original a um sistema desacoplado, mas ainda é possível transforma-lo a um sistema quase desacoplado.\r\nDada que A não é diagonalizável, Precisamos fazer uso de uma matriz de transformação \\(\\small \\Lambda\\) quase diagonal, dada por:\r\n\\[\r\n\\begin{align}\r\n  \\Lambda = \r\n    \\begin{bmatrix}\r\n      \\lambda & 1 \\\\\r\n      0 & \\lambda\r\n    \\end{bmatrix}\r\n\\end{align}\r\n\\]\r\ntal que:\r\n\\[\r\nP^{-1}AP = \\Lambda\r\n\\]\r\nMultiplicando P à equerda em ambos os lados:\r\n\\[\r\nAP = P \\Lambda\r\n\\]\r\nonde \\(\\small P = [c_1 | c_2]\\) é inversível.\r\nAssim,\r\n\\[\r\nA \\cdot [c_1|c_2] = [c_1|c_2] \\cdot \r\n  \\begin{bmatrix}\r\n    \\lambda & 1 \\\\\r\n    0 & \\lambda\r\n  \\end{bmatrix}\r\n\\]\r\nRealizando os produtos matriciais, temos:\r\n\\[\r\n[Ac_1|Ac_2] = [\\lambda c_1|c_1 + \\lambda c_2]\r\n\\]\r\nPortanto:\r\n\\[\r\n\\begin{align}\r\n  \\cases{\r\n    Ac_1 = \\lambda c_1 \\\\\r\n    Ac_2 = c_1 + \\lambda c_2\r\n  } \\quad \\to \\quad\r\n  \\cases{\r\n    (A-\\lambda I)c_1 &=  0 \\\\\r\n    (A-\\lambda I)^2c_2 &=  0\r\n  }\r\n\\end{align}\r\n\\]\r\nPortanto, \\(\\small c_2\\) é autovetor generalizado de \\(\\small A\\) associado a \\(\\small \\lambda\\)!!\r\nAssim, precisamos do autovetor generalizado, c2. Que por definição:\r\n\\[\r\n(A - \\lambda I)c_2 = v_1\r\n\\] Onde \\(\\small v_1\\) é o único autovetor L.I associado a \\(\\small \\lambda\\).\r\nVoltando ao exercício (queremos achar \\(\\small P=[v_1|c_2]\\)):\r\n\r\n\r\nP\r\n\r\n\r\n           [,1]       [,2]\r\n[1,]  0.7071068 -0.7071068\r\n[2,] -0.7071068  0.7071068\r\n\r\ndet(P)\r\n\r\n\r\n[1] 0\r\n\r\n\r\n\r\nv1 <- P[, 1]\r\nv1\r\n\r\n\r\n[1]  0.7071068 -0.7071068\r\n\r\nLogo, resolvendo o sistema indeterminado:\r\n\r\n\r\nM <- A - diag(lambda[1], 2)\r\nM\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    1    1\r\n[2,]   -1   -1\r\n\r\n\r\n\r\nB <- matrix(data = v1, nrow = 2)\r\nB\r\n\r\n\r\n           [,1]\r\n[1,]  0.7071068\r\n[2,] -0.7071068\r\n\r\n\r\n\r\nMhat <- cbind(M, B)\r\nMhat\r\n\r\n\r\n     [,1] [,2]       [,3]\r\n[1,]    1    1  0.7071068\r\n[2,]   -1   -1 -0.7071068\r\n\r\n\r\n\r\nMhat_esc <- echelon(Mhat)\r\nMhat_esc\r\n\r\n\r\n     [,1] [,2]      [,3]\r\n[1,]    1    1 0.7071068\r\n[2,]    0    0 0.0000000\r\n\r\nTemos portanto, um S.I., com o posto sendo igual a 1. Se \\(\\small c2 = (a, b)\\), da única linha não nula temos que:\r\n\\[\r\na + b = 0.707168\r\n\\]\r\nLogo, se b é a nossa variável livre (\\(\\small n − p = 2 − 1 = 1\\) grau de liberdade), temos que:\r\n\\[\r\na = 0.707168 - b\r\n\\]\r\nNote que a medida que b aumenta, a diminui. E vice versa. Logo, plotando todos os pares possíveis de a e b no espaço bidimensional, teríamos como resultado uma reta com inclinação negativa igual a −1. Uma solução possível seria, por exemplo, para o caso de \\(\\small b = 0\\). Com isso, \\(\\small a = 0.707168\\) e por tanto\r\n\\[\r\nc_2 = (0.707168, 0)\r\n\\]\r\nque poderia ser utilizado para a formulação da solução analítica.\r\nRaízes Complexas\r\nSeja o sistema (Shone, ex. 12, cap. 5):\r\n\\[\r\n\\begin{align}\r\n  &\\cases{\r\n    x_{t+1} = -5 + x_t - 2y_t \\\\\r\n    y_{t+1} = 4 + x_t - y_t\r\n  } \\\\[5pt]\r\n  &\\cases{\r\n    x_0 = 1 \\\\\r\n    y_0 = 2\r\n  }\r\n\\end{align}\r\n\\]\r\nA Matriz A é\r\n\\[\r\n\\begin{align}\r\n  A =\r\n    \\begin{bmatrix}\r\n      1 & -2 \\\\\r\n      1 & -1\r\n    \\end{bmatrix}\r\n\\end{align}\r\n\\]\r\nE o termo independente é\r\n\\[\r\n\\begin{align}\r\n  B =\r\n    \\begin{bmatrix}\r\n      -5 \\\\\r\n      4\r\n    \\end{bmatrix}\r\n\\end{align}\r\n\\]\r\nSimulando esse sistema:\r\n\r\n\r\nA <- matrix(c(1, 1, -2, -1), nrow=2)\r\nB <- matrix(c(-5, 4), nrow=2)\r\nZ0 <- c(1, 2)\r\nt <- 20\r\n\r\n\r\n\r\n\r\n\r\norbita_sis_1(A = A, Z0 = Z0, t = t) %>% \r\n  ts() %>%\r\n  autoplot(facets = F) +\r\n  theme_hc() +\r\n  scale_x_continuous(breaks = seq(0, 20, 1)) +\r\n  scale_y_continuous(breaks = seq(-4, 4, 1)) +\r\n  scale_color_discrete(\"\") +\r\n  theme(legend.position = \"top\")\r\n\r\n\r\n\r\n\r\nEssa, entretanto, é a órbita para o sistema homogêneo. Para a órbita que considera a solução particular, precisamos modificar a função, incluindo o termo independente:\r\n\r\n\r\n# Função que calcula a orbita de um sistema de Eq em diferença de ordem 1\r\norbita_sis_1_termind <- function(A, B, Z0, t) {\r\n  \r\n  Z <- matrix(data = 0, nrow = 2, ncol = t)\r\n  Z[, 1] <- Z0\r\n  \r\n  for (i in 1:(t-1)) {\r\n    Z[, i+1] <- A %*% Z[, i] + B\r\n  }\r\n  \r\n  Z <- t(Z)\r\n  colnames(Z) <- c(\"x\", \"y\")\r\n  \r\n  return(Z)\r\n  \r\n}\r\n\r\n\r\n\r\n\r\n\r\norbita_sis_1_termind(A = A, B = B, Z0 = Z0, t = t) %>% \r\n  ts() %>%\r\n  autoplot(facets = F) +\r\n  theme_hc() +\r\n  scale_x_continuous(breaks = seq(0, 20, 1)) +\r\n  scale_y_continuous(breaks = seq(-20, 4, 2)) +\r\n  scale_color_discrete(\"\") +\r\n  theme(legend.position = \"top\")\r\n\r\n\r\n\r\n\r\nA partir da simulação, já sabemos que o sistema apresenta ciclo regulares, que não explodem e nem convergem, portanto, possui raízes complexas e com \\(\\small R = 1\\).\r\nSolução Analítica\r\nComo o sistema não é homogêneo, a solução geral será dada pela soma da solução homogênea com a solução particular \\(Z_t = Z^h_t + Z^p_t\\).\r\nRelembrando que\r\n\\[\r\n\\begin{align}\r\n  A =\r\n    \\begin{bmatrix}\r\n      1 & -2 \\\\\r\n      1 & -1\r\n    \\end{bmatrix} ; \\qquad\r\n  B =\r\n    \\begin{bmatrix}\r\n      -5 \\\\\r\n      4\r\n    \\end{bmatrix}\r\n\\end{align}\r\n\\]\r\nPrimeiro, obtemos os autovalores:\r\n\r\n\r\nA <- matrix(c(1, 1, -2, -1), nrow = 2)\r\nr <- eigen(A)\r\nlambda <- r$values\r\nP <- r$vectors\r\nr\r\n\r\n\r\neigen() decomposition\r\n$values\r\n[1] 0+1i 0-1i\r\n\r\n$vectors\r\n                     [,1]                 [,2]\r\n[1,] 0.8164966+0.0000000i 0.8164966+0.0000000i\r\n[2,] 0.4082483-0.4082483i 0.4082483+0.4082483i\r\n\r\nAo ser autovalores complexos, sabemos que a estabilidade incide sobre o módulo:\r\n\r\n\r\nR <- abs(lambda[1])\r\ntheta <- round(Arg(lambda[1]), 2)\r\nR\r\n\r\n\r\n[1] 1\r\n\r\ntheta\r\n\r\n\r\n[1] 1.57\r\n\r\nSendo \\(\\small R = 1\\), esperamos observar ciclos regulares nas séries temporais, como já apontando como gráfico.\r\nA parcela real e imaginâria dos autovetores nos permitem a construção da forma analítica da série:\r\n\r\n\r\nu <- round(Re(P[, 1]), 2)\r\nv <- round(Im(P[, 1]), 2)\r\nu\r\n\r\n\r\n[1] 0.82 0.41\r\n\r\nv\r\n\r\n\r\n[1]  0.00 -0.41\r\n\r\nAssim, a solução homogênea será dada por:\r\n\\[\r\n\\small\r\n\\begin{align}\r\n  \\begin{bmatrix}\r\n    x^h_t \\\\\r\n    y^h_t\r\n  \\end{bmatrix}\r\n  = (1)^t \\cdot \r\n  \\begin{bmatrix}\r\n    \\begin{pmatrix}\r\n      0.82 \\\\\r\n      0.41\r\n    \\end{pmatrix}\r\n  (A_1 cos(1.57t) + A_2 sin(1.57t)) + \r\n    \\begin{pmatrix}\r\n      0 \\\\\r\n      -0.41\r\n    \\end{pmatrix}\r\n  (A_2 cos(1.57t) - A_1 sin(1.57t))\r\n  \\end{bmatrix}\r\n\\end{align}\r\n\\]\r\nVejamos agora a solução particular.\r\nNo estado estacionário, sabemos que \\(\\small Z_{t+1} \\to Z_t \\approx Z^∗\\). Substituindo na equação matricial do sistema:\r\n\\[\r\nZ^∗ = A \\cdot Z^∗ + B = (I − A)^{−1} \\cdot B\r\n\\]\r\n\r\n\r\nB <- matrix(c(-5, 4), nrow = 2)\r\nZeq <- inv(diag(1, nrow(A)) - A ) %*% B\r\nZeq # Zeq é o Z*, ou seja, o Z de equilíbrio\r\n\r\n\r\n     [,1]\r\n[1,] -9.0\r\n[2,] -2.5\r\n\r\nPor tanto temos o ponto fixo \\(\\small (x^∗, y^∗) = (−9, − 2.5)\\) que não é nem atrator, nem repulsor.\r\nModelo de Cournot\r\nAnalisaremos a versão dinâmica do modelo (sec. 10.1 do Gandolfo). O modelo contempla n firmas, que ajustam as suas decisões a partir da observação do comportamento das suas concorrentes. Pragmaticamente, para cada período de tempo t, a firma i observa o comportamento das outras n−1 firmas (o produto) e assume que essas quantidades se manterão em t+1. Logo, dada a demanda, a firma i decidirá a quantidade a produzir visando a maximização dos seus lucros. Simularemos dois casos: quando n=2 e quando n>2. Seja então o mercado oligopolístico com n firmas produzindo um bem homogêneo. Assumindo uma curva de demanda linear, temos que:\r\n\\[\r\np_t = a - b \\sum^n_{i=1}x_{i,t}\r\n\\]\r\ncom a>0, b>0 e com \\(x_{i,t}\\) representando a produção atual da i−ésima firma no período t. Visando simplificar a representação, adotaremos também curvas lineares para as funções custo, \\(C_i\\), para cada firma. Com isto, garantimos que os custos marginais \\(c_i\\) sejam constantes:\r\n\\[\r\nC_{i,t} = d + c_i \\cdot x_{i,t}\r\n\\]\r\nConsiderando que as firmas maximizam os lucros e após algumas manipulações algébricas:\r\n\\[\r\nx_{i,t+1} = - \\dfrac{1}{2} \\sum^n_{j \\ne i} x_{j,t} + \\dfrac{a-c_i}{2b}\r\n\\]\r\nDuas Firmas\r\nNesse caso, as equações do sistema dinâmico são:\r\n\\[\r\n\\begin{align}\r\n  \\cases{\r\n    x_{1,t+1} = - \\dfrac{1}{2} x_{2,t} + \\dfrac{a-c_1}{2b} \\\\[7pt]\r\n    x_{2,t+1} = - \\dfrac{1}{2} x_{1,t} + \\dfrac{a-c_2}{2b}\r\n  }\r\n\\end{align}\r\n\\]\r\nA matriz de coeficientes do sistema não homogêneo é dada por:\r\n\\[\r\n\\begin{align}\r\n  A = \r\n    \\begin{bmatrix}\r\n      0 & -\\dfrac{1}{2} \\\\[7pt]\r\n      -\\dfrac{1}{2} & 0\r\n    \\end{bmatrix}\r\n\\end{align}\r\n\\]\r\ncom o termo independente sendo igual a\r\n\\[\r\n\\begin{align}\r\n  B = \r\n    \\begin{bmatrix}\r\n      \\dfrac{a-c_1}{2b} \\\\[7pt]\r\n      \\dfrac{a-c_2}{2b}\r\n    \\end{bmatrix}\r\n\\end{align}\r\n\\]\r\nDados os seguintes valores para os parâmetros:\r\n\r\n\r\nset.seed(1)\r\nn <- 2\r\na <- 10 # valor arbitrario\r\nb <- 0.5 # valor arbitrario\r\nd <- 10 # valor arbitrario\r\nc <- runif(n) # valores arbitrarios\r\nA <- matrix(-1/2, nrow = n, ncol = n) + diag(1/2, n)\r\nB <- matrix((a - c) / (2 * b), nrow = n)\r\nZ0 <- 100 * runif(n) # condicoes iniciais para cada uma das n firmas\r\nt <- 20\r\n\r\nlist(\"A\" = A, \"B\" = B, \"Z0\" = Z0)\r\n\r\n\r\n$A\r\n     [,1] [,2]\r\n[1,]  0.0 -0.5\r\n[2,] -0.5  0.0\r\n\r\n$B\r\n         [,1]\r\n[1,] 9.734491\r\n[2,] 9.627876\r\n\r\n$Z0\r\n[1] 57.28534 90.82078\r\n\r\nSimulando:\r\n\r\n\r\norbita_sis_1_termind(A = A, B = B, Z0 = Z0, t = t) %>% \r\n  ts() %>%\r\n  autoplot(facets = F) +\r\n  theme_hc() +\r\n  scale_x_continuous(breaks = seq(0, 20, 1)) +\r\n  scale_y_continuous(breaks = seq(-50, 100, 10)) +\r\n  scale_color_discrete(\"\") +\r\n  theme(legend.position = \"top\")\r\n\r\n\r\n\r\n\r\nAnalisando os autovalores de A:\r\n\r\n\r\nr <- eigen(A)\r\nlambda = r$values\r\nlambda\r\n\r\n\r\n[1]  0.5 -0.5\r\n\r\nVemos que ambos os autovalores são menores que um em módulo, havendo um autovalor negativo. Logo, ao simular as séries, esperaríamos observar (como de fato observamos) trajetórias amortecidas com oscilações transitórias. O estado estacionário será dado por (atrator):\r\n\r\n\r\nXeq = inv((diag(1, n) - A)) %*% B\r\nXeq \r\n\r\n\r\n         [,1]\r\n[1,] 6.560738\r\n[2,] 6.347507\r\n\r\nColocando no gráfico os valores de equilíbrio:\r\n\r\n\r\norbita_sis_1_termind(A = A, B = B, Z0 = Z0, t = t) %>% \r\n  ts() %>%\r\n  autoplot(facets = F) +\r\n  theme_hc() +\r\n  scale_x_continuous(breaks = seq(0, 20, 1)) +\r\n  scale_y_continuous(breaks = seq(-50, 100, 10)) +\r\n  scale_color_discrete(\"\") +\r\n  theme(legend.position = \"top\") +\r\n  geom_hline(yintercept = Xeq[1], linetype = \"dashed\", color = \"red\") +\r\n  geom_hline(yintercept = Xeq[2], linetype = \"dotted\", color = \"blue\")\r\n\r\n\r\n\r\n\r\nMais de duas firmas\r\nAntes de analisar esse caso, vamos reescrever a função de órbita para admitir mais de 2 equações (basta acrescentar o parâmetro n):\r\n\r\n\r\n# Função que calcula a orbita de um sistema de Eq em diferença de ordem 1\r\norbita_sis_neqs <- function(A, B, Z0, n, t) {\r\n  \r\n  Z <- matrix(data = 0, nrow = n, ncol = t)\r\n  Z[, 1] <- Z0\r\n  \r\n  for (i in 1:(t-1)) {\r\n    Z[, i+1] <- A %*% Z[, i] + B\r\n  }\r\n  \r\n  Z <- t(Z)\r\n  colnames(Z) <- c(paste0(rep(\"X.\"), 1:n))\r\n  \r\n  return(Z)\r\n  \r\n}\r\n\r\n\r\n\r\n\r\n\r\nset.seed(1)\r\nn <- 6\r\na <- 10 # valor arbitrario\r\nb <- 0.5 # valor arbitrario\r\nd <- 10 # valor arbitrario\r\nc <- runif(n) # valores arbitrarios\r\nA <- matrix(-1/2, nrow = n, ncol = n) + diag(1/2, n)\r\nB <- matrix((a - c) / (2 * b), nrow = n)\r\nZ0 <- 100 * runif(n) # condicoes iniciais para cada uma das n firmas\r\nt <- 20\r\n\r\nlist(\"A\" = A, \"B\" = B, \"Z0\" = Z0)\r\n\r\n\r\n$A\r\n     [,1] [,2] [,3] [,4] [,5] [,6]\r\n[1,]  0.0 -0.5 -0.5 -0.5 -0.5 -0.5\r\n[2,] -0.5  0.0 -0.5 -0.5 -0.5 -0.5\r\n[3,] -0.5 -0.5  0.0 -0.5 -0.5 -0.5\r\n[4,] -0.5 -0.5 -0.5  0.0 -0.5 -0.5\r\n[5,] -0.5 -0.5 -0.5 -0.5  0.0 -0.5\r\n[6,] -0.5 -0.5 -0.5 -0.5 -0.5  0.0\r\n\r\n$B\r\n         [,1]\r\n[1,] 9.734491\r\n[2,] 9.627876\r\n[3,] 9.427147\r\n[4,] 9.091792\r\n[5,] 9.798318\r\n[6,] 9.101610\r\n\r\n$Z0\r\n[1] 94.467527 66.079779 62.911404  6.178627 20.597457 17.655675\r\n\r\n\r\n\r\norbita_sis_neqs(A = A, B = B, Z0 = Z0, n = n, t = t) %>% \r\n  ts() %>%\r\n  autoplot(facets = F) +\r\n  theme_hc() +\r\n  scale_x_continuous(breaks = seq(0, 20, 1)) +\r\n  scale_color_discrete(\"\") +\r\n  theme(legend.position = \"top\")\r\n\r\n\r\n\r\n\r\nVoltando ao exercício, para \\(n = 3\\), as equações do sistema serão:\r\n\\[\r\n\\begin{align}\r\n  \\cases{\r\n    x_{1,t+1} = - \\dfrac{1}{2} x_{2,t} - \\dfrac{1}{2} x_{3,t} + \\dfrac{a-c_1}{2b} \\\\[7pt]\r\n    x_{2,t+1} = - \\dfrac{1}{2} x_{1,t} - \\dfrac{1}{2} x_{3,t} + \\dfrac{a-c_2}{2b} \\\\[7pt]\r\n    x_{3,t+1} = - \\dfrac{1}{2} x_{1,t} - \\dfrac{1}{2} x_{2,t} + \\dfrac{a-c_3}{2b} \\\\\r\n  }\r\n\\end{align}\r\n\\]\r\nLogo, a matriz A será dada por\r\n\\[\r\n\\begin{align}\r\n  A = \r\n    \\begin{bmatrix}\r\n      0 & -\\dfrac{1}{2} & -\\dfrac{1}{2} \\\\[7pt]\r\n      -\\dfrac{1}{2} & 0 & -\\dfrac{1}{2} \\\\[7pt]\r\n      -\\dfrac{1}{2} & -\\dfrac{1}{2} & 0\r\n    \\end{bmatrix}\r\n\\end{align}\r\n\\]\r\nSimulando:\r\n\r\n\r\nset.seed(1)\r\nn <- 3\r\na <- 10 # valor arbitrario\r\nb <- 0.5 # valor arbitrario\r\nd <- 10 # valor arbitrario\r\nc <- runif(n) # valores arbitrarios\r\nA <- matrix(-1/2, nrow = n, ncol = n) + diag(1/2, n)\r\nB <- matrix((a - c) / (2 * b), nrow = n)\r\nZ0 <- 100 * runif(n) # condicoes iniciais para cada uma das n firmas\r\nt <- 20\r\n\r\nlist(\"A\" = A, \"B\" = B, \"Z0\" = Z0)\r\n\r\n\r\n$A\r\n     [,1] [,2] [,3]\r\n[1,]  0.0 -0.5 -0.5\r\n[2,] -0.5  0.0 -0.5\r\n[3,] -0.5 -0.5  0.0\r\n\r\n$B\r\n         [,1]\r\n[1,] 9.734491\r\n[2,] 9.627876\r\n[3,] 9.427147\r\n\r\n$Z0\r\n[1] 90.82078 20.16819 89.83897\r\n\r\n\r\n\r\norbita_sis_neqs(A = A, B = B, Z0 = Z0, n = n, t = t) %>% \r\n  ts() %>%\r\n  autoplot(facets = F) +\r\n  theme_hc() +\r\n  scale_x_continuous(breaks = seq(0, 20, 1)) +\r\n  scale_y_continuous(breaks = seq(-50, 100, 10)) +\r\n  scale_color_discrete(\"\") +\r\n  theme(legend.position = \"top\")\r\n\r\n\r\n\r\n\r\ne analisando os seus autovalores:\r\n\r\n\r\nr = eigen(A)\r\nlambda = r$values\r\nlambda\r\n\r\n\r\n[1]  0.5  0.5 -1.0\r\n\r\nobservamos a presenção de um autovalor com módulo unitário e oscilações regulares. Logo, o sistema não é estável no longo prazo.\r\nPara n = 4:\r\n\r\n\r\nset.seed(1)\r\nn <- 4\r\na <- 10 # valor arbitrario\r\nb <- 0.5 # valor arbitrario\r\nd <- 10 # valor arbitrario\r\nc <- runif(n) # valores arbitrarios\r\nA <- matrix(-1/2, nrow = n, ncol = n) + diag(1/2, n)\r\nB <- matrix((a - c) / (2 * b), nrow = n)\r\nZ0 <- 100 * runif(n) # condicoes iniciais para cada uma das n firmas\r\nt <- 20\r\n\r\nlist(\"A\" = A, \"B\" = B, \"Z0\" = Z0)\r\n\r\n\r\n$A\r\n     [,1] [,2] [,3] [,4]\r\n[1,]  0.0 -0.5 -0.5 -0.5\r\n[2,] -0.5  0.0 -0.5 -0.5\r\n[3,] -0.5 -0.5  0.0 -0.5\r\n[4,] -0.5 -0.5 -0.5  0.0\r\n\r\n$B\r\n         [,1]\r\n[1,] 9.734491\r\n[2,] 9.627876\r\n[3,] 9.427147\r\n[4,] 9.091792\r\n\r\n$Z0\r\n[1] 20.16819 89.83897 94.46753 66.07978\r\n\r\n\r\n\r\norbita_sis_neqs(A = A, B = B, Z0 = Z0, n = n, t = t) %>% \r\n  ts() %>%\r\n  autoplot(facets = F) +\r\n  theme_hc() +\r\n  scale_x_continuous(breaks = seq(0, 20, 1)) +\r\n  scale_color_discrete(\"\") +\r\n  theme(legend.position = \"top\")\r\n\r\n\r\n\r\n\r\ne os seus autovalores são\r\n\r\n\r\nr = eigen(A)\r\nlambda = r$values\r\nlambda\r\n\r\n\r\n[1]  0.5  0.5  0.5 -1.5\r\n\r\nteremos um autovalor com módulo maior que um e por tanto, obteremos trajetórias instáveis com oscilações explosivas, como o gráfico deixa claro.\r\nDe forma geral, para \\(n > 3\\) teremos trajetórias não convergentes, pois podemos demonstrar (ver o livro) que nesses casos, teremos sempre um autovalor \\(\\lambda = -(n-1)/2\\), que possui módulo maior que a unidade para o caso de três firmas em diante.\r\n\r\n\r\n\r\n",
      "last_modified": "2021-05-25T21:02:02-03:00"
    }
  ],
  "collections": []
}
