{
  "articles": [
    {
      "path": "about.html",
      "title": "Algebra Linear",
      "description": "Essa aula estuda vetores, matrizes e sistemas lineares.\n",
      "author": [
        {
          "name": "Rafael Peixoto",
          "url": {}
        }
      ],
      "date": "03-26-2021",
      "contents": "\r\n\r\nContents\r\nVetores\r\nOperações com Vetores\r\nOutras funções\r\n\r\nMatrizes\r\nMatrizes especiais\r\nOperações com Matrizes\r\nAcesso aos Valores\r\n\r\nSistemas Lineares\r\nVisualização de sistemas simples\r\nSistemas de duas variáveis\r\nSistemas de três variáveis\r\nEscalonamento de matrizes (Gauss-Jordan)\r\nPosto de uma matriz\r\n\r\nResolução Numérica de Sistemas\r\nSistema Determinado\r\nSistema Indeterminado\r\nTeorema de Binet\r\nInversa\r\nDependencia Linear\r\nAutovalores\r\n\r\nExercícios sobre estrutura de ontrole\r\nExercícios Semana 3\r\n\r\n\r\n\r\nd-article p {\r\n  text-align: justify;\r\n  font-size: 16px;\r\n}\r\n\r\nd-article p code {\r\n  background: rgba(236, 236, 236, 0.8);\r\n}\r\n\r\nd-article div.sourceCode {\r\n  overflow: auto !important;\r\n}\r\n\r\nVetores\r\nA função c() cria vetores no R\r\nOperações com Vetores\r\n\r\n\r\n# Soma\r\n\r\nv1 <- c(5, 8, 9, 6.25, 7, 7)\r\nv2 <- c(7, 5, 10, 3, 3, 4)\r\n\r\nsoma_vetores <- v1 + v2\r\nsoma_vetores\r\n\r\n\r\n[1] 12.00 13.00 19.00  9.25 10.00 11.00\r\n\r\n\r\n\r\n# Tamanho do vetor\r\n\r\nlength(soma_vetores)\r\n\r\n\r\n[1] 6\r\n\r\n\r\n\r\n# Produto por escalar\r\n\r\nvetor1 <- soma_vetores * 0.5\r\nvetor2 <- soma_vetores * runif(n = 1, min = 0, max = 1)\r\n\r\n\r\n\r\n\r\n\r\nvetor1\r\n\r\n\r\n[1] 6.000 6.500 9.500 4.625 5.000 5.500\r\n\r\nvetor2\r\n\r\n\r\n[1]  9.320453 10.097157 14.757383  7.184516  7.767044  8.543748\r\n\r\n\r\n\r\n# Produto Escalar\r\n\r\nprod_esca <- sum(v1 * v2)\r\nprod_esca\r\n\r\n\r\n[1] 232.75\r\n\r\n\r\n\r\n# Norma\r\n\r\nnorma_v1 <- sqrt(x = sum(v1 * v2))\r\nnorma_v1\r\n\r\n\r\n[1] 15.25615\r\n\r\nOutras funções\r\n\r\n\r\n# Sequência\r\n\r\nseq(from = 1, to = 10, by = 2)\r\n\r\n\r\n[1] 1 3 5 7 9\r\n\r\n\r\n\r\n# Repetição\r\n\r\nrep(x = c(1,3), 10)\r\n\r\n\r\n [1] 1 3 1 3 1 3 1 3 1 3 1 3 1 3 1 3 1 3 1 3\r\n\r\n\r\n\r\n# Ordenação\r\n\r\nv = c(2, 8, 3, 1, 9)\r\nsort(x = v, decreasing = FALSE)\r\n\r\n\r\n[1] 1 2 3 8 9\r\n\r\nMatrizes\r\nA função matrix() cria matrizes no R\r\n\r\n\r\n# Criando uma Matriz\r\n\r\nelementos <- seq(from = 1, to = 6, by = 1)\r\nA <- matrix(data = elementos, nrow = 2)\r\nA\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    1    3    5\r\n[2,]    2    4    6\r\n\r\n\r\n\r\n# Criando a mesma Matriz\r\n\r\nA <- matrix(data = 1:6, ncol = 3)\r\nA\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    1    3    5\r\n[2,]    2    4    6\r\n\r\n\r\n\r\n# Dimensões de uma Matriz\r\n\r\ndim(x = A)\r\n\r\n\r\n[1] 2 3\r\n\r\nnrow(x = A)\r\n\r\n\r\n[1] 2\r\n\r\nncol(x = A)\r\n\r\n\r\n[1] 3\r\n\r\nMatrizes especiais\r\n\r\n\r\n# Matriz nula\r\n\r\nmatrix(data = 0, nrow = 2, ncol = 2)\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    0    0\r\n[2,]    0    0\r\n\r\n\r\n\r\n# Matriz unitária\r\n\r\nmatrix(data = 1, nrow = 2, ncol = 2)\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    1    1\r\n[2,]    1    1\r\n\r\n\r\n\r\n# Matriz diagonal\r\n\r\ndiag(x = 1:5)\r\n\r\n\r\n     [,1] [,2] [,3] [,4] [,5]\r\n[1,]    1    0    0    0    0\r\n[2,]    0    2    0    0    0\r\n[3,]    0    0    3    0    0\r\n[4,]    0    0    0    4    0\r\n[5,]    0    0    0    0    5\r\n\r\n\r\n\r\n# Matriz identidade\r\n\r\ndiag(x = 1, nrow = 4)\r\n\r\n\r\n     [,1] [,2] [,3] [,4]\r\n[1,]    1    0    0    0\r\n[2,]    0    1    0    0\r\n[3,]    0    0    1    0\r\n[4,]    0    0    0    1\r\n\r\n\r\n\r\n# Obter a diagonal de uma matriz\r\n\r\nA <- matrix(data = 1:9, nrow = 3)\r\nA\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    1    4    7\r\n[2,]    2    5    8\r\n[3,]    3    6    9\r\n\r\ndiag(x = A)\r\n\r\n\r\n[1] 1 5 9\r\n\r\nOperações com Matrizes\r\n\r\n\r\nA <- matrix(data = c(1, 3, 2, 2, 8, 9), ncol = 2)\r\nA\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    1    2\r\n[2,]    3    8\r\n[3,]    2    9\r\n\r\nB <- matrix(data = 1:6, ncol = 2)\r\nB\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    1    4\r\n[2,]    2    5\r\n[3,]    3    6\r\n\r\nC <- matrix(data = c(5, 8, 4, 2), ncol = 2)\r\nC\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    5    4\r\n[2,]    8    2\r\n\r\n\r\n\r\n# Soma de Matrizes\r\n\r\nA + B\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    2    6\r\n[2,]    5   13\r\n[3,]    5   15\r\n\r\n\r\n\r\n# Subtração de Matrizes\r\n\r\nA - B\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    0   -2\r\n[2,]    1    3\r\n[3,]   -1    3\r\n\r\n\r\n\r\n# Produto por um escalar\r\n\r\nA * 3\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    3    6\r\n[2,]    9   24\r\n[3,]    6   27\r\n\r\n\r\n\r\n# Transposta de uma Matriz\r\n\r\nt(A)\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    1    3    2\r\n[2,]    2    8    9\r\n\r\nAcesso aos Valores\r\nPrecisamos de dois indicadores [linha, coluna]\r\n\r\n\r\n# Elemento da linha 1 e coluna 2\r\n\r\nA[1, 2]\r\n\r\n\r\n[1] 2\r\n\r\n\r\n\r\n# Todos os elementos da coluna 2\r\n\r\nA[, 2]\r\n\r\n\r\n[1] 2 8 9\r\n\r\n\r\n\r\n# Todos os elementos da linha 3\r\n\r\nA[3, ]\r\n\r\n\r\n[1] 2 9\r\n\r\n\r\n\r\n# Eliminar coluna 3\r\n\r\nA[, -3]\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    1    2\r\n[2,]    3    8\r\n[3,]    2    9\r\n\r\nSistemas Lineares\r\nPacotes para tratamento de matrizes e sistemas lineares:\r\nmatrixcale\r\nMatrix\r\nlimSolve\r\nmatlib\r\nVisualização de sistemas simples\r\nSeja o sistema:\r\n\\[\r\n\\begin{aligned}\r\n  \\begin{cases}\r\n      2x + y = 5 \\\\\r\n      x - 1y = 6\r\n  \\end{cases}\r\n\\end{aligned}\r\n\\]\r\nMatricialmente:\r\n\\[\r\n\\begin{aligned}\r\n  A = \r\n  \\begin{bmatrix}\r\n    2 & 1 \\\\\r\n    1 & -1\r\n  \\end{bmatrix}\r\n  \\qquad \r\n  B = \r\n  \\begin{bmatrix}\r\n    5 \\\\\r\n    6\r\n  \\end{bmatrix}\r\n\\end{aligned}\r\n\\] No R usaremos o pacote matlib.\r\n\r\n\r\nA <- matrix(data = c(2, 1, 1, -1), ncol = 2)\r\nB <- matrix(data = c(5, 6), ncol = 1)\r\n\r\n\r\n\r\n\r\n\r\nA\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    2    1\r\n[2,]    1   -1\r\n\r\nB\r\n\r\n\r\n     [,1]\r\n[1,]    5\r\n[2,]    6\r\n\r\nA função showEqn() nos permite visualizar as equações lineares correspondentes, a partir das matrizes \\(\\small A\\) e \\(\\small B\\); e a função plotEqn() permite a visualização das equações lineares de sistemas bivariados.\r\nSistemas de duas variáveis\r\nExemnplo 1\r\n\r\n\r\n# Visualizar as equações\r\n\r\nshowEqn(A = A, b = B)\r\n\r\n\r\n2*x1 + 1*x2  =  5 \r\n1*x1 - 1*x2  =  6 \r\n\r\n\r\n\r\n# Plotar as equações\r\n\r\nplotEqn(A = A, b = B, lwd = 1)\r\n\r\n\r\n2*x[1]   + x[2]  =  5 \r\n  x[1] - 1*x[2]  =  6 \r\n\r\n\r\nComo se observa, pela interseção das duas retas, se entende que o sistema possui uma única solução. Ou seja, é um sistema possível e determinado.\r\nExemplo 2\r\nNo caso de três equações de um sistema determinado bivariado (ainda no \\(\\mathbb{R}^ 2\\)):\r\n\r\n\r\nA <- matrix(data = c(1:3, -1, 2, 1), ncol = 2)\r\nB <- matrix(data = c(2, 1, 3), ncol = 1)\r\n\r\nshowEqn(A = A, b = B)\r\n\r\n\r\n1*x1 - 1*x2  =  2 \r\n2*x1 + 2*x2  =  1 \r\n3*x1 + 1*x2  =  3 \r\n\r\nplotEqn(A = A, b = B, lwd = 1)\r\n\r\n\r\n  x[1] - 1*x[2]  =  2 \r\n2*x[1] + 2*x[2]  =  1 \r\n3*x[1]   + x[2]  =  3 \r\n\r\n\r\nSe para definir um ponto no espaço bidimensional precisamos de apenas duas retas, o que uma terceira reta representaria no sistema? Veja que uma das equações pode ser reescrita a partir das outras duas!\r\nExemplo 3\r\nAinda no \\(\\mathbb{R}^2\\), quando temos um sistema indeterminado, a geometria resultante muda pois o sistema possui infinitas soluções:\r\n\r\n\r\nA <- matrix(data = c(2, 4, 1, 2), ncol = 2)\r\nB <- matrix(data = c(5, 10), ncol = 1)\r\n\r\nshowEqn(A = A, b = B)\r\n\r\n\r\n2*x1 + 1*x2  =   5 \r\n4*x1 + 2*x2  =  10 \r\n\r\nplotEqn(A = A, b = B, lwd = 1)\r\n\r\n\r\n2*x[1]   + x[2]  =   5 \r\n4*x[1] + 2*x[2]  =  10 \r\n\r\n\r\nExemplo 4\r\nE quando o sistema é impossível/inconsistente, geometricamente não veremos nenhum caso de interseção entre as retas:\r\n\r\n\r\nA <- matrix(data = c(1,2,3, -1, 2, 1), ncol = 2)\r\nB <-matrix(data = c(2,1,6), ncol = 1)\r\n\r\nshowEqn(A = A, b = B)\r\n\r\n\r\n1*x1 - 1*x2  =  2 \r\n2*x1 + 2*x2  =  1 \r\n3*x1 + 1*x2  =  6 \r\n\r\nplotEqn(A = A, b = B, lwd = 1)\r\n\r\n\r\n  x[1] - 1*x[2]  =  2 \r\n2*x[1] + 2*x[2]  =  1 \r\n3*x[1]   + x[2]  =  6 \r\n\r\n\r\nSistemas de três variáveis\r\nNo \\(\\mathbb{R}^3\\), podemos seguir usando a função showEqn() para verificar as equações equivalentes do sistema, mas para fins de visualização gráfica, usamos a função plotEqn3d().\r\nSistema Determinado\r\n\r\n\r\nA <- matrix(data = c(6, 2, 3, 2, 4, 2, 1, 1, 8), ncol = 3)\r\nB <- matrix(data = c(7, 7, 13), ncol = 1)\r\n\r\nshowEqn(A = A, b = B)\r\n\r\n\r\n6*x1 + 2*x2 + 1*x3  =   7 \r\n2*x1 + 4*x2 + 1*x3  =   7 \r\n3*x1 + 2*x2 + 8*x3  =  13 \r\n\r\n\r\n\r\nplotEqn3d(A = A, b = B)\r\n\r\n\r\n\r\nComo observamos, as equações agora representam planos no espaço tridimensional, e havendo uma única solução do sistema, teremos geométrica mente a solução representada pelo ponto de interseção dos três planos (das três equações).\r\nSistema Inconsistente\r\nNo caso de um sistema inconsistente, não haverá interseção entre os três planos:\r\n\r\n\r\nA <- matrix(data = c(1, 3, 1,\r\n                     1, -2, -2,\r\n                     2, 1, -1), ncol = 3, byrow = TRUE)\r\nB <- matrix(data = c(2, 3, 6), ncol = 1)\r\n\r\nshowEqn(A = A, b = B)\r\n\r\n\r\n1*x1 + 3*x2 + 1*x3  =  2 \r\n1*x1 - 2*x2 - 2*x3  =  3 \r\n2*x1 + 1*x2 - 1*x3  =  6 \r\n\r\n\r\n\r\nplotEqn3d(A = A, b = B)\r\n\r\n\r\n\r\nEscalonamento de matrizes (Gauss-Jordan)\r\n\r\n\r\nA <- matrix(data = c(6, 2, 3, 2, 4, 2, 1, 1, 8), ncol = 3)\r\nA\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    6    2    1\r\n[2,]    2    4    1\r\n[3,]    3    2    8\r\n\r\n\r\n\r\n# Escalonamento\r\n\r\nechelon(A = A, verbose = TRUE, fractions = TRUE)\r\n\r\n\r\n\r\nInitial matrix:\r\n     [,1] [,2] [,3]\r\n[1,] 6    2    1   \r\n[2,] 2    4    1   \r\n[3,] 3    2    8   \r\n\r\nrow: 1 \r\n\r\n multiply row 1 by 1/6 \r\n     [,1] [,2] [,3]\r\n[1,]   1  1/3  1/6 \r\n[2,]   2    4    1 \r\n[3,]   3    2    8 \r\n\r\n multiply row 1 by 2 and subtract from row 2 \r\n     [,1] [,2] [,3]\r\n[1,]    1  1/3  1/6\r\n[2,]    0 10/3  2/3\r\n[3,]    3    2    8\r\n\r\n multiply row 1 by 3 and subtract from row 3 \r\n     [,1] [,2] [,3]\r\n[1,]    1  1/3  1/6\r\n[2,]    0 10/3  2/3\r\n[3,]    0    1 15/2\r\n\r\nrow: 2 \r\n\r\n multiply row 2 by 3/10 \r\n     [,1] [,2] [,3]\r\n[1,]    1  1/3  1/6\r\n[2,]    0    1  1/5\r\n[3,]    0    1 15/2\r\n\r\n multiply row 2 by 1/3 and subtract from row 1 \r\n     [,1] [,2] [,3]\r\n[1,]    1    0 1/10\r\n[2,]    0    1  1/5\r\n[3,]    0    1 15/2\r\n\r\n subtract row 2 from row 3 \r\n     [,1]  [,2]  [,3] \r\n[1,]     1     0  1/10\r\n[2,]     0     1   1/5\r\n[3,]     0     0 73/10\r\n\r\nrow: 3 \r\n\r\n multiply row 3 by 10/73 \r\n     [,1] [,2] [,3]\r\n[1,]    1    0 1/10\r\n[2,]    0    1  1/5\r\n[3,]    0    0    1\r\n\r\n multiply row 3 by 1/10 and subtract from row 1 \r\n     [,1] [,2] [,3]\r\n[1,]   1    0    0 \r\n[2,]   0    1  1/5 \r\n[3,]   0    0    1 \r\n\r\n multiply row 3 by 1/5 and subtract from row 2 \r\n     [,1] [,2] [,3]\r\n[1,] 1    0    0   \r\n[2,] 0    1    0   \r\n[3,] 0    0    1   \r\n\r\nPara criar a matriz ampliada precisamos juntar a matriz de coeficientes e a matriz de termos independentes:\r\n\r\n\r\nB <- matrix(data = c(7, 7, 13), ncol = 1)\r\nB\r\n\r\n\r\n     [,1]\r\n[1,]    7\r\n[2,]    7\r\n[3,]   13\r\n\r\n\r\n\r\nA <- matrix(data = c(6, 6, 3, 2, 4, 1, 1, 1, 0.5), ncol = 3)\r\nB <- matrix(data = c(7, 2, 13), ncol = 1)\r\nechelon(A = A, B = B, verbose = TRUE, fractions = TRUE)\r\n\r\n\r\n\r\nInitial matrix:\r\n     [,1] [,2] [,3] [,4]\r\n[1,]   6    2    1    7 \r\n[2,]   6    4    1    2 \r\n[3,]   3    1  1/2   13 \r\n\r\nrow: 1 \r\n\r\n multiply row 1 by 1/6 \r\n     [,1] [,2] [,3] [,4]\r\n[1,]   1  1/3  1/6  7/6 \r\n[2,]   6    4    1    2 \r\n[3,]   3    1  1/2   13 \r\n\r\n multiply row 1 by 6 and subtract from row 2 \r\n     [,1] [,2] [,3] [,4]\r\n[1,]   1  1/3  1/6  7/6 \r\n[2,]   0    2    0   -5 \r\n[3,]   3    1  1/2   13 \r\n\r\n multiply row 1 by 3 and subtract from row 3 \r\n     [,1] [,2] [,3] [,4]\r\n[1,]    1  1/3  1/6  7/6\r\n[2,]    0    2    0   -5\r\n[3,]    0    0    0 19/2\r\n\r\nrow: 2 \r\n\r\n multiply row 2 by 1/2 \r\n     [,1] [,2] [,3] [,4]\r\n[1,]    1  1/3  1/6  7/6\r\n[2,]    0    1    0 -5/2\r\n[3,]    0    0    0 19/2\r\n\r\n multiply row 2 by 1/3 and subtract from row 1 \r\n     [,1] [,2] [,3] [,4]\r\n[1,]    1    0  1/6    2\r\n[2,]    0    1    0 -5/2\r\n[3,]    0    0    0 19/2\r\n\r\nrow: 3 \r\n\r\n\r\n\r\n# Juntando as matrizes\r\n\r\nAhat <- cbind(A, B)\r\nAhat\r\n\r\n\r\n     [,1] [,2] [,3] [,4]\r\n[1,]    6    2  1.0    7\r\n[2,]    6    4  1.0    2\r\n[3,]    3    1  0.5   13\r\n\r\nPosto de uma matriz\r\nA função R() do pacote matlib nos permite avaliar o posto de uma matriz:\r\n\r\n\r\n# Se os postos são iguais, o sistema terá solução\r\n\r\nposto_A <- R(A)\r\nposto_Ahat <- R(Ahat)\r\n\r\nc(posto_A, posto_Ahat)\r\n\r\n\r\n[1] 2 3\r\n\r\nResolução Numérica de Sistemas\r\nSistema Determinado\r\nPara o sistema determinado, temos que\r\n\\[\r\np_A = p_{\\hat{A}} = n\r\n\\]\r\nonde \\(\\small n\\) é o número de variáveis do sistema.\r\n\r\n\r\nA <- matrix(data = c(6, 2, 3, 2, 4, 2, 1, 1, 8), ncol = 3)\r\nB <- matrix(data = c(7, 7, 13), ncol = 1)\r\nn <- ncol(A)\r\n\r\nAhat <- cbind(A, B)\r\n\r\nposto_A <- R(A)\r\nposto_Ahat <- R(Ahat)\r\n\r\ncondicao1 <- posto_A == posto_Ahat\r\ncondicao2 <- posto_A == n \r\n\r\n\r\n\r\n\r\n\r\ncondicao1\r\n\r\n\r\n[1] TRUE\r\n\r\ncondicao2\r\n\r\n\r\n[1] TRUE\r\n\r\nAtendendo aos requisitos, podemos usar a função solve() sobre a matriz ampliada para obter a solução do sistema:\r\n\r\n\r\n# Sistema Determinado\r\n\r\nif (condicao1 & condicao2) {\r\n  X <- solve(A, B)\r\n  X\r\n}\r\n\r\n\r\n          [,1]\r\n[1,] 0.5890411\r\n[2,] 1.1780822\r\n[3,] 1.1095890\r\n\r\nPodemos também usar o escalonamento de matrizes:\r\n\r\n\r\nAhat_esc <- echelon(A = Ahat, verbose = TRUE)\r\n\r\n\r\n\r\nInitial matrix:\r\n     [,1] [,2] [,3] [,4]\r\n[1,]    6    2    1    7\r\n[2,]    2    4    1    7\r\n[3,]    3    2    8   13\r\n\r\nrow: 1 \r\n\r\n multiply row 1 by 0.1666667 \r\n     [,1]      [,2]      [,3]      [,4]\r\n[1,]    1 0.3333333 0.1666667  1.166667\r\n[2,]    2 4.0000000 1.0000000  7.000000\r\n[3,]    3 2.0000000 8.0000000 13.000000\r\n\r\n multiply row 1 by 2 and subtract from row 2 \r\n     [,1]      [,2]      [,3]      [,4]\r\n[1,]    1 0.3333333 0.1666667  1.166667\r\n[2,]    0 3.3333333 0.6666667  4.666667\r\n[3,]    3 2.0000000 8.0000000 13.000000\r\n\r\n multiply row 1 by 3 and subtract from row 3 \r\n     [,1]      [,2]      [,3]     [,4]\r\n[1,]    1 0.3333333 0.1666667 1.166667\r\n[2,]    0 3.3333333 0.6666667 4.666667\r\n[3,]    0 1.0000000 7.5000000 9.500000\r\n\r\nrow: 2 \r\n\r\n multiply row 2 by 0.3 \r\n     [,1]      [,2]      [,3]     [,4]\r\n[1,]    1 0.3333333 0.1666667 1.166667\r\n[2,]    0 1.0000000 0.2000000 1.400000\r\n[3,]    0 1.0000000 7.5000000 9.500000\r\n\r\n multiply row 2 by 0.3333333 and subtract from row 1 \r\n     [,1] [,2] [,3] [,4]\r\n[1,]    1    0  0.1  0.7\r\n[2,]    0    1  0.2  1.4\r\n[3,]    0    1  7.5  9.5\r\n\r\n subtract row 2 from row 3 \r\n     [,1] [,2] [,3] [,4]\r\n[1,]    1    0  0.1  0.7\r\n[2,]    0    1  0.2  1.4\r\n[3,]    0    0  7.3  8.1\r\n\r\nrow: 3 \r\n\r\n multiply row 3 by 0.1369863 \r\n     [,1] [,2] [,3]     [,4]\r\n[1,]    1    0  0.1 0.700000\r\n[2,]    0    1  0.2 1.400000\r\n[3,]    0    0  1.0 1.109589\r\n\r\n multiply row 3 by 0.1 and subtract from row 1 \r\n     [,1] [,2] [,3]      [,4]\r\n[1,]    1    0  0.0 0.5890411\r\n[2,]    0    1  0.2 1.4000000\r\n[3,]    0    0  1.0 1.1095890\r\n\r\n multiply row 3 by 0.2 and subtract from row 2 \r\n     [,1] [,2] [,3]      [,4]\r\n[1,]    1    0    0 0.5890411\r\n[2,]    0    1    0 1.1780822\r\n[3,]    0    0    1 1.1095890\r\n\r\nAhat_esc\r\n\r\n\r\n     [,1] [,2] [,3]      [,4]\r\n[1,]    1    0    0 0.5890411\r\n[2,]    0    1    0 1.1780822\r\n[3,]    0    0    1 1.1095890\r\n\r\n\r\n\r\n# Coluna das soluções\r\n\r\nround(Ahat_esc[, (n + 1)], 2)\r\n\r\n\r\n[1] 0.59 1.18 1.11\r\n\r\nSistema Indeterminado\r\nO comando solve(A, B) dará erro caso o sistema seja indeterminado. Podemos optar pela solução via métodos numéricos. Para isso, usaremos o pacote limSolve:\r\n\r\n\r\nA <- matrix(data = c(2, 4, 1, 2), ncol = 2)\r\nB <- matrix(data = c(5, 10), ncol = 1)\r\nn <- ncol(A)\r\n\r\nc(R(A), R(B), n)\r\n\r\n\r\n[1] 1 1 2\r\n\r\nComo os postos são iguais, mas menores que \\(\\small n = 2\\), não podemos usar a função solve().\r\nTeorema de Binet\r\n\r\n\r\nA <- matrix(data = runif(100, -2, 2), ncol = 10) \r\nB <- matrix(data = runif(100, -2, 2), ncol = 10) \r\n\r\nA * B\r\n\r\n\r\n             [,1]       [,2]         [,3]       [,4]         [,5]\r\n [1,]  0.39831263  1.7798120  0.092843792 -1.2563811  0.043976992\r\n [2,] -1.53021070 -0.9788685  3.601725096 -1.5358201 -0.462123996\r\n [3,]  0.01848743  1.5531496 -0.237410958  0.3825196 -0.086815112\r\n [4,] -2.19057717 -0.3017758 -0.268826573 -1.8618520  1.150089367\r\n [5,] -0.39750301  1.6456487  0.834745426 -0.4904471  0.695074470\r\n [6,]  0.58798671  0.9529728  0.733224058  1.4249163  2.379604172\r\n [7,] -0.10809096  0.9087442  0.243718451  2.0177178  0.002188265\r\n [8,]  1.88721248  1.9123628  0.238953378 -0.2289470 -1.367161450\r\n [9,] -0.37531843 -2.1389797  1.574300738 -3.0068767 -1.839605990\r\n[10,]  2.21851333 -0.1707133 -0.001016078 -1.9710285 -0.005661734\r\n            [,6]        [,7]       [,8]       [,9]       [,10]\r\n [1,]  0.7991707 -0.32899323  0.3309628 -1.8568167 -0.31681375\r\n [2,]  0.1587375  0.67267357 -0.7255012  0.1107379 -1.47895205\r\n [3,]  1.3990216 -0.04301500  2.4446202 -0.2631944  2.25700613\r\n [4,] -2.1539200  1.06151263 -0.3678820  0.4411630 -0.43073626\r\n [5,]  0.1383386 -0.61626106 -0.1426254  1.2093622  0.06210132\r\n [6,]  0.0191145 -0.03534108  1.1885916  2.2404155 -0.16310513\r\n [7,] -2.3012246  0.10557369 -0.5116712  0.2094723  0.24056896\r\n [8,]  0.3794164  0.12919783 -0.8692364 -1.2313721  2.96512730\r\n [9,]  0.6358050 -2.77817583 -0.7134866  0.9981540  2.21934857\r\n[10,]  2.3554203  2.68917705  0.8253227 -1.4261646  0.09084630\r\n\r\nA %*% B\r\n\r\n\r\n             [,1]       [,2]      [,3]        [,4]       [,5]\r\n [1,] -3.52842225 -0.9133331 -5.320028 -13.3210657  1.3403246\r\n [2,] -6.87658150 -8.6912923 -2.646651   6.9346613 -1.3861076\r\n [3,] -7.51446126 -2.2222545 -7.005367  -1.7961486 -4.5311159\r\n [4,] -0.01434075 -4.0536313  2.326817  -4.9087545  2.8171919\r\n [5,]  2.17858125 -3.3051049 -1.528834   3.3045668 -1.5863339\r\n [6,] -3.90553895 -1.5657043 -3.497143  -4.6598571  0.6603700\r\n [7,]  4.07344891  2.7544587  6.638743  -0.5207372  4.5047730\r\n [8,] -2.94698864  3.9818123 -7.550529   6.2471058 -3.0298718\r\n [9,]  4.30581669 -2.8805128  6.180285  10.7981045 -0.8008744\r\n[10,]  4.15282395 -7.6771348  8.867502   1.3770958  8.3349323\r\n            [,6]       [,7]       [,8]        [,9]      [,10]\r\n [1,]  0.3545271  0.7551179  8.4665937   3.1761579 -6.1654832\r\n [2,]  6.5645010  7.0779181  5.1304388 -13.5394422  0.8717081\r\n [3,]  7.1187340  4.8491998  6.4144212  -8.7451109 -0.1470304\r\n [4,] -5.1939230 -1.3056269  0.1871272   3.4293164  0.4617634\r\n [5,] -0.9206974 -4.8905252  1.0994509  -0.4897312  1.4542101\r\n [6,]  0.9566147 -1.4260500  4.9730991   0.7632391  0.3334091\r\n [7,] -3.9371246  1.9626560 -1.7753653   3.9940700  1.3558968\r\n [8,]  2.1585656  2.4712673 -8.4290507  -5.1708361 -1.3056229\r\n [9,] -2.3797791 -0.8410147 -4.5704480 -10.4570262  5.2900346\r\n[10,] -5.5069507  6.2269903  2.7194325   4.5565011 -0.6117880\r\n\r\nC = A %*% B\r\ndet(C) == det(A %*% B)\r\n\r\n\r\n[1] TRUE\r\n\r\ndet(A + B) == (det(A) + det(B))\r\n\r\n\r\n[1] FALSE\r\n\r\nInversa\r\n\r\n\r\nA <- matrix(data = c(6, 2, 3, 2, 4, 2, 1, 1, 8), ncol = 3)\r\ndet(A)\r\n\r\n\r\n[1] 146\r\n\r\ninv(A)\r\n\r\n\r\n            [,1]        [,2]        [,3]\r\n[1,]  0.20547945 -0.09589041 -0.01369863\r\n[2,] -0.08904110  0.30821918 -0.02739726\r\n[3,] -0.05479452 -0.04109589  0.13698630\r\n\r\nDependencia Linear\r\n\r\n\r\nv1 <- c(1, -1, 0, 0)\r\nv2 <- c(0, 0, 1, 1)\r\nv3 <- c(-2, 2, 1, 1)\r\nv4 <- c(1, 0, 0, 0)\r\n\r\nA <- matrix(data = cbind(v1, v2, v3, v4), ncol = 4)\r\n# Se o determinante de A for 0, os vetores são linearmente dependentes\r\ndet(A)\r\n\r\n\r\n[1] 0\r\n\r\nv5 <- c(2, -3, 2, 2)\r\nAhat <- cbind(A, v5)\r\nAhat\r\n\r\n\r\n               v5\r\n[1,]  1 0 -2 1  2\r\n[2,] -1 0  2 0 -3\r\n[3,]  0 1  1 0  2\r\n[4,]  0 1  1 0  2\r\n\r\n# Como os postos são iguais (p = 3), o sistema é possivel.\r\n# Como o número de variáveis é maior que o posto (n > p), o sistema é indetemrinado.\r\n# Assim, v5 é combinação linear dos outros vetores.\r\nechelon(Ahat)\r\n\r\n\r\n              v5\r\n[1,] 1 0 -2 0  3\r\n[2,] 0 1  1 0  2\r\n[3,] 0 0  0 1 -1\r\n[4,] 0 0  0 0  0\r\n\r\nAutovalores\r\n\r\n\r\neigen(A)\r\n\r\n\r\neigen() decomposition\r\n$values\r\n[1]  2.2469796 -0.8019377  0.5549581  0.0000000\r\n\r\n$vectors\r\n           [,1]       [,2]       [,3]          [,4]\r\n[1,]  0.3913958 -0.2354615 -0.8346812 -8.164966e-01\r\n[2,] -0.6086042  0.7645385  0.1653188  4.082483e-01\r\n[3,] -0.4880626 -0.4242869 -0.3714681 -4.082483e-01\r\n[4,] -0.4880626 -0.4242869 -0.3714681  1.281975e-16\r\n\r\neigen(A)$vectors %>%\r\n  zapsmall(digits = 1)\r\n\r\n\r\n     [,1] [,2] [,3] [,4]\r\n[1,]  0.4 -0.2 -0.8 -0.8\r\n[2,] -0.6  0.8  0.2  0.4\r\n[3,] -0.5 -0.4 -0.4 -0.4\r\n[4,] -0.5 -0.4 -0.4  0.0\r\n\r\neigen(A)$values %>%\r\n  zapsmall(digits = 1)\r\n\r\n\r\n[1]  2.2 -0.8  0.6  0.0\r\n\r\nExercícios sobre estrutura de ontrole\r\nExercício 1\r\nElabore uma função que verifique que uma matriz é quadrada e que seja singular antes de calcular a sua inversa. Não atendendo a uma das condições, a função deverá mostrar uma mensagem alertando o problema. Além de pode usar a estrutura de conotrle if-else, há também uma função chamada ifelse() para processos condicionados curtos.\r\n\r\n\r\nA <- matrix(data = c(1, 5, 0, 0, 4, 2, 0, 0, 2), ncol = 3)\r\nB <- matrix(data = c(1, 5, 0, 0, 4, 2, 0, 0, 0), ncol = 3)\r\nC <- matrix(data = c(1, 5, 0, 0, 4, 2, 0, 0, 2), ncol = 2)\r\ndet(A)\r\n\r\n\r\n[1] 8\r\n\r\ndet(B)\r\n\r\n\r\n[1] 0\r\n\r\ndet(C)\r\n\r\n\r\nError in determinant.matrix(x, logarithm = TRUE, ...): 'x' must be a square matrix\r\n\r\ninversa <- function(A) {\r\n  \r\n  cond1 <- dim(A)[1] == dim(A)[2]\r\n\r\n  if (!cond1) {\r\n    stop(\"Matriz não quadrada\")\r\n  }\r\n  else\r\n    \r\n    cond2 <- det(A) != 0\r\n  \r\n    if (!cond2) {\r\n      stop(\"Matriz singular\")\r\n    }\r\n    else\r\n      matlib::inv(A)\r\n  \r\n}\r\n\r\ninversa(A)\r\n\r\n\r\n      [,1]  [,2] [,3]\r\n[1,]  1.00  0.00  0.0\r\n[2,] -1.25  0.25  0.0\r\n[3,]  1.25 -0.25  0.5\r\n\r\ninversa(B)\r\n\r\n\r\nError in inversa(B): Matriz singular\r\n\r\ninversa(C)\r\n\r\n\r\nError in inversa(C): Matriz não quadrada\r\n\r\nExercício 2\r\nTemos uma lista de n=100 pessoas, cujas notas de desempenho possuem uma média de 500 e um desvio padrão de 20. Com uma nota maior que 500, o candidato é considerado aprovado (“A”) e apto para o emprego, caso contrário, o seu status é de reprovado (“R”). Gere um vetor com as notas e a partir dele, usando a função ifelse(), gere um vetor com o resultado final para cada candidato (“A” ou “R”). O vetor com as notas pode ser produzido com a função rnorm().\r\n\r\n\r\nnotas <- rnorm(n = 100, mean = 500, sd = 20)\r\nnotas\r\n\r\n\r\n  [1] 508.5161 512.4819 462.5406 493.3440 540.5563 489.1314 492.4846\r\n  [8] 513.3362 478.9894 511.3907 533.0762 526.6487 474.3280 498.0020\r\n [15] 543.7234 453.9966 480.2205 505.1516 488.1915 492.3320 492.9752\r\n [22] 476.9968 546.0724 491.3769 477.1136 502.3489 478.4946 475.9336\r\n [29] 526.5553 560.5395 499.4660 472.1483 469.4766 493.2332 497.7766\r\n [36] 453.9527 483.3606 490.2269 491.9194 511.2450 481.5268 534.2467\r\n [43] 524.0561 507.3827 494.7971 506.4502 507.7488 484.8842 520.0724\r\n [50] 496.9047 534.6462 503.7906 521.2470 497.7723 487.4163 477.8998\r\n [57] 515.0203 492.8200 504.3510 495.5463 516.2180 500.0520 480.2098\r\n [64] 467.2513 499.8623 524.7926 506.6221 472.2973 491.8054 515.2148\r\n [71] 489.5778 510.6856 488.8224 518.3622 491.3570 501.7972 503.7050\r\n [78] 493.3520 493.2637 494.4771 523.4170 498.2444 502.8270 501.2262\r\n [85] 526.6827 484.3219 498.0222 505.9754 515.2530 526.0936 514.0274\r\n [92] 526.7409 481.5296 470.6381 516.9061 503.3089 534.7859 499.5337\r\n [99] 457.7609 521.3797\r\n\r\nresultado <- ifelse(test = notas > 500, yes = \"A\", no = \"R\")\r\nresultado\r\n\r\n\r\n  [1] \"A\" \"A\" \"R\" \"R\" \"A\" \"R\" \"R\" \"A\" \"R\" \"A\" \"A\" \"A\" \"R\" \"R\" \"A\" \"R\"\r\n [17] \"R\" \"A\" \"R\" \"R\" \"R\" \"R\" \"A\" \"R\" \"R\" \"A\" \"R\" \"R\" \"A\" \"A\" \"R\" \"R\"\r\n [33] \"R\" \"R\" \"R\" \"R\" \"R\" \"R\" \"R\" \"A\" \"R\" \"A\" \"A\" \"A\" \"R\" \"A\" \"A\" \"R\"\r\n [49] \"A\" \"R\" \"A\" \"A\" \"A\" \"R\" \"R\" \"R\" \"A\" \"R\" \"A\" \"R\" \"A\" \"A\" \"R\" \"R\"\r\n [65] \"R\" \"A\" \"A\" \"R\" \"R\" \"A\" \"R\" \"A\" \"R\" \"A\" \"R\" \"A\" \"A\" \"R\" \"R\" \"R\"\r\n [81] \"A\" \"R\" \"A\" \"A\" \"A\" \"R\" \"R\" \"A\" \"A\" \"A\" \"A\" \"A\" \"R\" \"R\" \"A\" \"A\"\r\n [97] \"A\" \"R\" \"R\" \"A\"\r\n\r\nExercício 3\r\nElabore uma função que calcule o cofator Aij de uma matriz A de ordem n.\r\n\r\n\r\nA <- matrix(data = c(1, 5, 0, 0, 4, 2, 0, 0, 2), ncol = 3)\r\nA\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    1    0    0\r\n[2,]    5    4    0\r\n[3,]    0    2    2\r\n\r\n\r\n\r\nmcof <- function(A) {\r\n  C <- matrix(nrow = dim(A)[1], ncol = dim(A)[2])\r\n  \r\n  for (i in 1:dim(A)[1]) {\r\n    for (j in 1:dim(A)[2]) {\r\n      B <- A[-i, -j]\r\n      C[i, j] <- det(B)*(-1)^outer(X = i, Y = j, FUN = \"+\")\r\n    }\r\n  }\r\n  return(C)\r\n}\r\nmcof(A)\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    8  -10   10\r\n[2,]    0    2   -2\r\n[3,]    0    0    4\r\n\r\n\r\n\r\nmcof <- function(A) {\r\n  C <- matrix(nrow = dim(A)[1], ncol = dim(A)[2])\r\n  \r\n  for (i in 1:dim(A)[1]) {\r\n    for (j in 1:dim(A)[2]) {\r\n      B <- A[-i, -j]\r\n      C[i, j] <- det(B)*(-1)^(i + j)\r\n    }\r\n  }\r\n  return(C)\r\n\r\n}\r\nmcof(A)\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    8  -10   10\r\n[2,]    0    2   -2\r\n[3,]    0    0    4\r\n\r\n\r\n\r\nmcof2 <- function(A) {\r\n  C <- matrix(nrow = dim(A)[1], ncol = dim(A)[2])\r\n  \r\n  for (i in 1:dim(A)[1]) {\r\n    for (j in 1:dim(A)[2]) {\r\n      C[i, j] <- cofactor(A, i, j)\r\n    }\r\n  }\r\n  return(C)\r\n}\r\nmcof2(A)\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    8  -10   10\r\n[2,]    0    2   -2\r\n[3,]    0    0    4\r\n\r\nExercícios Semana 3\r\nExercício 4\r\n\r\n\r\nA <- matrix(data = c(1, 5, 0, 0, 4, 2, 0, 0, 2), ncol = 3)\r\nA\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    1    0    0\r\n[2,]    5    4    0\r\n[3,]    0    2    2\r\n\r\nCalcule o determinante de A:\r\n\r\n\r\ndet(A)\r\n\r\n\r\n[1] 8\r\n\r\nObtenha a diagonal de A e calcule o produto dos seus elementos, usando a função prod().\r\n\r\n\r\ndiag(A)\r\n\r\n\r\n[1] 1 4 2\r\n\r\nprod(diag(A))\r\n\r\n\r\n[1] 8\r\n\r\nCompare os resultados de A) e B)\r\n\r\n\r\nc(det(A), prod(diag(A)))\r\n\r\n\r\n[1] 8 8\r\n\r\nPodemos afirmar que A é inversível?\r\n\r\nSim. Pois \\(det(A) \\ne 0\\)\r\n\r\n\r\ninv(A)\r\n\r\n\r\n      [,1]  [,2] [,3]\r\n[1,]  1.00  0.00  0.0\r\n[2,] -1.25  0.25  0.0\r\n[3,]  1.25 -0.25  0.5\r\n\r\nExercício 5\r\nGere duas matrizes de ordem n = 10, com valores inteiros aleatorios de distribuição uniforme no intervalo [−10, 10]. Verifique o teorema de Binet (a falsidade da propriedade distributiva da soma para o determinante de matrizes).\r\n\r\n\r\nA <- matrix(data = runif(n = 100, min = -10, max = 10), ncol = 10)\r\nB <- matrix(data = runif(n = 100, min = -10, max = 10), ncol = 10)\r\n\r\ndet(A)\r\n\r\n\r\n[1] 9404234994\r\n\r\ndet(B)\r\n\r\n\r\n[1] 12540850890\r\n\r\ndet(A + B)\r\n\r\n\r\n[1] 250703837462\r\n\r\ndet(A + B) == (det(A) + det(B))\r\n\r\n\r\n[1] FALSE\r\n\r\nExercício 6\r\nDetermine os autovalores e autovetores das matrizes a seguir:\r\n\r\n\r\n\r\nA <- matrix(data = c(3, 0, 0, -3, 3, 0, -4, 5, -1), ncol = 3)\r\nA\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    3   -3   -4\r\n[2,]    0    3    5\r\n[3,]    0    0   -1\r\n\r\neigen(A)\r\n\r\n\r\neigen() decomposition\r\n$values\r\n[1]  3  3 -1\r\n\r\n$vectors\r\n     [,1]         [,2]        [,3]\r\n[1,]    1 1.000000e+00  0.03901372\r\n[2,]    0 2.220446e-16 -0.78027431\r\n[3,]    0 0.000000e+00  0.62421945\r\n\r\ncbind(eigen(A)$values, diag(A))\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    3    3\r\n[2,]    3    3\r\n[3,]   -1   -1\r\n\r\nCompare os autovalores obtidos com a diagonal principal da matriz triangular superior. Por que acontece o observado?\r\nR: Porque a matriz é triangular, portanto o produto da diagonal princial é o único termo do determinante que não se anula.\r\n\r\n\r\n\r\nA <- matrix(data = c(-1, 2, 2, -4, -7, -4, 14, 14, 11), ncol = 3)\r\nA\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]   -1   -4   14\r\n[2,]    2   -7   14\r\n[3,]    2   -4   11\r\n\r\neigen(A)\r\n\r\n\r\neigen() decomposition\r\n$values\r\n[1]  9 -3 -3\r\n\r\n$vectors\r\n          [,1]       [,2]        [,3]\r\n[1,] 0.5773503 -0.9622504  0.09350413\r\n[2,] 0.5773503  0.1924501 -0.95370329\r\n[3,] 0.5773503  0.1924501 -0.28584439\r\n\r\ncbind(eigen(A)$values, diag(A))\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    9   -1\r\n[2,]   -3   -7\r\n[3,]   -3   11\r\n\r\nC )\r\n\r\n\r\nA <- matrix(data = c(1, -1, 1, 0, 0, 1, 2, 1, 2), ncol = 3)\r\nA\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    1    0    2\r\n[2,]   -1    0    1\r\n[3,]    1    1    2\r\n\r\neigen(A)\r\n\r\n\r\neigen() decomposition\r\n$values\r\n[1]  3 -1  1\r\n\r\n$vectors\r\n             [,1]       [,2]          [,3]\r\n[1,] 7.071068e-01  0.4082483  7.071068e-01\r\n[2,] 2.840404e-16  0.8164966 -7.071068e-01\r\n[3,] 7.071068e-01 -0.4082483 -1.727306e-16\r\n\r\ncbind(eigen(A)$values, diag(A))\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    3    1\r\n[2,]   -1    0\r\n[3,]    1    2\r\n\r\n\r\n\r\n\r\nA <- matrix(data = c(3, 0, 0, -3, 3, 0, -4, 5, -1), ncol = 3)\r\nB <- matrix(data = c(-1, 2, 2, -4, -7, -4, 14, 14, 11), ncol = 3)\r\nC <- matrix(data = c(1, -1, 1, 0, 0, 1, 2, 1, 2), ncol = 3)\r\n\r\navecA <- eigen(A)$vector\r\navecB <- eigen(B)$vector\r\navecC <- eigen(C)$vector\r\n\r\navecA\r\n\r\n\r\n     [,1]         [,2]        [,3]\r\n[1,]    1 1.000000e+00  0.03901372\r\n[2,]    0 2.220446e-16 -0.78027431\r\n[3,]    0 0.000000e+00  0.62421945\r\n\r\ndet(avecA)\r\n\r\n\r\n[1] 1.386046e-16\r\n\r\navecB\r\n\r\n\r\n          [,1]       [,2]        [,3]\r\n[1,] 0.5773503 -0.9622504  0.09350413\r\n[2,] 0.5773503  0.1924501 -0.95370329\r\n[3,] 0.5773503  0.1924501 -0.28584439\r\n\r\ndet(avecB)\r\n\r\n\r\n[1] 0.4452393\r\n\r\navecC\r\n\r\n\r\n             [,1]       [,2]          [,3]\r\n[1,] 7.071068e-01  0.4082483  7.071068e-01\r\n[2,] 2.840404e-16  0.8164966 -7.071068e-01\r\n[3,] 7.071068e-01 -0.4082483 -1.727306e-16\r\n\r\ndet(avecC)\r\n\r\n\r\n[1] -0.8164966\r\n\r\nOs determinantes são diferentes de 0, portanto os autovetores são linearmente independentes.\r\n\r\n\r\n\r\n",
      "last_modified": "2021-04-19T17:27:38-03:00"
    },
    {
      "path": "eqdiff.html",
      "title": "Equações em Diferença",
      "description": "Essa aula estuda Equações em Diferença.\n",
      "author": [
        {
          "name": "Rafael Peixoto",
          "url": {}
        }
      ],
      "date": "04-19-2021",
      "contents": "\r\n\r\nContents\r\nEquações Homogêneas\r\n\r\n\r\n\r\nd-article p {\r\n  text-align: justify;\r\n  font-size: 16px;\r\n}\r\n\r\nd-article p code {\r\n  background: rgba(236, 236, 236, 0.8);\r\n}\r\n\r\nd-article div.sourceCode {\r\n  overflow: auto !important;\r\n}\r\n\r\nEquações Homogêneas\r\n\r\n\r\n\r\n",
      "last_modified": "2021-04-19T17:27:39-03:00"
    },
    {
      "path": "index.html",
      "title": "Economia Matemática",
      "author": [
        {
          "name": "Rafael Peixoto",
          "url": {}
        }
      ],
      "date": "03-26-2021",
      "contents": "\r\n\r\n\r\nd-article p {\r\n  text-align: center;\r\n  font-size: 26px;\r\n}\r\n\r\nd-article p code {\r\n  background: rgba(236, 236, 236, 0.8);\r\n}\r\n\r\nd-article div.sourceCode {\r\n  overflow: auto !important;\r\n}\r\n\r\n\r\nEsse site acompanha as aulas da disciplina Economia Matemática (HO-012).\r\n\r\n\r\n\r\n",
      "last_modified": "2021-04-19T17:27:41-03:00"
    }
  ],
  "collections": []
}
