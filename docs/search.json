{
  "articles": [
    {
      "path": "about.html",
      "title": "Algebra Linear",
      "description": "Essa aula estuda vetores, matrizes e sistemas lineares.\n",
      "author": [
        {
          "name": "Rafael Peixoto",
          "url": {}
        }
      ],
      "date": "03-26-2021",
      "contents": "\r\n\r\nContents\r\nVetores\r\nOperações com Vetores\r\nOutras funções\r\n\r\nMatrizes\r\nMatrizes especiais\r\nOperações com Matrizes\r\nAcesso aos Valores\r\n\r\nSistemas Lineares\r\nVisualização de sistemas simples\r\nSistemas de duas variáveis\r\nSistemas de três variáveis\r\nEscalonamento de matrizes (Gauss-Jordan)\r\nPosto de uma matriz\r\n\r\nResolução Numérica de Sistemas\r\nSistema Determinado\r\nSistema Indeterminado\r\nTeorema de Binet\r\nInversa\r\nDependencia Linear\r\nAutovalores\r\n\r\nExercícios sobre estrutura de ontrole\r\nExercícios Semana 3\r\n\r\n\r\n\r\nd-article p {\r\n  text-align: justify;\r\n  font-size: 16px;\r\n}\r\n\r\nd-article p code {\r\n  background: rgba(236, 236, 236, 0.8);\r\n}\r\n\r\nd-article div.sourceCode {\r\n  overflow: auto !important;\r\n}\r\n\r\nVetores\r\nA função c() cria vetores no R\r\nOperações com Vetores\r\n\r\n\r\n# Soma\r\n\r\nv1 <- c(5, 8, 9, 6.25, 7, 7)\r\nv2 <- c(7, 5, 10, 3, 3, 4)\r\n\r\nsoma_vetores <- v1 + v2\r\nsoma_vetores\r\n\r\n\r\n[1] 12.00 13.00 19.00  9.25 10.00 11.00\r\n\r\n\r\n\r\n# Tamanho do vetor\r\n\r\nlength(soma_vetores)\r\n\r\n\r\n[1] 6\r\n\r\n\r\n\r\n# Produto por escalar\r\n\r\nvetor1 <- soma_vetores * 0.5\r\nvetor2 <- soma_vetores * runif(n = 1, min = 0, max = 1)\r\n\r\n\r\n\r\n\r\n\r\nvetor1\r\n\r\n\r\n[1] 6.000 6.500 9.500 4.625 5.000 5.500\r\n\r\nvetor2\r\n\r\n\r\n[1] 10.550049 11.429220 16.704245  8.132330  8.791708  9.670879\r\n\r\n\r\n\r\n# Produto Escalar\r\n\r\nprod_esca <- sum(v1 * v2)\r\nprod_esca\r\n\r\n\r\n[1] 232.75\r\n\r\n\r\n\r\n# Norma\r\n\r\nnorma_v1 <- sqrt(x = sum(v1 * v2))\r\nnorma_v1\r\n\r\n\r\n[1] 15.25615\r\n\r\nOutras funções\r\n\r\n\r\n# Sequência\r\n\r\nseq(from = 1, to = 10, by = 2)\r\n\r\n\r\n[1] 1 3 5 7 9\r\n\r\n\r\n\r\n# Repetição\r\n\r\nrep(x = c(1,3), 10)\r\n\r\n\r\n [1] 1 3 1 3 1 3 1 3 1 3 1 3 1 3 1 3 1 3 1 3\r\n\r\n\r\n\r\n# Ordenação\r\n\r\nv = c(2, 8, 3, 1, 9)\r\nsort(x = v, decreasing = FALSE)\r\n\r\n\r\n[1] 1 2 3 8 9\r\n\r\nMatrizes\r\nA função matrix() cria matrizes no R\r\n\r\n\r\n# Criando uma Matriz\r\n\r\nelementos <- seq(from = 1, to = 6, by = 1)\r\nA <- matrix(data = elementos, nrow = 2)\r\nA\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    1    3    5\r\n[2,]    2    4    6\r\n\r\n\r\n\r\n# Criando a mesma Matriz\r\n\r\nA <- matrix(data = 1:6, ncol = 3)\r\nA\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    1    3    5\r\n[2,]    2    4    6\r\n\r\n\r\n\r\n# Dimensões de uma Matriz\r\n\r\ndim(x = A)\r\n\r\n\r\n[1] 2 3\r\n\r\nnrow(x = A)\r\n\r\n\r\n[1] 2\r\n\r\nncol(x = A)\r\n\r\n\r\n[1] 3\r\n\r\nMatrizes especiais\r\n\r\n\r\n# Matriz nula\r\n\r\nmatrix(data = 0, nrow = 2, ncol = 2)\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    0    0\r\n[2,]    0    0\r\n\r\n\r\n\r\n# Matriz unitária\r\n\r\nmatrix(data = 1, nrow = 2, ncol = 2)\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    1    1\r\n[2,]    1    1\r\n\r\n\r\n\r\n# Matriz diagonal\r\n\r\ndiag(x = 1:5)\r\n\r\n\r\n     [,1] [,2] [,3] [,4] [,5]\r\n[1,]    1    0    0    0    0\r\n[2,]    0    2    0    0    0\r\n[3,]    0    0    3    0    0\r\n[4,]    0    0    0    4    0\r\n[5,]    0    0    0    0    5\r\n\r\n\r\n\r\n# Matriz identidade\r\n\r\ndiag(x = 1, nrow = 4)\r\n\r\n\r\n     [,1] [,2] [,3] [,4]\r\n[1,]    1    0    0    0\r\n[2,]    0    1    0    0\r\n[3,]    0    0    1    0\r\n[4,]    0    0    0    1\r\n\r\n\r\n\r\n# Obter a diagonal de uma matriz\r\n\r\nA <- matrix(data = 1:9, nrow = 3)\r\nA\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    1    4    7\r\n[2,]    2    5    8\r\n[3,]    3    6    9\r\n\r\ndiag(x = A)\r\n\r\n\r\n[1] 1 5 9\r\n\r\nOperações com Matrizes\r\n\r\n\r\nA <- matrix(data = c(1, 3, 2, 2, 8, 9), ncol = 2)\r\nA\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    1    2\r\n[2,]    3    8\r\n[3,]    2    9\r\n\r\nB <- matrix(data = 1:6, ncol = 2)\r\nB\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    1    4\r\n[2,]    2    5\r\n[3,]    3    6\r\n\r\nC <- matrix(data = c(5, 8, 4, 2), ncol = 2)\r\nC\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    5    4\r\n[2,]    8    2\r\n\r\n\r\n\r\n# Soma de Matrizes\r\n\r\nA + B\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    2    6\r\n[2,]    5   13\r\n[3,]    5   15\r\n\r\n\r\n\r\n# Subtração de Matrizes\r\n\r\nA - B\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    0   -2\r\n[2,]    1    3\r\n[3,]   -1    3\r\n\r\n\r\n\r\n# Produto por um escalar\r\n\r\nA * 3\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    3    6\r\n[2,]    9   24\r\n[3,]    6   27\r\n\r\n\r\n\r\n# Transposta de uma Matriz\r\n\r\nt(A)\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    1    3    2\r\n[2,]    2    8    9\r\n\r\nAcesso aos Valores\r\nPrecisamos de dois indicadores [linha, coluna]\r\n\r\n\r\n# Elemento da linha 1 e coluna 2\r\n\r\nA[1, 2]\r\n\r\n\r\n[1] 2\r\n\r\n\r\n\r\n# Todos os elementos da coluna 2\r\n\r\nA[, 2]\r\n\r\n\r\n[1] 2 8 9\r\n\r\n\r\n\r\n# Todos os elementos da linha 3\r\n\r\nA[3, ]\r\n\r\n\r\n[1] 2 9\r\n\r\n\r\n\r\n# Eliminar coluna 3\r\n\r\nA[, -3]\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    1    2\r\n[2,]    3    8\r\n[3,]    2    9\r\n\r\nSistemas Lineares\r\nPacotes para tratamento de matrizes e sistemas lineares:\r\nmatrixcale\r\nMatrix\r\nlimSolve\r\nmatlib\r\nVisualização de sistemas simples\r\nSeja o sistema:\r\n\\[\r\n\\begin{aligned}\r\n  \\begin{cases}\r\n      2x + y = 5 \\\\\r\n      x - 1y = 6\r\n  \\end{cases}\r\n\\end{aligned}\r\n\\]\r\nMatricialmente:\r\n\\[\r\n\\begin{aligned}\r\n  A = \r\n  \\begin{bmatrix}\r\n    2 & 1 \\\\\r\n    1 & -1\r\n  \\end{bmatrix}\r\n  \\qquad \r\n  B = \r\n  \\begin{bmatrix}\r\n    5 \\\\\r\n    6\r\n  \\end{bmatrix}\r\n\\end{aligned}\r\n\\] No R usaremos o pacote matlib.\r\n\r\n\r\nA <- matrix(data = c(2, 1, 1, -1), ncol = 2)\r\nB <- matrix(data = c(5, 6), ncol = 1)\r\n\r\n\r\n\r\n\r\n\r\nA\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    2    1\r\n[2,]    1   -1\r\n\r\nB\r\n\r\n\r\n     [,1]\r\n[1,]    5\r\n[2,]    6\r\n\r\nA função showEqn() nos permite visualizar as equações lineares correspondentes, a partir das matrizes \\(\\small A\\) e \\(\\small B\\); e a função plotEqn() permite a visualização das equações lineares de sistemas bivariados.\r\nSistemas de duas variáveis\r\nExemnplo 1\r\n\r\n\r\n# Visualizar as equações\r\n\r\nshowEqn(A = A, b = B)\r\n\r\n\r\n2*x1 + 1*x2  =  5 \r\n1*x1 - 1*x2  =  6 \r\n\r\n\r\n\r\n# Plotar as equações\r\n\r\nplotEqn(A = A, b = B, lwd = 1)\r\n\r\n\r\n2*x[1]   + x[2]  =  5 \r\n  x[1] - 1*x[2]  =  6 \r\n\r\n\r\nComo se observa, pela interseção das duas retas, se entende que o sistema possui uma única solução. Ou seja, é um sistema possível e determinado.\r\nExemplo 2\r\nNo caso de três equações de um sistema determinado bivariado (ainda no \\(\\mathbb{R}^ 2\\)):\r\n\r\n\r\nA <- matrix(data = c(1:3, -1, 2, 1), ncol = 2)\r\nB <- matrix(data = c(2, 1, 3), ncol = 1)\r\n\r\nshowEqn(A = A, b = B)\r\n\r\n\r\n1*x1 - 1*x2  =  2 \r\n2*x1 + 2*x2  =  1 \r\n3*x1 + 1*x2  =  3 \r\n\r\nplotEqn(A = A, b = B, lwd = 1)\r\n\r\n\r\n  x[1] - 1*x[2]  =  2 \r\n2*x[1] + 2*x[2]  =  1 \r\n3*x[1]   + x[2]  =  3 \r\n\r\n\r\nSe para definir um ponto no espaço bidimensional precisamos de apenas duas retas, o que uma terceira reta representaria no sistema? Veja que uma das equações pode ser reescrita a partir das outras duas!\r\nExemplo 3\r\nAinda no \\(\\mathbb{R}^2\\), quando temos um sistema indeterminado, a geometria resultante muda pois o sistema possui infinitas soluções:\r\n\r\n\r\nA <- matrix(data = c(2, 4, 1, 2), ncol = 2)\r\nB <- matrix(data = c(5, 10), ncol = 1)\r\n\r\nshowEqn(A = A, b = B)\r\n\r\n\r\n2*x1 + 1*x2  =   5 \r\n4*x1 + 2*x2  =  10 \r\n\r\nplotEqn(A = A, b = B, lwd = 1)\r\n\r\n\r\n2*x[1]   + x[2]  =   5 \r\n4*x[1] + 2*x[2]  =  10 \r\n\r\n\r\nExemplo 4\r\nE quando o sistema é impossível/inconsistente, geometricamente não veremos nenhum caso de interseção entre as retas:\r\n\r\n\r\nA <- matrix(data = c(1,2,3, -1, 2, 1), ncol = 2)\r\nB <-matrix(data = c(2,1,6), ncol = 1)\r\n\r\nshowEqn(A = A, b = B)\r\n\r\n\r\n1*x1 - 1*x2  =  2 \r\n2*x1 + 2*x2  =  1 \r\n3*x1 + 1*x2  =  6 \r\n\r\nplotEqn(A = A, b = B, lwd = 1)\r\n\r\n\r\n  x[1] - 1*x[2]  =  2 \r\n2*x[1] + 2*x[2]  =  1 \r\n3*x[1]   + x[2]  =  6 \r\n\r\n\r\nSistemas de três variáveis\r\nNo \\(\\mathbb{R}^3\\), podemos seguir usando a função showEqn() para verificar as equações equivalentes do sistema, mas para fins de visualização gráfica, usamos a função plotEqn3d().\r\nSistema Determinado\r\n\r\n\r\nA <- matrix(data = c(6, 2, 3, 2, 4, 2, 1, 1, 8), ncol = 3)\r\nB <- matrix(data = c(7, 7, 13), ncol = 1)\r\n\r\nshowEqn(A = A, b = B)\r\n\r\n\r\n6*x1 + 2*x2 + 1*x3  =   7 \r\n2*x1 + 4*x2 + 1*x3  =   7 \r\n3*x1 + 2*x2 + 8*x3  =  13 \r\n\r\n\r\n\r\nplotEqn3d(A = A, b = B)\r\n\r\n\r\n\r\nComo observamos, as equações agora representam planos no espaço tridimensional, e havendo uma única solução do sistema, teremos geométrica mente a solução representada pelo ponto de interseção dos três planos (das três equações).\r\nSistema Inconsistente\r\nNo caso de um sistema inconsistente, não haverá interseção entre os três planos:\r\n\r\n\r\nA <- matrix(data = c(1, 3, 1,\r\n                     1, -2, -2,\r\n                     2, 1, -1), ncol = 3, byrow = TRUE)\r\nB <- matrix(data = c(2, 3, 6), ncol = 1)\r\n\r\nshowEqn(A = A, b = B)\r\n\r\n\r\n1*x1 + 3*x2 + 1*x3  =  2 \r\n1*x1 - 2*x2 - 2*x3  =  3 \r\n2*x1 + 1*x2 - 1*x3  =  6 \r\n\r\n\r\n\r\nplotEqn3d(A = A, b = B)\r\n\r\n\r\n\r\nEscalonamento de matrizes (Gauss-Jordan)\r\n\r\n\r\nA <- matrix(data = c(6, 2, 3, 2, 4, 2, 1, 1, 8), ncol = 3)\r\nA\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    6    2    1\r\n[2,]    2    4    1\r\n[3,]    3    2    8\r\n\r\n\r\n\r\n# Escalonamento\r\n\r\nechelon(A = A, verbose = TRUE, fractions = TRUE)\r\n\r\n\r\n\r\nInitial matrix:\r\n     [,1] [,2] [,3]\r\n[1,] 6    2    1   \r\n[2,] 2    4    1   \r\n[3,] 3    2    8   \r\n\r\nrow: 1 \r\n\r\n multiply row 1 by 1/6 \r\n     [,1] [,2] [,3]\r\n[1,]   1  1/3  1/6 \r\n[2,]   2    4    1 \r\n[3,]   3    2    8 \r\n\r\n multiply row 1 by 2 and subtract from row 2 \r\n     [,1] [,2] [,3]\r\n[1,]    1  1/3  1/6\r\n[2,]    0 10/3  2/3\r\n[3,]    3    2    8\r\n\r\n multiply row 1 by 3 and subtract from row 3 \r\n     [,1] [,2] [,3]\r\n[1,]    1  1/3  1/6\r\n[2,]    0 10/3  2/3\r\n[3,]    0    1 15/2\r\n\r\nrow: 2 \r\n\r\n multiply row 2 by 3/10 \r\n     [,1] [,2] [,3]\r\n[1,]    1  1/3  1/6\r\n[2,]    0    1  1/5\r\n[3,]    0    1 15/2\r\n\r\n multiply row 2 by 1/3 and subtract from row 1 \r\n     [,1] [,2] [,3]\r\n[1,]    1    0 1/10\r\n[2,]    0    1  1/5\r\n[3,]    0    1 15/2\r\n\r\n subtract row 2 from row 3 \r\n     [,1]  [,2]  [,3] \r\n[1,]     1     0  1/10\r\n[2,]     0     1   1/5\r\n[3,]     0     0 73/10\r\n\r\nrow: 3 \r\n\r\n multiply row 3 by 10/73 \r\n     [,1] [,2] [,3]\r\n[1,]    1    0 1/10\r\n[2,]    0    1  1/5\r\n[3,]    0    0    1\r\n\r\n multiply row 3 by 1/10 and subtract from row 1 \r\n     [,1] [,2] [,3]\r\n[1,]   1    0    0 \r\n[2,]   0    1  1/5 \r\n[3,]   0    0    1 \r\n\r\n multiply row 3 by 1/5 and subtract from row 2 \r\n     [,1] [,2] [,3]\r\n[1,] 1    0    0   \r\n[2,] 0    1    0   \r\n[3,] 0    0    1   \r\n\r\nPara criar a matriz ampliada precisamos juntar a matriz de coeficientes e a matriz de termos independentes:\r\n\r\n\r\nB <- matrix(data = c(7, 7, 13), ncol = 1)\r\nB\r\n\r\n\r\n     [,1]\r\n[1,]    7\r\n[2,]    7\r\n[3,]   13\r\n\r\n\r\n\r\nA <- matrix(data = c(6, 6, 3, 2, 4, 1, 1, 1, 0.5), ncol = 3)\r\nB <- matrix(data = c(7, 2, 13), ncol = 1)\r\nechelon(A = A, B = B, verbose = TRUE, fractions = TRUE)\r\n\r\n\r\n\r\nInitial matrix:\r\n     [,1] [,2] [,3] [,4]\r\n[1,]   6    2    1    7 \r\n[2,]   6    4    1    2 \r\n[3,]   3    1  1/2   13 \r\n\r\nrow: 1 \r\n\r\n multiply row 1 by 1/6 \r\n     [,1] [,2] [,3] [,4]\r\n[1,]   1  1/3  1/6  7/6 \r\n[2,]   6    4    1    2 \r\n[3,]   3    1  1/2   13 \r\n\r\n multiply row 1 by 6 and subtract from row 2 \r\n     [,1] [,2] [,3] [,4]\r\n[1,]   1  1/3  1/6  7/6 \r\n[2,]   0    2    0   -5 \r\n[3,]   3    1  1/2   13 \r\n\r\n multiply row 1 by 3 and subtract from row 3 \r\n     [,1] [,2] [,3] [,4]\r\n[1,]    1  1/3  1/6  7/6\r\n[2,]    0    2    0   -5\r\n[3,]    0    0    0 19/2\r\n\r\nrow: 2 \r\n\r\n multiply row 2 by 1/2 \r\n     [,1] [,2] [,3] [,4]\r\n[1,]    1  1/3  1/6  7/6\r\n[2,]    0    1    0 -5/2\r\n[3,]    0    0    0 19/2\r\n\r\n multiply row 2 by 1/3 and subtract from row 1 \r\n     [,1] [,2] [,3] [,4]\r\n[1,]    1    0  1/6    2\r\n[2,]    0    1    0 -5/2\r\n[3,]    0    0    0 19/2\r\n\r\nrow: 3 \r\n\r\n\r\n\r\n# Juntando as matrizes\r\n\r\nAhat <- cbind(A, B)\r\nAhat\r\n\r\n\r\n     [,1] [,2] [,3] [,4]\r\n[1,]    6    2  1.0    7\r\n[2,]    6    4  1.0    2\r\n[3,]    3    1  0.5   13\r\n\r\nPosto de uma matriz\r\nA função R() do pacote matlib nos permite avaliar o posto de uma matriz:\r\n\r\n\r\n# Se os postos são iguais, o sistema terá solução\r\n\r\nposto_A <- R(A)\r\nposto_Ahat <- R(Ahat)\r\n\r\nc(posto_A, posto_Ahat)\r\n\r\n\r\n[1] 2 3\r\n\r\nResolução Numérica de Sistemas\r\nSistema Determinado\r\nPara o sistema determinado, temos que\r\n\\[\r\np_A = p_{\\hat{A}} = n\r\n\\]\r\nonde \\(\\small n\\) é o número de variáveis do sistema.\r\n\r\n\r\nA <- matrix(data = c(6, 2, 3, 2, 4, 2, 1, 1, 8), ncol = 3)\r\nB <- matrix(data = c(7, 7, 13), ncol = 1)\r\nn <- ncol(A)\r\n\r\nAhat <- cbind(A, B)\r\n\r\nposto_A <- R(A)\r\nposto_Ahat <- R(Ahat)\r\n\r\ncondicao1 <- posto_A == posto_Ahat\r\ncondicao2 <- posto_A == n \r\n\r\n\r\n\r\n\r\n\r\ncondicao1\r\n\r\n\r\n[1] TRUE\r\n\r\ncondicao2\r\n\r\n\r\n[1] TRUE\r\n\r\nAtendendo aos requisitos, podemos usar a função solve() sobre a matriz ampliada para obter a solução do sistema:\r\n\r\n\r\n# Sistema Determinado\r\n\r\nif (condicao1 & condicao2) {\r\n  X <- solve(A, B)\r\n  X\r\n}\r\n\r\n\r\n          [,1]\r\n[1,] 0.5890411\r\n[2,] 1.1780822\r\n[3,] 1.1095890\r\n\r\nPodemos também usar o escalonamento de matrizes:\r\n\r\n\r\nAhat_esc <- echelon(A = Ahat, verbose = TRUE)\r\n\r\n\r\n\r\nInitial matrix:\r\n     [,1] [,2] [,3] [,4]\r\n[1,]    6    2    1    7\r\n[2,]    2    4    1    7\r\n[3,]    3    2    8   13\r\n\r\nrow: 1 \r\n\r\n multiply row 1 by 0.1666667 \r\n     [,1]      [,2]      [,3]      [,4]\r\n[1,]    1 0.3333333 0.1666667  1.166667\r\n[2,]    2 4.0000000 1.0000000  7.000000\r\n[3,]    3 2.0000000 8.0000000 13.000000\r\n\r\n multiply row 1 by 2 and subtract from row 2 \r\n     [,1]      [,2]      [,3]      [,4]\r\n[1,]    1 0.3333333 0.1666667  1.166667\r\n[2,]    0 3.3333333 0.6666667  4.666667\r\n[3,]    3 2.0000000 8.0000000 13.000000\r\n\r\n multiply row 1 by 3 and subtract from row 3 \r\n     [,1]      [,2]      [,3]     [,4]\r\n[1,]    1 0.3333333 0.1666667 1.166667\r\n[2,]    0 3.3333333 0.6666667 4.666667\r\n[3,]    0 1.0000000 7.5000000 9.500000\r\n\r\nrow: 2 \r\n\r\n multiply row 2 by 0.3 \r\n     [,1]      [,2]      [,3]     [,4]\r\n[1,]    1 0.3333333 0.1666667 1.166667\r\n[2,]    0 1.0000000 0.2000000 1.400000\r\n[3,]    0 1.0000000 7.5000000 9.500000\r\n\r\n multiply row 2 by 0.3333333 and subtract from row 1 \r\n     [,1] [,2] [,3] [,4]\r\n[1,]    1    0  0.1  0.7\r\n[2,]    0    1  0.2  1.4\r\n[3,]    0    1  7.5  9.5\r\n\r\n subtract row 2 from row 3 \r\n     [,1] [,2] [,3] [,4]\r\n[1,]    1    0  0.1  0.7\r\n[2,]    0    1  0.2  1.4\r\n[3,]    0    0  7.3  8.1\r\n\r\nrow: 3 \r\n\r\n multiply row 3 by 0.1369863 \r\n     [,1] [,2] [,3]     [,4]\r\n[1,]    1    0  0.1 0.700000\r\n[2,]    0    1  0.2 1.400000\r\n[3,]    0    0  1.0 1.109589\r\n\r\n multiply row 3 by 0.1 and subtract from row 1 \r\n     [,1] [,2] [,3]      [,4]\r\n[1,]    1    0  0.0 0.5890411\r\n[2,]    0    1  0.2 1.4000000\r\n[3,]    0    0  1.0 1.1095890\r\n\r\n multiply row 3 by 0.2 and subtract from row 2 \r\n     [,1] [,2] [,3]      [,4]\r\n[1,]    1    0    0 0.5890411\r\n[2,]    0    1    0 1.1780822\r\n[3,]    0    0    1 1.1095890\r\n\r\nAhat_esc\r\n\r\n\r\n     [,1] [,2] [,3]      [,4]\r\n[1,]    1    0    0 0.5890411\r\n[2,]    0    1    0 1.1780822\r\n[3,]    0    0    1 1.1095890\r\n\r\n\r\n\r\n# Coluna das soluções\r\n\r\nround(Ahat_esc[, (n + 1)], 2)\r\n\r\n\r\n[1] 0.59 1.18 1.11\r\n\r\nSistema Indeterminado\r\nO comando solve(A, B) dará erro caso o sistema seja indeterminado. Podemos optar pela solução via métodos numéricos. Para isso, usaremos o pacote limSolve:\r\n\r\n\r\nA <- matrix(data = c(2, 4, 1, 2), ncol = 2)\r\nB <- matrix(data = c(5, 10), ncol = 1)\r\nn <- ncol(A)\r\n\r\nc(R(A), R(B), n)\r\n\r\n\r\n[1] 1 1 2\r\n\r\nComo os postos são iguais, mas menores que \\(\\small n = 2\\), não podemos usar a função solve().\r\nTeorema de Binet\r\n\r\n\r\nA <- matrix(data = runif(100, -2, 2), ncol = 10) \r\nB <- matrix(data = runif(100, -2, 2), ncol = 10) \r\n\r\nA * B\r\n\r\n\r\n             [,1]         [,2]       [,3]        [,4]       [,5]\r\n [1,]  1.97685095  2.637793067 -0.1709097  0.77949438 -0.1697666\r\n [2,] -0.27957421  0.163442634  2.3056332  0.39816074  0.8622028\r\n [3,]  2.32782828 -0.001585787 -0.7693069 -1.48674814  1.4287202\r\n [4,]  0.01319151 -0.924124477  0.8347153 -0.05427304 -0.3990050\r\n [5,] -2.58068636 -3.156491718  1.8824704  0.39304926  0.9149455\r\n [6,] -0.06542615  1.136464062  1.2023916 -2.39086291 -0.4302586\r\n [7,] -0.41334401 -0.140952416 -0.1938012 -0.14818355 -0.1502110\r\n [8,]  2.59133145  1.129510073 -1.1600341 -2.03264067  0.5551561\r\n [9,] -0.19974760 -2.491981271  1.3681220 -1.81997923  1.0540119\r\n[10,] -1.68804556  0.142704016  0.1503112  2.59047668  1.9495745\r\n             [,6]        [,7]        [,8]        [,9]       [,10]\r\n [1,]  0.35726527  0.54479195  0.71045144  0.12093579 -0.50527050\r\n [2,] -1.70212893  0.87925324 -0.11567527 -2.30056025  0.08120681\r\n [3,]  0.61579454 -1.40885920  0.37523183 -2.04403695 -1.86772383\r\n [4,]  0.13935082 -0.49236688  0.24843597  1.10264483  3.58891104\r\n [5,]  2.56047043 -0.04537879  0.94609823  0.84502330 -1.97346292\r\n [6,] -1.61439864  0.02736107  1.18698717 -0.26236584 -2.35061698\r\n [7,]  1.38535557 -1.47917011  0.03604596 -0.58221675 -1.91172208\r\n [8,] -2.43197108  2.27754031  0.79457889 -1.92111865 -0.20142443\r\n [9,] -2.74954715 -2.20195595  0.97673882 -0.06741577  0.84320441\r\n[10,] -0.02845352  2.05010340 -0.04993779 -0.76210496  0.68938646\r\n\r\nA %*% B\r\n\r\n\r\n            [,1]       [,2]       [,3]        [,4]       [,5]\r\n [1,]  0.9938655 -3.7309864  4.5522411  1.42000159  3.7608506\r\n [2,] -1.4184994  0.7751247 -1.3288096 -2.52155881 -0.8933873\r\n [3,]  1.0392495  4.1453159  2.6158826 -4.92927853 -6.7984345\r\n [4,]  1.4520863 -2.1428715  2.0579063  0.10890153  8.4537281\r\n [5,] -6.0320999  7.9910496 -0.3209918  0.08380835  0.7225981\r\n [6,] -5.1239885  1.1136269  1.9894389 -3.21518739  0.0225107\r\n [7,] -2.7391669  3.2879656 -0.4839578 -2.77454947 -5.6744185\r\n [8,]  7.9646920 -0.5860431  2.7216186  6.98664010 -7.1396897\r\n [9,] -3.0590553  2.9376885  1.2365207 -4.94641999 -1.4093955\r\n[10,]  3.2322680 -3.6443159 -1.7754987  5.30872208  4.9346859\r\n             [,6]       [,7]       [,8]       [,9]      [,10]\r\n [1,]  5.95629065  3.5948044 -4.3321155  0.4266339 -0.7405074\r\n [2,]  5.12318341  1.7659080  2.1793587  3.0943642  3.3751705\r\n [3,] -0.03959789  6.7095507  0.9329672  8.2343062  0.8640957\r\n [4,]  3.18427174 -0.4438895 -1.3685704 -4.6234702 -3.4690237\r\n [5,]  0.70768109 -1.8240165 -9.4876407 -8.2360025 -2.6058889\r\n [6,]  2.76104601  4.2737939 -3.4401771 -2.5917601 -5.1458223\r\n [7,]  1.53290217  5.1794165 -2.9718640  3.0624102  1.1503788\r\n [8,] -3.32543937  2.7871569 -2.6589193  8.6706184  8.9524173\r\n [9,]  3.46481964  8.3290385 -3.5026001  0.3530313 -1.2923100\r\n[10,]  0.80393092 -4.6363067 -0.8109415 -3.4473722  1.6077858\r\n\r\nC = A %*% B\r\ndet(C) == det(A %*% B)\r\n\r\n\r\n[1] TRUE\r\n\r\ndet(A + B) == (det(A) + det(B))\r\n\r\n\r\n[1] FALSE\r\n\r\nInversa\r\n\r\n\r\nA <- matrix(data = c(6, 2, 3, 2, 4, 2, 1, 1, 8), ncol = 3)\r\ndet(A)\r\n\r\n\r\n[1] 146\r\n\r\ninv(A)\r\n\r\n\r\n            [,1]        [,2]        [,3]\r\n[1,]  0.20547945 -0.09589041 -0.01369863\r\n[2,] -0.08904110  0.30821918 -0.02739726\r\n[3,] -0.05479452 -0.04109589  0.13698630\r\n\r\nDependencia Linear\r\n\r\n\r\nv1 <- c(1, -1, 0, 0)\r\nv2 <- c(0, 0, 1, 1)\r\nv3 <- c(-2, 2, 1, 1)\r\nv4 <- c(1, 0, 0, 0)\r\n\r\nA <- matrix(data = cbind(v1, v2, v3, v4), ncol = 4)\r\n# Se o determinante de A for 0, os vetores são linearmente dependentes\r\ndet(A)\r\n\r\n\r\n[1] 0\r\n\r\nv5 <- c(2, -3, 2, 2)\r\nAhat <- cbind(A, v5)\r\nAhat\r\n\r\n\r\n               v5\r\n[1,]  1 0 -2 1  2\r\n[2,] -1 0  2 0 -3\r\n[3,]  0 1  1 0  2\r\n[4,]  0 1  1 0  2\r\n\r\n# Como os postos são iguais (p = 3), o sistema é possivel.\r\n# Como o número de variáveis é maior que o posto (n > p), o sistema é indetemrinado.\r\n# Assim, v5 é combinação linear dos outros vetores.\r\nechelon(Ahat)\r\n\r\n\r\n              v5\r\n[1,] 1 0 -2 0  3\r\n[2,] 0 1  1 0  2\r\n[3,] 0 0  0 1 -1\r\n[4,] 0 0  0 0  0\r\n\r\nAutovalores\r\n\r\n\r\neigen(A)\r\n\r\n\r\neigen() decomposition\r\n$values\r\n[1]  2.2469796 -0.8019377  0.5549581  0.0000000\r\n\r\n$vectors\r\n           [,1]       [,2]       [,3]          [,4]\r\n[1,]  0.3913958 -0.2354615 -0.8346812 -8.164966e-01\r\n[2,] -0.6086042  0.7645385  0.1653188  4.082483e-01\r\n[3,] -0.4880626 -0.4242869 -0.3714681 -4.082483e-01\r\n[4,] -0.4880626 -0.4242869 -0.3714681  1.281975e-16\r\n\r\neigen(A)$vectors %>%\r\n  zapsmall(digits = 1)\r\n\r\n\r\n     [,1] [,2] [,3] [,4]\r\n[1,]  0.4 -0.2 -0.8 -0.8\r\n[2,] -0.6  0.8  0.2  0.4\r\n[3,] -0.5 -0.4 -0.4 -0.4\r\n[4,] -0.5 -0.4 -0.4  0.0\r\n\r\neigen(A)$values %>%\r\n  zapsmall(digits = 1)\r\n\r\n\r\n[1]  2.2 -0.8  0.6  0.0\r\n\r\nExercícios sobre estrutura de ontrole\r\nExercício 1\r\nElabore uma função que verifique que uma matriz é quadrada e que seja singular antes de calcular a sua inversa. Não atendendo a uma das condições, a função deverá mostrar uma mensagem alertando o problema. Além de pode usar a estrutura de conotrle if-else, há também uma função chamada ifelse() para processos condicionados curtos.\r\n\r\n\r\nA <- matrix(data = c(1, 5, 0, 0, 4, 2, 0, 0, 2), ncol = 3)\r\nB <- matrix(data = c(1, 5, 0, 0, 4, 2, 0, 0, 0), ncol = 3)\r\nC <- matrix(data = c(1, 5, 0, 0, 4, 2, 0, 0, 2), ncol = 2)\r\ndet(A)\r\n\r\n\r\n[1] 8\r\n\r\ndet(B)\r\n\r\n\r\n[1] 0\r\n\r\ndet(C)\r\n\r\n\r\nError in determinant.matrix(x, logarithm = TRUE, ...): 'x' must be a square matrix\r\n\r\ninversa <- function(A) {\r\n  \r\n  cond1 <- dim(A)[1] == dim(A)[2]\r\n\r\n  if (!cond1) {\r\n    stop(\"Matriz não quadrada\")\r\n  }\r\n  else\r\n    \r\n    cond2 <- det(A) != 0\r\n  \r\n    if (!cond2) {\r\n      stop(\"Matriz singular\")\r\n    }\r\n    else\r\n      matlib::inv(A)\r\n  \r\n}\r\n\r\ninversa(A)\r\n\r\n\r\n      [,1]  [,2] [,3]\r\n[1,]  1.00  0.00  0.0\r\n[2,] -1.25  0.25  0.0\r\n[3,]  1.25 -0.25  0.5\r\n\r\ninversa(B)\r\n\r\n\r\nError in inversa(B): Matriz singular\r\n\r\ninversa(C)\r\n\r\n\r\nError in inversa(C): Matriz não quadrada\r\n\r\nExercício 2\r\nTemos uma lista de n=100 pessoas, cujas notas de desempenho possuem uma média de 500 e um desvio padrão de 20. Com uma nota maior que 500, o candidato é considerado aprovado (“A”) e apto para o emprego, caso contrário, o seu status é de reprovado (“R”). Gere um vetor com as notas e a partir dele, usando a função ifelse(), gere um vetor com o resultado final para cada candidato (“A” ou “R”). O vetor com as notas pode ser produzido com a função rnorm().\r\n\r\n\r\nnotas <- rnorm(n = 100, mean = 500, sd = 20)\r\nnotas\r\n\r\n\r\n  [1] 498.0368 496.8187 517.4338 498.9388 507.2851 475.8379 536.3180\r\n  [8] 535.7041 508.4909 508.5773 500.7933 519.3354 490.1823 489.2373\r\n [15] 497.9161 526.6797 515.1088 498.1005 473.6683 501.9816 482.8166\r\n [22] 498.9245 512.4836 520.1285 488.6387 460.8951 503.7758 505.5996\r\n [29] 514.9753 482.9350 491.8421 469.1067 479.1165 487.6381 511.1203\r\n [36] 495.5932 531.2411 497.6885 502.3628 534.7925 524.8541 506.6856\r\n [43] 498.4812 515.7652 565.1426 484.7626 531.6333 501.9248 491.7815\r\n [50] 519.5835 522.5611 468.5922 488.2129 516.9791 485.5881 505.5929\r\n [57] 475.3099 516.3805 478.3660 487.5648 512.2753 486.6493 499.8239\r\n [64] 508.3172 506.8702 515.0624 481.8286 506.2760 505.7845 475.9142\r\n [71] 490.6238 499.0099 511.6090 533.3013 534.9954 483.0735 521.0264\r\n [78] 495.8033 491.5243 473.0262 511.4558 483.6711 482.6113 537.2641\r\n [85] 496.8289 486.4473 487.5622 508.8091 492.1757 502.8958 496.8729\r\n [92] 465.0350 496.9658 501.3405 519.1321 467.6980 509.8034 482.6991\r\n [99] 512.4218 526.3270\r\n\r\nresultado <- ifelse(test = notas > 500, yes = \"A\", no = \"R\")\r\nresultado\r\n\r\n\r\n  [1] \"R\" \"R\" \"A\" \"R\" \"A\" \"R\" \"A\" \"A\" \"A\" \"A\" \"A\" \"A\" \"R\" \"R\" \"R\" \"A\"\r\n [17] \"A\" \"R\" \"R\" \"A\" \"R\" \"R\" \"A\" \"A\" \"R\" \"R\" \"A\" \"A\" \"A\" \"R\" \"R\" \"R\"\r\n [33] \"R\" \"R\" \"A\" \"R\" \"A\" \"R\" \"A\" \"A\" \"A\" \"A\" \"R\" \"A\" \"A\" \"R\" \"A\" \"A\"\r\n [49] \"R\" \"A\" \"A\" \"R\" \"R\" \"A\" \"R\" \"A\" \"R\" \"A\" \"R\" \"R\" \"A\" \"R\" \"R\" \"A\"\r\n [65] \"A\" \"A\" \"R\" \"A\" \"A\" \"R\" \"R\" \"R\" \"A\" \"A\" \"A\" \"R\" \"A\" \"R\" \"R\" \"R\"\r\n [81] \"A\" \"R\" \"R\" \"A\" \"R\" \"R\" \"R\" \"A\" \"R\" \"A\" \"R\" \"R\" \"R\" \"A\" \"A\" \"R\"\r\n [97] \"A\" \"R\" \"A\" \"A\"\r\n\r\nExercício 3\r\nElabore uma função que calcule o cofator Aij de uma matriz A de ordem n.\r\n\r\n\r\nA <- matrix(data = c(1, 5, 0, 0, 4, 2, 0, 0, 2), ncol = 3)\r\nA\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    1    0    0\r\n[2,]    5    4    0\r\n[3,]    0    2    2\r\n\r\n\r\n\r\nmcof <- function(A) {\r\n  C <- matrix(nrow = dim(A)[1], ncol = dim(A)[2])\r\n  \r\n  for (i in 1:dim(A)[1]) {\r\n    for (j in 1:dim(A)[2]) {\r\n      B <- A[-i, -j]\r\n      C[i, j] <- det(B)*(-1)^outer(X = i, Y = j, FUN = \"+\")\r\n    }\r\n  }\r\n  return(C)\r\n}\r\nmcof(A)\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    8  -10   10\r\n[2,]    0    2   -2\r\n[3,]    0    0    4\r\n\r\n\r\n\r\nmcof <- function(A) {\r\n  C <- matrix(nrow = dim(A)[1], ncol = dim(A)[2])\r\n  \r\n  for (i in 1:dim(A)[1]) {\r\n    for (j in 1:dim(A)[2]) {\r\n      B <- A[-i, -j]\r\n      C[i, j] <- det(B)*(-1)^(i + j)\r\n    }\r\n  }\r\n  return(C)\r\n\r\n}\r\nmcof(A)\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    8  -10   10\r\n[2,]    0    2   -2\r\n[3,]    0    0    4\r\n\r\n\r\n\r\nmcof2 <- function(A) {\r\n  C <- matrix(nrow = dim(A)[1], ncol = dim(A)[2])\r\n  \r\n  for (i in 1:dim(A)[1]) {\r\n    for (j in 1:dim(A)[2]) {\r\n      C[i, j] <- cofactor(A, i, j)\r\n    }\r\n  }\r\n  return(C)\r\n}\r\nmcof2(A)\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    8  -10   10\r\n[2,]    0    2   -2\r\n[3,]    0    0    4\r\n\r\nExercícios Semana 3\r\nExercício 4\r\n\r\n\r\nA <- matrix(data = c(1, 5, 0, 0, 4, 2, 0, 0, 2), ncol = 3)\r\nA\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    1    0    0\r\n[2,]    5    4    0\r\n[3,]    0    2    2\r\n\r\nCalcule o determinante de A:\r\n\r\n\r\ndet(A)\r\n\r\n\r\n[1] 8\r\n\r\nObtenha a diagonal de A e calcule o produto dos seus elementos, usando a função prod().\r\n\r\n\r\ndiag(A)\r\n\r\n\r\n[1] 1 4 2\r\n\r\nprod(diag(A))\r\n\r\n\r\n[1] 8\r\n\r\nCompare os resultados de A) e B)\r\n\r\n\r\nc(det(A), prod(diag(A)))\r\n\r\n\r\n[1] 8 8\r\n\r\nPodemos afirmar que A é inversível?\r\n\r\nSim. Pois \\(det(A) \\ne 0\\)\r\n\r\n\r\ninv(A)\r\n\r\n\r\n      [,1]  [,2] [,3]\r\n[1,]  1.00  0.00  0.0\r\n[2,] -1.25  0.25  0.0\r\n[3,]  1.25 -0.25  0.5\r\n\r\nExercício 5\r\nGere duas matrizes de ordem n = 10, com valores inteiros aleatorios de distribuição uniforme no intervalo [−10, 10]. Verifique o teorema de Binet (a falsidade da propriedade distributiva da soma para o determinante de matrizes).\r\n\r\n\r\nA <- matrix(data = runif(n = 100, min = -10, max = 10), ncol = 10)\r\nB <- matrix(data = runif(n = 100, min = -10, max = 10), ncol = 10)\r\n\r\ndet(A)\r\n\r\n\r\n[1] 30536081138\r\n\r\ndet(B)\r\n\r\n\r\n[1] -19352573558\r\n\r\ndet(A + B)\r\n\r\n\r\n[1] -5.874197e+12\r\n\r\ndet(A + B) == (det(A) + det(B))\r\n\r\n\r\n[1] FALSE\r\n\r\nExercício 6\r\nDetermine os autovalores e autovetores das matrizes a seguir:\r\n\r\n\r\n\r\nA <- matrix(data = c(3, 0, 0, -3, 3, 0, -4, 5, -1), ncol = 3)\r\nA\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    3   -3   -4\r\n[2,]    0    3    5\r\n[3,]    0    0   -1\r\n\r\neigen(A)\r\n\r\n\r\neigen() decomposition\r\n$values\r\n[1]  3  3 -1\r\n\r\n$vectors\r\n     [,1]         [,2]        [,3]\r\n[1,]    1 1.000000e+00  0.03901372\r\n[2,]    0 2.220446e-16 -0.78027431\r\n[3,]    0 0.000000e+00  0.62421945\r\n\r\ncbind(eigen(A)$values, diag(A))\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    3    3\r\n[2,]    3    3\r\n[3,]   -1   -1\r\n\r\nCompare os autovalores obtidos com a diagonal principal da matriz triangular superior. Por que acontece o observado?\r\nR: Porque a matriz é triangular, portanto o produto da diagonal princial é o único termo do determinante que não se anula.\r\n\r\n\r\n\r\nA <- matrix(data = c(-1, 2, 2, -4, -7, -4, 14, 14, 11), ncol = 3)\r\nA\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]   -1   -4   14\r\n[2,]    2   -7   14\r\n[3,]    2   -4   11\r\n\r\neigen(A)\r\n\r\n\r\neigen() decomposition\r\n$values\r\n[1]  9 -3 -3\r\n\r\n$vectors\r\n          [,1]       [,2]        [,3]\r\n[1,] 0.5773503 -0.9622504  0.09350413\r\n[2,] 0.5773503  0.1924501 -0.95370329\r\n[3,] 0.5773503  0.1924501 -0.28584439\r\n\r\ncbind(eigen(A)$values, diag(A))\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    9   -1\r\n[2,]   -3   -7\r\n[3,]   -3   11\r\n\r\nC )\r\n\r\n\r\nA <- matrix(data = c(1, -1, 1, 0, 0, 1, 2, 1, 2), ncol = 3)\r\nA\r\n\r\n\r\n     [,1] [,2] [,3]\r\n[1,]    1    0    2\r\n[2,]   -1    0    1\r\n[3,]    1    1    2\r\n\r\neigen(A)\r\n\r\n\r\neigen() decomposition\r\n$values\r\n[1]  3 -1  1\r\n\r\n$vectors\r\n             [,1]       [,2]          [,3]\r\n[1,] 7.071068e-01  0.4082483  7.071068e-01\r\n[2,] 2.840404e-16  0.8164966 -7.071068e-01\r\n[3,] 7.071068e-01 -0.4082483 -1.727306e-16\r\n\r\ncbind(eigen(A)$values, diag(A))\r\n\r\n\r\n     [,1] [,2]\r\n[1,]    3    1\r\n[2,]   -1    0\r\n[3,]    1    2\r\n\r\n\r\n\r\n\r\nA <- matrix(data = c(3, 0, 0, -3, 3, 0, -4, 5, -1), ncol = 3)\r\nB <- matrix(data = c(-1, 2, 2, -4, -7, -4, 14, 14, 11), ncol = 3)\r\nC <- matrix(data = c(1, -1, 1, 0, 0, 1, 2, 1, 2), ncol = 3)\r\n\r\navecA <- eigen(A)$vector\r\navecB <- eigen(B)$vector\r\navecC <- eigen(C)$vector\r\n\r\navecA\r\n\r\n\r\n     [,1]         [,2]        [,3]\r\n[1,]    1 1.000000e+00  0.03901372\r\n[2,]    0 2.220446e-16 -0.78027431\r\n[3,]    0 0.000000e+00  0.62421945\r\n\r\ndet(avecA)\r\n\r\n\r\n[1] 1.386046e-16\r\n\r\navecB\r\n\r\n\r\n          [,1]       [,2]        [,3]\r\n[1,] 0.5773503 -0.9622504  0.09350413\r\n[2,] 0.5773503  0.1924501 -0.95370329\r\n[3,] 0.5773503  0.1924501 -0.28584439\r\n\r\ndet(avecB)\r\n\r\n\r\n[1] 0.4452393\r\n\r\navecC\r\n\r\n\r\n             [,1]       [,2]          [,3]\r\n[1,] 7.071068e-01  0.4082483  7.071068e-01\r\n[2,] 2.840404e-16  0.8164966 -7.071068e-01\r\n[3,] 7.071068e-01 -0.4082483 -1.727306e-16\r\n\r\ndet(avecC)\r\n\r\n\r\n[1] -0.8164966\r\n\r\nOs determinantes são diferentes de 0, portanto os autovetores são linearmente independentes.\r\n\r\n\r\n\r\n",
      "last_modified": "2021-04-30T19:46:07-03:00"
    },
    {
      "path": "cobweb.html",
      "title": "Cobweb",
      "description": "Essa aula estuda o modelo de Cobweb e Expectativas adaptativas.\n",
      "author": [
        {
          "name": "Rafael Peixoto",
          "url": {}
        }
      ],
      "date": "04-23-2021",
      "contents": "\r\n\r\nContents\r\nCobweb\r\nExpectativas Adaptativas\r\nExercícios\r\n\r\n\r\n\r\nd-article p {\r\n  text-align: justify;\r\n  font-size: 16px;\r\n}\r\n\r\nd-article p code {\r\n  background: rgba(236, 236, 236, 0.8);\r\n}\r\n\r\nd-article div.sourceCode {\r\n  overflow: auto !important;\r\n}\r\n\r\nCobweb\r\nSe trata de um modelo cássico de oferta e demanda baseado nas seguintes hipóteses:\r\nFunções lineares;\r\nA oferta reage ao preço com um atraso de um período: a produção requer de um período fixo de tempo (agricultura);\r\nOs produtores acreditam que o preço se manterá no período seguinte e assim, a nova “safra” de produção será iniciada a partir desse preço:\r\n\\[\r\nS_t = a_1 + b_1 p_{t-1}\r\n\\]\r\nA demanda depende do preço atual:\r\n\\[\r\nD_t = a + b p_t\r\n\\]\r\nMarket clearing: a cada período o mercado determina o preço tal que a demanda absorva o produto ofertado:\r\n\\[\r\nD_t = S_t\r\n\\]\r\nCom isso, substituindo as duas primeiras equações na terceira, chegamos a uma equação emdiferença de primeira ordem em p:\r\n\\[\r\na + b p_t = a_1 + b_1 p_{t-1}\r\n\\]\r\nReescrevendo essa equação nos termos que estamos utilizando aqui (\\(p_t = y_t\\)):\r\n\\[\r\ny_{t+1} = \\frac{b_1}{b} \\times y_t + \\frac{a_1 - a}{b}\r\n\\]\r\nEssa equação possui a mesma forma que a equação não-homogêna (sem trend) que vimos anteriormente:\r\n\\[\r\ny_{t+1} = - a_0 \\times y_t + b\r\n\\]\r\nUtilizaremos, portanto, a função orbita:\r\n\r\n\r\n# Função que calcula a orbita de cada Eq em diferença\r\norbita <- function(a0, y0, b, t) {\r\n  \r\n  out <- vector(mode = \"numeric\", length = t)\r\n  out[1] <- y0\r\n  for (i in 1:t) {\r\n    out[i+1] <- ((-a0*out[i]) + b)\r\n  }\r\n  \r\n  return(out[-1])\r\n  \r\n}\r\n\r\n\r\n\r\n\r\n\r\n# Exemplo\r\norbita(a0 = 0.8, y0 = 1, b = 2, t = 20) %>%\r\n  ts() %>%\r\n  autoplot()\r\n\r\n\r\n\r\n\r\nVoltando ao modelo de Cobweb, vejamos um exemplo com os seguintes parâmetros:\r\n\r\n\r\na <- 0.2\r\nb <- -1\r\na1 <- 0.1\r\nb1 <- 0.5\r\np0 <- 1\r\nt <- 20\r\n\r\n\r\n\r\n\r\n\r\n# Plot\r\norbita(a0 = -(b1/b), y0 = p0, b = (a1 - a)/b, t = t) %>%\r\n  ts() %>%\r\n  autoplot()\r\n\r\n\r\n\r\n\r\nLembrando que estamos considerando \\(p_t = y_t\\), portanto esse gráfico diz respeito ao comportamento dos preços. Podemos também analisar o comportamento da oferta e da demanda, incluindo essas na função junto ao preço:\r\n\r\n\r\ncobweb <- function(a, b, a1, b1, p0, t) {\r\n  \r\n  p1 <- (b1/b)*p0 + (a1 - a)/b\r\n  \r\n  p <- vector(mode = \"numeric\", length = t)\r\n  p[1] <- p1\r\n  D <- vector(mode = \"numeric\", length = t)\r\n  D[1] <- a + b*p[1]\r\n  S <- vector(mode = \"numeric\", length = t)\r\n  S[1] <- a1 + b1*p0\r\n  \r\n  for (i in 1:t) {\r\n    p[i+1] <- (b1/b)*p[i] + (a1 - a)/b\r\n    D[i+1] <- a + b*p[i+1]\r\n    S[i+1] <- a1 + b1*p[i]\r\n  }\r\n  \r\n  cobweb <- cbind(p, D, S)\r\n  colnames(cobweb) <- c(\"Preço\", \"Demanda\", \"Oferta\")\r\n  \r\n  return(cobweb)\r\n  \r\n}\r\n\r\n\r\n\r\n\r\n\r\n# Exemplo\r\ncobweb(a = a, b = b, a1 = a1, b1 = b1, p0 = p0, t = t) %>%\r\n  ts() %>%\r\n  autoplot()\r\n\r\n\r\n\r\n\r\nAjustando o gráfico:\r\n\r\n\r\n# Exemplo\r\ncobweb(a = a, b = b, a1 = a1, b1 = b1, p0 = p0, t = t) %>%\r\n  ts() %>%\r\n  autoplot(facets = F) +\r\n    ggtitle(\"Modelo Cobweb\") + \r\n    xlab(\"t\") +\r\n    ylab(\"\") +\r\n    theme_hc() +\r\n    theme(plot.title = element_text(size = 15, hjust = 0.5, colour = \"black\"),\r\n          plot.subtitle = element_text(size = 10, hjust = 0.5, colour = \"black\"),\r\n          legend.position = \"top\") +\r\n    scale_colour_discrete(\"\") +\r\n    scale_x_continuous(breaks = seq(from = 0, to = 20, by = 2)) +\r\n    scale_y_continuous(breaks = seq(from = -1, to = 1, by = 0.2))\r\n\r\n\r\n\r\n\r\nNo gráfico com as três séries juntas, como a demanda e a oferta são iguais (pressuposto do modelo), elas se sobepõem.\r\nExpectativas Adaptativas\r\nNeste caso, como já visto, realizamos um refinamento do modelo anterior. Os produtores têm uma expectativa de preço \\(p^e\\), a partir da qual determinam os seus níveis de produção:\r\n\\[\r\nS_t = a_1 + b_1 \\times p_t^e\r\n\\]\r\nEstas expectativas são ajustadas a cada período de acordo com a discrepância entre o valor observado (realizado) e o valor esperado, com regra de variação dada por:\r\n\\[\r\np_t^e = \\beta p_{t-1} + (1 - \\beta) p_{t-1}^e \r\n\\]\r\nVimos que a solução analítica para \\(p^e_t\\) não é arbitrária. Mas, podemos analisar a dinâmica o modelo por simulação, contemplando assim, a todas as variáveis na análise numérica.\r\nPAra implementar esse modelo, basta adicionarmos essa equação à função cobweb que ja havíamos criado (além de modificar a equação do preço):\r\n\r\n\r\nexpec_adap <- function(a, b, a1, b1, p0, pe0, beta, t) {\r\n  \r\n  pe <- vector(mode = \"numeric\", length = t)\r\n  pe[1] <- pe0\r\n  \r\n  p1 <- (1 + beta*(b1/b - 1))*p0 + (a1 - a)*beta/b\r\n  \r\n  p <- vector(mode = \"numeric\", length = t)\r\n  p[1] <- p1\r\n  D <- vector(mode = \"numeric\", length = t)\r\n  D[1] <- a + b*p[1]\r\n  S <- vector(mode = \"numeric\", length = t)\r\n  S[1] <- a1 + b1*p0\r\n  \r\n  for (i in 1:t) {\r\n    p[i+1] <- (1 + beta*(b1/b - 1))*p[i] + (a1 - a)*beta/b\r\n    pe[i+1] <- beta*p[i] + (1-beta)*pe[i]\r\n    D[i+1] <- a + b*p[i+1]\r\n    S[i+1] <- a1 + b1*pe[i+1]\r\n  }\r\n  \r\n  expec_adap <- cbind(p, pe, D, S)\r\n  colnames(expec_adap) <- c(\"Preço\", \"Exp Preço\", \"Demanda\", \"Oferta\")\r\n  \r\n  return(expec_adap)\r\n  \r\n}\r\n\r\n\r\n\r\nVejamos um exemplo com os seguintes parâmetros:\r\n\r\n\r\na <- 0.2\r\nb <- -1\r\na1 <- 0.1\r\nb1 <- 0.5\r\np0 <- 2\r\nt <- 10\r\npe0 <- 3\r\nbeta <- 0.6\r\n\r\n\r\n\r\n\r\n\r\n# Exemplo\r\nexpec_adap(a = a, b = b, a1 = a1, b1 = b1, p0 = p0, pe0 = pe0, beta = beta, t = t) %>%\r\n  ts() %>%\r\n  autoplot()\r\n\r\n\r\n\r\n\r\nAjustando o gráfico:\r\n\r\n\r\nexpec_adap(a = a, b = b, a1 = a1, b1 = b1, p0 = p0, pe0 = pe0, beta = beta, t = t) %>%\r\n  ts() %>%\r\n  autoplot(facets = F) +\r\n    ggtitle(\"Exepctativas Adaptativas\") + \r\n    xlab(\"t\") +\r\n    ylab(\"\") +\r\n    theme_hc() +\r\n    theme(plot.title = element_text(size = 15, hjust = 0.5, colour = \"black\"),\r\n          plot.subtitle = element_text(size = 10, hjust = 0.5, colour = \"black\"),\r\n          legend.position = \"top\") +\r\n    scale_colour_discrete(\"\") +\r\n    scale_x_continuous(breaks = seq(from = 0, to = t, by = 1)) +\r\n    scale_y_continuous(breaks = seq(from = -1, to = 3, by = 0.5))\r\n\r\n\r\n\r\n\r\nExercícios\r\n1.\r\nSimule o modelo Cobweb considerando o preço normal. Pode por exemplo, testar os valores dos exercícios numéricos do Shone e do Gandolfo.\r\nComo, nesse modelo, o \\(a_0\\) é representado por \\(- \\frac{b_1}{b}\\), essa fração precisa ser menor, em módulo, que 1, para que o sistema não seja explosivo:\r\n\r\n\r\ncobweb(a = 2, b = -2, a1 = 1, b1 = 1.8, p0 = 4, t = 50) %>%\r\n  ts() %>%\r\n  autoplot(facets = F)\r\n\r\n\r\n\r\n\r\n\r\n\r\ncobweb(a = 2, b = -2, a1 = 1, b1 = 2, p0 = 4, t = 50) %>%\r\n  ts() %>%\r\n  autoplot(facets = F)\r\n\r\n\r\n\r\n\r\n\r\n\r\ncobweb(a = 2, b = -2, a1 = 1, b1 = 2.2, p0 = 4, t = 50) %>%\r\n  ts() %>%\r\n  autoplot(facets = F)\r\n\r\n\r\n\r\n\r\n2.\r\nSe sugere analisar as simulações com outros conjuntos de parâmetros e inicializações.\r\n\r\n\r\n\r\n",
      "last_modified": "2021-04-30T19:46:17-03:00"
    },
    {
      "path": "eqdiff.html",
      "title": "Equações em Diferença",
      "description": "Essa aula estuda Equações em Diferença.\n",
      "author": [
        {
          "name": "Rafael Peixoto",
          "url": {}
        }
      ],
      "date": "04-19-2021",
      "contents": "\r\n\r\nContents\r\nEquações Homogêneas\r\nAutomatizando esse processo\r\n\r\nEquações Não Homogêneas\r\nHomogênea x não-Homogênea\r\nExercícios\r\n\r\n\r\n\r\nd-article p {\r\n  text-align: justify;\r\n  font-size: 16px;\r\n}\r\n\r\nd-article p code {\r\n  background: rgba(236, 236, 236, 0.8);\r\n}\r\n\r\nd-article div.sourceCode {\r\n  overflow: auto !important;\r\n}\r\n\r\nEquações Homogêneas\r\nQueremos analisar a dinâmica resultante de uma equação em diferença de ordem 1, analisando valores diversos para o coeficiente \\(a_0\\):\r\n\\[\r\ny_{t+1} + a_0 y_t = 0\r\n\\] Já conhecemos a solução analítica:\r\n\\[\r\ny_t = A(-a_0)^t\r\n\\] tal que, para \\(t = 0\\), \\(A = y_0\\), com \\(y_0\\) representando a condição inicial (se conhecida).\r\nCriando as séries\r\nMas também podemos oferecer a solução numérica via simulação, implementando diretamente a equação que define a dinâmica da sequência de valores (a série temporal):\r\n\r\n\r\n### Parâmetros e Condições iniciais\r\n\r\n# Coeficiente\r\na0 <- c(2, -2, 1/3, -1/3, 1, -1)\r\n\r\n# Número de iterações\r\nt <- 10\r\n\r\n# Valor inicial\r\ny0 <- 0.025\r\n\r\n\r\n\r\n\r\n\r\n### Séries temporais geradas a partir de cada coeficiente\r\n\r\n# Séries\r\ny1 <- (a0[1])^(1:t) * y0\r\ny2 <- (a0[2])^(1:t) * y0\r\ny3 <- (a0[3])^(1:t) * y0\r\ny4 <- (a0[4])^(1:t) * y0\r\ny5 <- (a0[5])^(1:t) * y0\r\ny6 <- (a0[6])^(1:t) * y0\r\n\r\n# Data-Frame (em forma de ts)\r\nydata <- data.frame(y1, y2, y3, y4, y5, y6) %>%\r\n  as.ts()\r\n\r\n\r\n\r\n\r\n\r\n# Plot das séries geradas\r\nautoplot(ydata, facets = F) +\r\n  ggtitle(\"Equações de Ordem 1\") +\r\n  xlab(\"t\") +\r\n  ylab(\"Y\") +\r\n  theme_hc() +\r\n  theme(plot.title = element_text(size = 15, hjust = 0.5, colour = \"black\"),\r\n        plot.subtitle = element_text(size = 10, hjust = 0.5, colour = \"black\"),\r\n        legend.position = \"right\") +\r\n  scale_colour_discrete(\"\") +\r\n  scale_x_continuous(breaks = seq(from = 0, to = t, by = 1)) +\r\n  scale_y_continuous(breaks = seq(from = -15, to = 25, by = 5))\r\n\r\n\r\n\r\n\r\nAutomatizando esse processo\r\n\r\n\r\n# Através de Loop\r\nydata <- ts(matrix(NA, nrow = length(1:t), ncol = length(a0)))\r\n\r\nfor (i in 1:length(a0)) {\r\n  ydata[, i] <- (a0[i])^(1:t) * y0\r\n}\r\n\r\n\r\n\r\n\r\n\r\n# Através de Função\r\nyfunchomo <- function(t, a0, y0) {\r\n  \r\n  ydata <- ts(matrix(NA, nrow = length(1:t), ncol = length(a0)))\r\n  \r\n  for (i in 1:length(a0)) {\r\n    ydata[, i] <- (a0[i])^(1:t) * y0\r\n  }\r\n  \r\n  colnames(ydata) <- c(paste0(rep(\"a0: \"), round(a0, 1)))\r\n  \r\n  ydata <- rbind(y0, ydata) %>% ts(start = 0)\r\n  \r\n  return(ydata)\r\n  \r\n}\r\n\r\n\r\n\r\n\r\n\r\n# Exemplo \r\nyfunchomo(t = 5, a0 = -2:2, y0 = 0.8)\r\n\r\n\r\nTime Series:\r\nStart = 0 \r\nEnd = 5 \r\nFrequency = 1 \r\n  a0: -2 a0: -1 a0: 0 a0: 1 a0: 2\r\n0    0.8    0.8   0.8   0.8   0.8\r\n1   -1.6   -0.8   0.0   0.8   1.6\r\n2    3.2    0.8   0.0   0.8   3.2\r\n3   -6.4   -0.8   0.0   0.8   6.4\r\n4   12.8    0.8   0.0   0.8  12.8\r\n5  -25.6   -0.8   0.0   0.8  25.6\r\n\r\n\r\n\r\n# Exemplo direto do Plot\r\nautoplot(yfunchomo(t = 5, a0 = seq(-1.5, 1.5, 0.5), y0 = 0.8), facets = F) +\r\n  ggtitle(\"Equações de Ordem 1\") +\r\n  xlab(\"t\") +\r\n  ylab(\"Y\") +\r\n  theme_hc() +\r\n  theme(plot.title = element_text(size = 15, hjust = 0.5, colour = \"black\"),\r\n        plot.subtitle = element_text(size = 10, hjust = 0.5, colour = \"black\"),\r\n        legend.position = \"right\") +\r\n  scale_colour_discrete(\"\")\r\n\r\n\r\n\r\n\r\nVoltando ao exemplo do início:\r\n\r\n\r\nydata <- yfunchomo(t = t, a0 = a0, y0 = y0)\r\n\r\n\r\n\r\n\r\n\r\nautoplot(ydata, facets = F) +\r\n  ggtitle(\"Equações de Ordem 1\") +\r\n  xlab(\"t\") +\r\n  ylab(\"Y\") +\r\n  theme_hc() +\r\n  theme(plot.title = element_text(size = 15, hjust = 0.5, colour = \"black\"),\r\n        plot.subtitle = element_text(size = 10, hjust = 0.5, colour = \"black\"),\r\n        legend.position = \"right\") +\r\n  scale_colour_discrete(\"\") +\r\n  scale_x_continuous(breaks = seq(from = 0, to = t, by = 1)) +\r\n  scale_y_continuous(breaks = seq(from = -15, to = 25, by = 5))\r\n\r\n\r\n\r\n\r\nEquações Não Homogêneas\r\nQueremos analisar uma série temporal \\(y_t\\), resultante de uma equação em diferença de ordem 1:\r\n\\[\r\ny_{t+1} + a_0 \\times y_t = b\r\n\\]\r\nOu:\r\n\\[\r\ny_{t+1} = - a_0 \\times y_t + b\r\n\\] Por exemplo:\r\n\\[\r\ny_{t+1} - 1.1 \\times y_t = 2\r\n\\]\r\nPara isso, precisamos antes definir todos os nossos parâmetros iniciais: quantidade de períodos de simulação, as condições iniciais, e demais coeficientes da equação e auxiliares. Neste caso, \\(a_0 = -1.1\\) e a única diferença com relação ao caso homogêneo é o acréscimo de um termo independente \\(g(t) = b = 2\\).\r\nSeria possível reusar a função yfunchomo criada acima caso soubéssemos o \\(\\overset{*}{y}\\) — ou seja, o steady state. Como usualmente a priori não sabemos esse valor, tempos que criar uma função que itere os valores de cada período.\r\n\r\n\r\n# Função que calcula a orbita de cada Eq em diferença\r\norbita <- function(m, y0, b, t) {\r\n  \r\n  out <- vector(mode = \"numeric\", length = t)\r\n  out[1] <- y0\r\n  for (i in 1:t) {\r\n    out[i+1] <- ((-m*out[i]) + b)\r\n  }\r\n  \r\n  return(out[-1])\r\n  \r\n}\r\n\r\n\r\n\r\n\r\n\r\n# Exemplo\r\norbita(m = -1.1, y0 = 1, b = 2, t = 10)\r\n\r\n\r\n [1]  3.10000  5.41000  7.95100 10.74610 13.82071 17.20278 20.92306\r\n [8] 25.01537 29.51690 34.46859\r\n\r\n\r\n\r\n# Função que junta as diversas orbitas\r\nyfunc <- function(t, a0, y0, b) {\r\n  \r\n  ydata <- ts(matrix(NA, nrow = length(1:t), ncol = length(a0)))\r\n  \r\n  for (i in 1:length(a0)) {\r\n    ydata[, i] <- orbita(m = a0[i], y0 = y0, b = b, t = t)\r\n  }\r\n  \r\n  colnames(ydata) <- c(paste0(rep(\"a0: \"), round(a0, 1)))\r\n  \r\n  ydata <- rbind(y0, ydata) %>% ts(start = 0)\r\n  \r\n  return(ydata)\r\n  \r\n}\r\n\r\n\r\n\r\n\r\n\r\n# Exemplo\r\nyfunc(t = 10, a0 = -1:1, y0 = 0.5, b = 2)\r\n\r\n\r\nTime Series:\r\nStart = 0 \r\nEnd = 10 \r\nFrequency = 1 \r\n   a0: -1 a0: 0 a0: 1\r\n 0    0.5   0.5   0.5\r\n 1    2.5   2.0   1.5\r\n 2    4.5   2.0   0.5\r\n 3    6.5   2.0   1.5\r\n 4    8.5   2.0   0.5\r\n 5   10.5   2.0   1.5\r\n 6   12.5   2.0   0.5\r\n 7   14.5   2.0   1.5\r\n 8   16.5   2.0   0.5\r\n 9   18.5   2.0   1.5\r\n10   20.5   2.0   0.5\r\n\r\n\r\n\r\n# Exemplo direto do Plot\r\nautoplot(yfunc(t = 5, a0 = c(-1, 0.5, -0.5, 1), y0 = 0.8, b = 1), facets = F) +\r\n  ggtitle(\"Equações de Ordem 1\") +\r\n  xlab(\"t\") +\r\n  ylab(\"Y\") +\r\n  theme_hc() +\r\n  theme(plot.title = element_text(size = 15, hjust = 0.5, colour = \"black\"),\r\n        plot.subtitle = element_text(size = 10, hjust = 0.5, colour = \"black\"),\r\n        legend.position = \"right\") +\r\n  scale_colour_discrete(\"\")\r\n\r\n\r\n\r\n\r\nHomogênea x não-Homogênea\r\n\r\n\r\n# Exemplo do início da seção\r\nautoplot(object = ts(cbind(yfunc(t = 5, a0 = -1.1, y0 = 1, b = 2),\r\n                           yfunc(t = 5, a0 = -1.1, y0 = 1, b = 0))),\r\n         facets = F) +\r\n  ggtitle(\"Equações de Ordem 1\") +\r\n  xlab(\"t\") +\r\n  ylab(\"Y\") +\r\n  theme_hc() +\r\n  theme(plot.title = element_text(size = 15, hjust = 0.5, colour = \"black\"),\r\n        plot.subtitle = element_text(size = 10, hjust = 0.5, colour = \"black\"),\r\n        legend.position = \"top\") +\r\n  scale_colour_discrete(\"\", labels = c(\"Não-Homogênea\", \"Homogênea\")) +\r\n  scale_x_continuous(breaks = seq(from = 0, to = t, by = 2)) +\r\n  scale_y_continuous(breaks = seq(from = -6, to = 15, by = 2))\r\n\r\n\r\n\r\n\r\nExercícios\r\nA partir das rotinas anteriores, analise a dinâmica e o estado estacionário das séries cujas dinâmicas são resultado das equações a seguir:\r\n1.\r\n\\(y_t + a_0 \\times y_{t-1} = \\frac{1}{4}\\), sendo que \\(y_0 = 2\\) e \\(a_0 = 0.25\\)\r\nR: Pela equação, \\(b = \\frac{1}{4}\\)\r\n\r\n\r\nnaohomo1 <- yfunc(t = 10, a0 = 0.25, y0 = 2, b = 1/4)\r\nhomo1 <- yfunc(t = 10, a0 = 0.25, y0 = 2, b = 0)\r\n\r\n\r\n\r\n\r\n\r\nresult1 <- cbind(naohomo1, homo1)\r\ncolnames(result1) <- c(\"Não-Homogênea\", \"Homogênea\")\r\nresult1\r\n\r\n\r\nTime Series:\r\nStart = 0 \r\nEnd = 10 \r\nFrequency = 1 \r\n   Não-Homogênea     Homogênea\r\n 0     2.0000000  2.000000e+00\r\n 1    -0.2500000 -5.000000e-01\r\n 2     0.3125000  1.250000e-01\r\n 3     0.1718750 -3.125000e-02\r\n 4     0.2070312  7.812500e-03\r\n 5     0.1982422 -1.953125e-03\r\n 6     0.2004395  4.882812e-04\r\n 7     0.1998901 -1.220703e-04\r\n 8     0.2000275  3.051758e-05\r\n 9     0.1999931 -7.629395e-06\r\n10     0.2000017  1.907349e-06\r\n\r\n\r\n\r\nautoplot(result1, facets = F)\r\n\r\n\r\n\r\n\r\nLimpando o gráfico:\r\n\r\n\r\nautoplot(object = result1, facets = F) +\r\n  ggtitle(expression(y[t] + (0.25 %*% y[t-1]) == frac(1,4))) +\r\n  xlab(\"t\") +\r\n  ylab(\"Y\") +\r\n  theme_hc() +\r\n  theme(plot.title = element_text(size = 15, hjust = 0.5, colour = \"black\"),\r\n        plot.subtitle = element_text(size = 10, hjust = 0.5, colour = \"black\"),\r\n        legend.position = \"top\") +\r\n  scale_colour_discrete(\"\") +\r\n  scale_x_continuous(breaks = seq(from = 0, to = 10, by = 2)) +\r\n  scale_y_continuous(breaks = seq(from = -1, to = 2, by = 0.25))\r\n\r\n\r\n\r\n\r\n2.\r\nComo faria para simular a série \\(y_{t+1} = (−a0 \\times y_t) + k_0 + (k_1 \\times t)\\)? Teste para diversas condições inicials e analise o resultado.\r\nR: Primeiramente, devemos mudar nossa função orbita, afim de acomodar o termo \\(k_1 \\times t\\):\r\n\r\n\r\n# Função que calcula a orbita de cada Eq em diferença\r\norbita_trend <- function(m, y0, k0, k1, t) {\r\n  \r\n  out <- vector(mode = \"numeric\", length = t)\r\n  out[1] <- y0\r\n  trend <- rep(x = 0, t)\r\n  trend[1:t] <- 1:t\r\n  for (i in 1:t) {\r\n    out[i+1] <- (-m*out[i] + k0 + k1*trend[i])\r\n  }\r\n  \r\n  return(out[-1])\r\n  \r\n}\r\n\r\n\r\n\r\n\r\n\r\n# Teste Orbita\r\norbita_trend(m = 0.5, y0 = 2, k0 = 0, k1 = 1, t = 20)\r\n\r\n\r\n [1]  0.000000  2.000000  2.000000  3.000000  3.500000  4.250000\r\n [7]  4.875000  5.562500  6.218750  6.890625  7.554688  8.222656\r\n[13]  8.888672  9.555664 10.222168 10.888916 11.555542 12.222229\r\n[19] 12.888885 13.555557\r\n\r\n\r\n\r\n# Teste plot\r\nautoplot(ts(orbita_trend(m = 0.5, y0 = 2, k0 = 0, k1 = 1, t = 20)))\r\n\r\n\r\n\r\n\r\nAgora, voltando a questão, vamos testar para diversos valores de \\(k_0\\) e \\(k_1\\):\r\n\r\n\r\ns1 <- ts(orbita_trend(m = 0.9, y0 = 2, k0 = 0, k1 = 0, t = 20))\r\ns2 <- ts(orbita_trend(m = 0.9, y0 = 2, k0 = 1, k1 = 0, t = 20))\r\ns3 <- ts(orbita_trend(m = 0.9, y0 = 2, k0 = 0, k1 = 1, t = 20))\r\ns4 <- ts(orbita_trend(m = 0.9, y0 = 2, k0 = 1, k1 = 1, t = 20))\r\n\r\nseries <- cbind(s1, s2, s3, s4)\r\ncolnames(series) <- c(\"(0,0)\", \"(1,0)\", \"(0,1)\", \"(1,1)\")\r\n\r\n\r\n\r\n\r\n\r\nautoplot(object = series, facets = F) +\r\n  ggtitle(expression(y[t+1] == (-a[0] %*% y[t]) +k[0] + (k[1] %*%  t)), \r\n          subtitle = expression(list(k[0],k[1]))) +\r\n  xlab(\"t\") +\r\n  ylab(\"Y\") +\r\n  theme_hc() +\r\n  theme(plot.title = element_text(size = 15, hjust = 0.5, colour = \"black\"),\r\n        plot.subtitle = element_text(size = 10, hjust = 0.5, colour = \"black\"),\r\n        legend.position = \"top\") +\r\n  scale_colour_discrete(\"\") +\r\n  scale_x_continuous(breaks = seq(from = 0, to = 20, by = 1)) +\r\n  scale_y_continuous(breaks = seq(from = -1, to = 20, by = 1))\r\n\r\n\r\n\r\n\r\n3.\r\n\\(y{t+1} = 0.9 · y_t + X_t\\); com \\(Xt \\sim N(0, σ^2)\\). Teste para valores diferentes de σ2 e analise o seu efeito sobre a dinâmica da série.\r\nR: Primeiramente, devemos mudar nossa função orbita, afim de acomodar o termo \\(X_t\\):\r\n\r\n\r\n# Função que calcula a orbita de cada Eq em diferença\r\norbita_estoc <- function(m, y0, s2, t) {\r\n  \r\n  out <- vector(mode = \"numeric\", length = t)\r\n  out[1] <- y0\r\n  for (i in 1:t) {\r\n    out[i+1] <- (-m*out[i] + rnorm(n = 1, mean = 0, sd = sqrt(s2)))\r\n  }\r\n  \r\n  return(out[-1])\r\n  \r\n}\r\n\r\n\r\n\r\n\r\n\r\n# Teste Orbita\r\norbita_estoc(m = 0.5, y0 = 2, s2 = 2, t = 20)\r\n\r\n\r\n [1] -3.123713571  1.627564609 -0.725874212  0.565773764  1.030858409\r\n [6] -1.378407214  0.816711837  1.459028626  2.720543393 -3.457193347\r\n[11]  0.770679615 -0.972717559 -1.835207102 -0.387656372 -0.179890254\r\n[16] -0.212916500 -0.516137316  0.009930374 -0.104278091 -3.075162231\r\n\r\n\r\n\r\n# Teste plot\r\nautoplot(ts(orbita_estoc(m = 0.5, y0 = 2, s2 = 2, t = 20)))\r\n\r\n\r\n\r\n\r\nAgora, voltando a questão, vamos testar para diversos valores de \\(s^2\\)\r\n\r\n\r\ns21 <- ts(orbita_estoc(m = 0.5, y0 = 2, s2 = 0, t = 20))\r\ns22 <- ts(orbita_estoc(m = 0.5, y0 = 2, s2 = 2, t = 20))\r\ns23 <- ts(orbita_estoc(m = 0.5, y0 = 2, s2 = 4, t = 20))\r\ns24 <- ts(orbita_estoc(m = 0.5, y0 = 2, s2 = 6, t = 20))\r\n\r\nseriess2 <- cbind(s21, s22, s23, s24)\r\ncolnames(seriess2) <- c(paste0(rep(\"s2: \", 4), seq(0, 6, 2)))\r\n\r\n\r\n\r\n\r\n\r\nautoplot(object = seriess2, facets = F) +\r\n  ggtitle(expression(y[t+1] == (-a[0] %*% y[t]) + X[t])) +\r\n  xlab(\"t\") +\r\n  ylab(\"Y\") +\r\n  theme_hc() +\r\n  theme(plot.title = element_text(size = 15, hjust = 0.5, colour = \"black\"),\r\n        plot.subtitle = element_text(size = 10, hjust = 0.5, colour = \"black\"),\r\n        legend.position = \"top\") +\r\n  scale_colour_discrete(\"\") +\r\n  scale_x_continuous(breaks = seq(from = 0, to = 20, by = 1)) +\r\n  scale_y_continuous(breaks = seq(from = -10, to = 10, by = 1))\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "last_modified": "2021-04-30T19:46:30-03:00"
    },
    {
      "path": "index.html",
      "title": "Economia Matemática",
      "author": [
        {
          "name": "Rafael Peixoto",
          "url": {}
        }
      ],
      "date": "03-26-2021",
      "contents": "\r\n\r\n\r\nd-article p {\r\n  text-align: center;\r\n  font-size: 26px;\r\n}\r\n\r\nd-article p code {\r\n  background: rgba(236, 236, 236, 0.8);\r\n}\r\n\r\nd-article div.sourceCode {\r\n  overflow: auto !important;\r\n}\r\n\r\n\r\nEsse site acompanha as aulas da disciplina Economia Matemática (HO-012).\r\n\r\n\r\n\r\n",
      "last_modified": "2021-04-30T19:46:32-03:00"
    },
    {
      "path": "jdv.html",
      "title": "O Jogo da Vida",
      "description": "Essa aula explora o \"Jogo da Vida\", proposto por John H. Conway na década de 70.\n",
      "author": [
        {
          "name": "Rafael Peixoto",
          "url": {}
        }
      ],
      "date": "04-18-2021",
      "contents": "\r\n\r\nContents\r\nIntrodução\r\nO jogo\r\nVizinhança\r\nAtualização dos estados\r\nAutomatizando o jogo\r\nExemplos\r\n\r\n\r\n\r\n\r\nd-article p {\r\n  text-align: justify;\r\n  font-size: 16px;\r\n}\r\n\r\nd-article p code {\r\n  background: rgba(236, 236, 236, 0.8);\r\n}\r\n\r\nd-article div.sourceCode {\r\n  overflow: auto !important;\r\n}\r\n\r\nIntrodução\r\nO Jogo da Vida consiste em um conjunto de agentes distribuidos em um grid de tamanho n previamente definido. Cada agente, representado em um quadrado desse grid, é caracterizado por um dos dois estados possíveis: morto ou vivo.\r\n\r\n\r\n# Criando o Grid\r\nn <- 5\r\ngridIni <- expand.grid(x = 1:n, y = 1:n)\r\ngridIni$z <- runif(n = n^2, min = 0, max = 1) %>% \r\n  round(digits = 0)\r\n\r\n\r\n\r\n\r\n\r\n# Plotando o Grid\r\nggplot(data = gridIni) +\r\n  aes(x = x, y = y, fill = factor(z)) + \r\n  geom_tile(colour = \"black\", size = 0.8) +\r\n  coord_equal() +\r\n  theme_void() +\r\n  scale_fill_brewer(breaks = c(0, 1), \r\n                    labels = c(\"0 - Morto\", \"1 - Vivo\"),\r\n                    type = \"seq\",\r\n                    direction = 1, \r\n                    palette = 12) + \r\n  labs(title = \"Geração 0\", x = NULL, y = NULL, fill = \"Life\") +\r\n  geom_text(mapping = aes(label = 1:(n^2))) -> plot0\r\n\r\nplot0\r\n\r\n\r\n\r\n\r\nO jogo\r\nO jogo consiste em atualizar os estados dos agentes a cada geração, o que ocorre a partir dos estados de seus vizinhos:\r\nSe o agente tem menos de dois vizinhos vivos, ele morre\r\nSe tem mais de três vizinhos vivos, ele morre\r\nSe tem exatamente dois vizinhos vivos, ele mantêm seu estado atutal (vivo ou morto)\r\nSe tem exatamente três vizinhos vivos, a célula muda seu estado de morto para vivo , ou permanece vivo se já está nesse estado.\r\nVizinhança\r\nAs matrizes construídas a seguir servem para identificar os vizinhos (com seus respectivos estados) de cada agente.\r\n\r\n\r\n# Matriz ampliada\r\nmat <- matrix(data = 1:n^2, nrow = n)\r\nmat.pad <- rbind(NA, cbind(NA, mat, NA), NA)\r\nmat.pad\r\n\r\n\r\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7]\r\n[1,]   NA   NA   NA   NA   NA   NA   NA\r\n[2,]   NA    1    6   11   16   21   NA\r\n[3,]   NA    2    7   12   17   22   NA\r\n[4,]   NA    3    8   13   18   23   NA\r\n[5,]   NA    4    9   14   19   24   NA\r\n[6,]   NA    5   10   15   20   25   NA\r\n[7,]   NA   NA   NA   NA   NA   NA   NA\r\n\r\n\r\n\r\n# Matriz com os vizinhos\r\nind <- 2:(n + 1)\r\nvizinhos <- rbind(N  = as.vector(mat.pad[ind - 1, ind    ]),\r\n                  NE = as.vector(mat.pad[ind - 1, ind + 1]),\r\n                  E  = as.vector(mat.pad[ind    , ind + 1]),\r\n                  SE = as.vector(mat.pad[ind + 1, ind + 1]),\r\n                  S  = as.vector(mat.pad[ind + 1, ind    ]),\r\n                  SO = as.vector(mat.pad[ind + 1, ind - 1]),\r\n                  O  = as.vector(mat.pad[ind    , ind - 1]),\r\n                  NO = as.vector(mat.pad[ind - 1, ind - 1]))\r\n\r\nvizinhos\r\n\r\n\r\n   [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]\r\nN    NA    1    2    3    4   NA    6    7    8     9    NA    11\r\nNE   NA    6    7    8    9   NA   11   12   13    14    NA    16\r\nE     6    7    8    9   10   11   12   13   14    15    16    17\r\nSE    7    8    9   10   NA   12   13   14   15    NA    17    18\r\nS     2    3    4    5   NA    7    8    9   10    NA    12    13\r\nSO   NA   NA   NA   NA   NA    2    3    4    5    NA     7     8\r\nO    NA   NA   NA   NA   NA    1    2    3    4     5     6     7\r\nNO   NA   NA   NA   NA   NA   NA    1    2    3     4    NA     6\r\n   [,13] [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23]\r\nN     12    13    14    NA    16    17    18    19    NA    21    22\r\nNE    17    18    19    NA    21    22    23    24    NA    NA    NA\r\nE     18    19    20    21    22    23    24    25    NA    NA    NA\r\nSE    19    20    NA    22    23    24    25    NA    NA    NA    NA\r\nS     14    15    NA    17    18    19    20    NA    22    23    24\r\nSO     9    10    NA    12    13    14    15    NA    17    18    19\r\nO      8     9    10    11    12    13    14    15    16    17    18\r\nNO     7     8     9    NA    11    12    13    14    NA    16    17\r\n   [,24] [,25]\r\nN     23    24\r\nNE    NA    NA\r\nE     NA    NA\r\nSE    NA    NA\r\nS     25    NA\r\nSO    20    NA\r\nO     19    20\r\nNO    18    19\r\n\r\n\r\n\r\n# Matriz com os estados dos vizinhos\r\nestados.vizinhos <- c()\r\nfor (i in 1:n^2) {\r\n  estados.vizinhos <- cbind(estados.vizinhos, gridIni[vizinhos[, i], 3])\r\n}\r\nestados.vizinhos\r\n\r\n\r\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]\r\n[1,]   NA    1    1    0    0   NA    1    0    1     1    NA     1\r\n[2,]   NA    1    0    1    1   NA    1    0    0     0    NA     1\r\n[3,]    1    0    1    1    0    1    0    0    0     1     1     0\r\n[4,]    0    1    1    0   NA    0    0    0    1    NA     0     0\r\n[5,]    1    0    0    0   NA    0    1    1    0    NA     0     0\r\n[6,]   NA   NA   NA   NA   NA    1    0    0    0    NA     0     1\r\n[7,]   NA   NA   NA   NA   NA    1    1    0    0     0     1     0\r\n[8,]   NA   NA   NA   NA   NA   NA    1    1    0     0    NA     1\r\n     [,13] [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22]\r\n[1,]     0     0     0    NA     1     0     0     0    NA     0\r\n[2,]     0     0     0    NA     0     0     1     0    NA    NA\r\n[3,]     0     0     1     0     0     1     0     1    NA    NA\r\n[4,]     0     1    NA     0     1     0     1    NA    NA    NA\r\n[5,]     0     1    NA     0     0     0     1    NA     0     1\r\n[6,]     1     0    NA     0     0     0     1    NA     0     0\r\n[7,]     1     1     0     1     0     0     0     1     1     0\r\n[8,]     0     1     1    NA     1     0     0     0    NA     1\r\n     [,23] [,24] [,25]\r\n[1,]     0     1     0\r\n[2,]    NA    NA    NA\r\n[3,]    NA    NA    NA\r\n[4,]    NA    NA    NA\r\n[5,]     0     1    NA\r\n[6,]     0     1    NA\r\n[7,]     0     0     1\r\n[8,]     0     0     0\r\n\r\n\r\n\r\n# Trocar os 'NA' por 0\r\nestados.vizinhos0 <- estados.vizinhos\r\nestados.vizinhos0[is.na(estados.vizinhos0)] <- 0\r\nestados.vizinhos0\r\n\r\n\r\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]\r\n[1,]    0    1    1    0    0    0    1    0    1     1     0     1\r\n[2,]    0    1    0    1    1    0    1    0    0     0     0     1\r\n[3,]    1    0    1    1    0    1    0    0    0     1     1     0\r\n[4,]    0    1    1    0    0    0    0    0    1     0     0     0\r\n[5,]    1    0    0    0    0    0    1    1    0     0     0     0\r\n[6,]    0    0    0    0    0    1    0    0    0     0     0     1\r\n[7,]    0    0    0    0    0    1    1    0    0     0     1     0\r\n[8,]    0    0    0    0    0    0    1    1    0     0     0     1\r\n     [,13] [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22]\r\n[1,]     0     0     0     0     1     0     0     0     0     0\r\n[2,]     0     0     0     0     0     0     1     0     0     0\r\n[3,]     0     0     1     0     0     1     0     1     0     0\r\n[4,]     0     1     0     0     1     0     1     0     0     0\r\n[5,]     0     1     0     0     0     0     1     0     0     1\r\n[6,]     1     0     0     0     0     0     1     0     0     0\r\n[7,]     1     1     0     1     0     0     0     1     1     0\r\n[8,]     0     1     1     0     1     0     0     0     0     1\r\n     [,23] [,24] [,25]\r\n[1,]     0     1     0\r\n[2,]     0     0     0\r\n[3,]     0     0     0\r\n[4,]     0     0     0\r\n[5,]     0     1     0\r\n[6,]     0     1     0\r\n[7,]     0     0     1\r\n[8,]     0     0     0\r\n\r\n\r\n\r\n# Número de vizinhos vivos para cada agente\r\nvivos <- c()\r\nfor (i in 1:n^2) {\r\n  vivos <- cbind(vivos, \r\n                 length(estados.vizinhos0[, i][estados.vizinhos0[, i] == 1]))\r\n}\r\nvivos\r\n\r\n\r\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]\r\n[1,]    2    3    3    2    1    3    5    2    2     2     2     4\r\n     [,13] [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22]\r\n[1,]     2     4     2     1     3     1     4     2     1     2\r\n     [,23] [,24] [,25]\r\n[1,]     0     3     1\r\n\r\nAtualização dos estados\r\nSeguindo as quatro regras apontadas anteriormente, assim fica o próximo período:\r\n\r\n\r\n# Criando novo Grid\r\ngridFin <- expand.grid(x = 1:n, y = 1:n)\r\ngridFin$z <- c(NA)\r\n\r\n# Atualizando os estados de cada agente\r\nfor (i in 1:n^2) {\r\n  if (vivos[i] < 2) {\r\n    gridFin$z[i] <- 0\r\n  }\r\n  if (vivos[i] > 3) {\r\n    gridFin$z[i] <- 0\r\n  }\r\n  if (vivos[i] == 2) {\r\n    gridFin$z[i] <- gridIni$z[i]\r\n  }\r\n  if (vivos[i] == 3) {\r\n    gridFin$z[i] <- 1\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n# Plotando novo Grid\r\nggplot(data = gridFin) +\r\n  aes(x = x, y = y, fill = factor(z)) + \r\n  geom_tile(colour = \"black\", size = 0.8) +\r\n  coord_equal() +\r\n  theme_void() +\r\n  scale_fill_brewer(breaks = c(0, 1), \r\n                    labels = c(\"0 - Morto\", \"1 - Vivo\"),\r\n                    type = \"seq\",\r\n                    direction = 1, \r\n                    palette = 12) + \r\n  labs(title = \"Geração 1\", x = NULL, y = NULL, fill = \"Life\") +\r\n  geom_text(mapping = aes(label = 1:(n^2))) -> plot1\r\n\r\nplot1\r\n\r\n\r\n\r\n\r\nComparando as duas gerações:\r\n\r\n\r\n# Plots lado a lado\r\ngrid.arrange(plot0, plot1, ncol = 2)\r\n\r\n\r\n\r\n\r\nAutomatizando o jogo\r\nAgora que conseguimos codificar as regras do jogo, podemos escrever funções que realizam os passos necessários de forma automática.\r\n\r\n\r\n# Função que gera o número de vizinhos vivos de cada agente\r\nnViz <- function(n, gridI) {\r\n  \r\n  mat <- matrix(data = 1:n^2, nrow = n)\r\n  mat.pad <- rbind(NA, cbind(NA, mat, NA), NA)\r\n  ind <- 2:(n + 1)\r\n  vizinhos <- rbind(N  = as.vector(mat.pad[ind - 1, ind    ]),\r\n                    NE = as.vector(mat.pad[ind - 1, ind + 1]),\r\n                    E  = as.vector(mat.pad[ind    , ind + 1]),\r\n                    SE = as.vector(mat.pad[ind + 1, ind + 1]),\r\n                    S  = as.vector(mat.pad[ind + 1, ind    ]),\r\n                    SO = as.vector(mat.pad[ind + 1, ind - 1]),\r\n                    O  = as.vector(mat.pad[ind    , ind - 1]),\r\n                    NO = as.vector(mat.pad[ind - 1, ind - 1]))\r\n  estados.vizinhos <- c()\r\n  for (i in 1:n^2) {\r\n    estados.vizinhos <- cbind(estados.vizinhos, gridI[vizinhos[, i], 3])\r\n  }\r\n  estados.vizinhos0 <- estados.vizinhos\r\n  estados.vizinhos0[is.na(estados.vizinhos0)] <- 0\r\n  vivos <- c()\r\n  for (i in 1:n^2) {\r\n    vivos <- cbind(vivos, \r\n                   length(estados.vizinhos0[, i][estados.vizinhos0[, i] == 1]))\r\n  }\r\n  \r\n  return(vivos)\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n# Função que gera o grid final com os estados dos agentes\r\nintera <- function(n, gridF, vivos) {\r\n  \r\n  for (i in 1:n^2) {\r\n    if (vivos[i] < 2) {\r\n      gridF$z[i] <- 0\r\n    }\r\n    if (vivos[i] > 3) {\r\n      gridF$z[i] <- 0\r\n    }\r\n    if (vivos[i] == 2) {\r\n      gridF$z[i] <- gridIni$z[i]\r\n    }\r\n    if (vivos[i] == 3) {\r\n      gridF$z[i] <- 1\r\n    }\r\n  }\r\n  \r\n  return(gridF)\r\n  \r\n}\r\n\r\n\r\n\r\nExemplos\r\n\r\n\r\n# Criando Grid inicial\r\ngera0 <- gridIni\r\n\r\n# Criando Grids para cada nova geração\r\ngera1 <- intera(n = n, gridF = gera0, vivos = nViz(n = n, gridI = gera0))\r\ngera2 <- intera(n = n, gridF = gera1, vivos = nViz(n = n, gridI = gera1))\r\ngera3 <- intera(n = n, gridF = gera2, vivos = nViz(n = n, gridI = gera2))\r\ngera4 <- intera(n = n, gridF = gera3, vivos = nViz(n = n, gridI = gera3))\r\ngera5 <- intera(n = n, gridF = gera4, vivos = nViz(n = n, gridI = gera4))\r\n\r\n\r\n\r\n\r\n\r\n# Criando Plots para cada novo Grid\r\nggplot(data = gera0) +\r\n  aes(x = x, y = y, fill = factor(z)) + \r\n  geom_tile(colour = \"black\", size = 0.8) +\r\n  coord_equal() +\r\n  theme_void() +\r\n  scale_fill_brewer(breaks = c(0, 1), \r\n                    labels = c(\"0 - Morto\", \"1 - Vivo\"),\r\n                    type = \"seq\",\r\n                    direction = 1, \r\n                    palette = 12) + \r\n  labs(title = \"Geração 0\", x = NULL, y = NULL, fill = \"Life\") +\r\n  geom_text(mapping = aes(label = 1:(n^2)), size = 2.5) -> plotgera0\r\n\r\nggplot(data = gera1) +\r\n  aes(x = x, y = y, fill = factor(z)) + \r\n  geom_tile(colour = \"black\", size = 0.8) +\r\n  coord_equal() +\r\n  theme_void() +\r\n  scale_fill_brewer(breaks = c(0, 1), \r\n                    labels = c(\"0 - Morto\", \"1 - Vivo\"),\r\n                    type = \"seq\",\r\n                    direction = 1, \r\n                    palette = 12) + \r\n  labs(title = \"Geração 1\", x = NULL, y = NULL, fill = \"Life\") +\r\n  geom_text(mapping = aes(label = 1:(n^2)), size = 2.5) -> plotgera1\r\n\r\nggplot(data = gera2) +\r\n  aes(x = x, y = y, fill = factor(z)) + \r\n  geom_tile(colour = \"black\", size = 0.8) +\r\n  coord_equal() +\r\n  theme_void() +\r\n  scale_fill_brewer(breaks = c(0, 1), \r\n                    labels = c(\"0 - Morto\", \"1 - Vivo\"),\r\n                    type = \"seq\",\r\n                    direction = 1, \r\n                    palette = 12) + \r\n  labs(title = \"Geração 2\", x = NULL, y = NULL, fill = \"Life\") +\r\n  geom_text(mapping = aes(label = 1:(n^2)), size = 2.5) -> plotgera2\r\n\r\nggplot(data = gera3) +\r\n  aes(x = x, y = y, fill = factor(z)) + \r\n  geom_tile(colour = \"black\", size = 0.8) +\r\n  coord_equal() +\r\n  theme_void() +\r\n  scale_fill_brewer(breaks = c(0, 1), \r\n                    labels = c(\"0 - Morto\", \"1 - Vivo\"),\r\n                    type = \"seq\",\r\n                    direction = 1, \r\n                    palette = 12) + \r\n  labs(title = \"Geração 3\", x = NULL, y = NULL, fill = \"Life\") +\r\n  geom_text(mapping = aes(label = 1:(n^2)), size = 2.5) -> plotgera3\r\n\r\nggplot(data = gera4) +\r\n  aes(x = x, y = y, fill = factor(z)) + \r\n  geom_tile(colour = \"black\", size = 0.8) +\r\n  coord_equal() +\r\n  theme_void() +\r\n  scale_fill_brewer(breaks = c(0, 1), \r\n                    labels = c(\"0 - Morto\", \"1 - Vivo\"),\r\n                    type = \"seq\",\r\n                    direction = 1, \r\n                    palette = 12) + \r\n  labs(title = \"Geração 4\", x = NULL, y = NULL, fill = \"Life\") +\r\n  geom_text(mapping = aes(label = 1:(n^2)), size = 2.5) -> plotgera4\r\n\r\nggplot(data = gera5) +\r\n  aes(x = x, y = y, fill = factor(z)) + \r\n  geom_tile(colour = \"black\", size = 0.8) +\r\n  coord_equal() +\r\n  theme_void() +\r\n  scale_fill_brewer(breaks = c(0, 1), \r\n                    labels = c(\"0 - Morto\", \"1 - Vivo\"),\r\n                    type = \"seq\",\r\n                    direction = 1, \r\n                    palette = 12) + \r\n  labs(title = \"Geração 5\", x = NULL, y = NULL, fill = \"Life\") +\r\n  geom_text(mapping = aes(label = 1:(n^2)), size = 2.5) -> plotgera5\r\n\r\n\r\n\r\n\r\n\r\n# plotando os Grids lado a lado\r\ngrid.arrange(plotgera0, plotgera1, plotgera2, plotgera3, plotgera4, plotgera5, \r\n             ncol = 2)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "last_modified": "2021-04-30T19:46:41-03:00"
    },
    {
      "path": "ordem2.html",
      "title": "Eq. Ordem 2",
      "description": "Essa aula estuda Equações em Diferença de ordem 2.\n",
      "author": [
        {
          "name": "Rafael Peixoto",
          "url": {}
        }
      ],
      "date": "04-19-2021",
      "contents": "\r\n\r\nContents\r\nEquações Homogêneas\r\nRaízes reais e diferentes\r\nSolução\r\nExemplo\r\n\r\nRaízes reais e iguais\r\nRaízes Complexas\r\n\r\n\r\n\r\nd-article p {\r\n  text-align: justify;\r\n  font-size: 16px;\r\n}\r\n\r\nd-article p code {\r\n  background: rgba(236, 236, 236, 0.8);\r\n}\r\n\r\nd-article div.sourceCode {\r\n  overflow: auto !important;\r\n}\r\n\r\nEquações Homogêneas\r\nUma equação em diferença de ordem 2 traz alguns elementos familiares das equações de ordem 1. No entanto, tendo em vista que agora as raízes do polinômio característico associado podem ser números complexos, temos neste caso, a presença de oscilações e ciclos. Seja a equação em diferença:\r\n\\[\r\ny_t + a_1 \\times y_{t-1} + a_0 \\times y_{t-2} = g(t)\r\n\\]\r\nonde g(t) é o termo independente (de y). A solução particular se determina seguindo o mesmo procedimento visto para o caso das equações de ordem 1.\r\nPara determinar a solução homogênea, precisamos antes identificar as raízes do polinômio característico. Se λ é raíz desse polinômio, temos que:\r\n\\[\r\np(\\lambda) = \\lambda^2 + a_1 \\lambda + a_0 = 0\r\n\\]\r\nLogo, dado que o polinômio é de grau 2, ele terá duas soluções possíveis:\r\n\\[\r\n\\lambda = - \\frac{a_1}{2} \\pm \\frac{\\sqrt{a_1^2 - 4 a_0}}{2}\r\n\\]\r\nSe \\(\\small \\Delta = a_1^2 - 4 a_0\\), temos 3 casos passiveis:\r\nDuas raízes reais e diferentes, no caso em que \\(\\small \\Delta > 0\\).\r\nDuas raízes reais e iguais, se \\(\\small \\Delta = 0\\);\r\nDuas raízes complexas, quando \\(\\small \\Delta < 0\\).\r\nAnalisemos cada caso.\r\nRaízes reais e diferentes\r\nSeja a equação em diferenças:\r\n\\[\r\ny_t - 3y_{t-1} + 2y_{t-2} = 0\r\n\\]\r\ncom \\(\\small y_1 = 1\\) e \\(\\small y_2 = -2\\)\r\nDetermine o polinômio característico e as suas raízes;\r\nDetermine as constantes arbitrárias;\r\nDetermine a trajetória temporal.\r\nSolução\r\nPara o primeiro item, precisamos usar a função polyroot do pacote base. Note que, dado que para gerar o valor da série em t + 2, precisamos dos valores em t + 1 e em t. Logo, para calcular y2, precisamos de dois valores iniciais: y1 e y0.\r\nUtilizando a mesma notação das outras aulas:\r\n\\[\r\na_2 \\times y_{t+2} = -a_1 \\times y_{t+1} - a_0 \\times y_t\r\n\\]\r\nPrimeiramente, vamos criar a função da órbita para uma equação de ordem 2:\r\n\r\n\r\n# Função que calcula a orbita de cada Eq em diferença de ordem 2\r\norbita_2o <- function(a0, y0, a1, y1, t) {\r\n  \r\n  out <- vector(mode = \"numeric\", length = t)\r\n  out[1] <- y0\r\n  out[2] <- y1\r\n  for (i in 1:t) {\r\n    out[i+2] <- -a1*out[i+1] -a0*out[i]\r\n  }\r\n  \r\n  return(out)\r\n  \r\n}\r\n\r\n\r\n\r\n\r\n\r\n# Exemplo\r\norbita_2o(a0 = -0.9, y0 = 1, a1 = -0.4, y1 = -2, t = 15) %>%\r\n  ts() %>%\r\n  autoplot()\r\n\r\n\r\n\r\n\r\nVejamos um exemplo com os seguintes parâmetros:\r\n\r\n\r\na0 <- 2\r\ny0 <- 1\r\na1 <- -3\r\ny1 <- -2\r\nt <- 10\r\n\r\n\r\n\r\n\r\n\r\n# Plot\r\norbita_2o(a0 = a0, y0 = y0, a1 = a1, y1 = y1, t = t) %>%\r\n  ts() %>%\r\n  autoplot()\r\n\r\n\r\n\r\n\r\nNote que a série se afasta do steady state \\(\\small y^∗ = 0\\) (é uma equação homogênea, certo?). E não há nem oscilações nem ciclos. Logo, o comportamento da série nos leva a inferir que a equação tem duas raízes reais e positivas; e pelo menos uma delas (sendo diferentes) possui módulo maior que um. Para confirmar, podemos primeiro calcular o discriminante (\\(\\small \\Delta\\)) do polinômio característico:\r\n\\[\r\np(\\lambda) = \\lambda^2 - 3 \\lambda + 2\r\n\\]\r\nPela definiçao:\r\n\r\n\r\na2 <- 1\r\na1 <- -3\r\na0 <- 2\r\n# calculando o discriminante\r\ndelta = a1^2 -4*a2*a0\r\ndelta\r\n\r\n\r\n[1] 1\r\n\r\nVeja que \\(\\small \\Delta = 1> 0\\). Logo, as raízes são reais e diferentes (caso 1). Agora, precisamos calcular as raízes do polinômio. Para isso, usamos a função polyroots() do pacote base (instalado e carregado automaticamente):\r\n\r\n\r\n# vetor de coeficientes do polinomio - veja que a ordem deles no vetor\r\n# vai do menor ao maior grau\r\ncoefs <- c(a0, a1, a2)\r\n# raizes\r\nroots <- polyroot(coefs)\r\nroots\r\n\r\n\r\n[1] 1+0i 2-0i\r\n\r\nNote que a função nos dá as raízes no formato mais geral que é o formato dos números complexos. Contudo, a parte imaginária das raízes é zero. Logo, temos duas raízes reais (e no caso, positivas), com \\(\\small (λ1, λ2) = Re(roots)\\).\r\n\r\n\r\nlambda = Re(roots) # a parte real das raizes\r\nlambda\r\n\r\n\r\n[1] 1 2\r\n\r\nCom isso, temos uma raíz de módulo unitário e outra com módulo maior que dois: a série temporal resultante será explosiva.\r\nA solução analítica será dada por:\r\n\\[\r\ny_t = A_1 \\lambda_1^t + A_2 \\lambda_2^t\r\n\\]\r\ncom \\(\\small λ1 = 1\\) e \\(\\small λ2 = 2\\). Dado que as condições iniciais são \\(\\small y_0=1\\) e \\(\\small y_1 =-2\\), temos que\r\n\\[\r\n\\begin{cases}\r\n& 1 = A_1(1)^0 + A_2(2)^0 \\\\\r\n& -2= A_1(1)^1 + A_2(2)^1\r\n\\end{cases}\r\n\\]\r\nque define um sistema linear e determinado. Logo:\r\n\r\n\r\nA <- matrix(data = c(1, lambda[1], 1, lambda[2]), nrow = 2)\r\nB <- c(y0, y1)\r\nX <- solve(A, B)\r\nX \r\n\r\n\r\n[1]  4 -3\r\n\r\nFinalmente, a solução analítica da equação é dada por:\r\n\\[\r\ny_t = 4(1)^t - 3(2)^t\r\n\\]\r\nVeja que essa solução é composta por duas parcelas, a parcela da primeira e da segunda raíz. Podemos analisar a contribuição de cada parcela na solução geral:\r\n\r\n\r\n# Função que calcula a orbita de cada Eq em diferença de ordem 2\r\norbita_parc <- function(X, lambda, t) {\r\n  \r\n  raiz1 <- vector(mode = \"numeric\", length = t)\r\n  raiz2 <- vector(mode = \"numeric\", length = t)\r\n  soma <- vector(mode = \"numeric\", length = t)\r\n  for (i in 1:t) {\r\n    raiz1[i] <- X[1]*lambda[1]^i\r\n    raiz2[i] <- X[2]*lambda[2]^i\r\n    soma[i] <- raiz1[i] + raiz2[i]\r\n  }\r\n  \r\n  out <- cbind(raiz1, raiz2, soma)\r\n  colnames(out) <- c(\"Raiz 1\", \"Raiz 2\", \"y\")\r\n  \r\n  return(out)\r\n  \r\n}\r\n\r\n\r\n\r\n\r\n\r\n# Plot\r\norbita_parc(X = X, lambda = lambda, t = t) %>%\r\n  ts() %>%\r\n  autoplot(facets = F)\r\n\r\n\r\n\r\n\r\nPara rodar essa função aqui foi necessário já possuir os valores de lambda e X, que foram assim encontrados: \\(\\small a_2 \\times y_{t+2} = -a_1 \\times y_{t+1} - a_0 \\times y_t\\). y0 e y1 foram dados: \\(\\small y_0 = 1\\) e \\(\\small y_1 = -2\\)\r\n\r\n\r\n# Vetor de coeficientes do polinomio \r\ncoefs <- c(a0, a1, a2)\r\n# Raizes\r\nroots <- polyroot(coefs)\r\n# A parte real das raizes\r\nlambda = Re(roots)\r\n# Para achar A1 e A2\r\nA <- matrix(data = c(1, lambda[1], 1, lambda[2]), nrow = 2)\r\nB <- c(y0, y1)\r\nX <- solve(A, B)\r\n\r\n\r\n\r\nVeja que o primeiro componente é estável, porém se mantém a uma distância constante do steady state \\(\\small y^∗ = 0\\). Logo, por esse componente ser constante, não podemos dizer que a série é estável. Ainda, o segundo componente explode a medida que t aumenta, e a grandeza dos valores tende a ser muito maior que a contribuição do primeiro componente, o que acaba gerando o comportamento da série \\(\\small y_t\\) no longo prazo.\r\nExemplo\r\nSeja a equação, com \\(\\small y_0 = 1\\) e \\(\\small y_1 = 3\\):\r\n\\[\r\ny_t -0.25y_{t-2} = 0\r\n\\]\r\nou\r\n\\[\r\n1y_{t+2} + 0y_{t+1} -0.25y_{t+0} = 0\r\n\\]\r\ntemos que:\r\n\r\n\r\na2 <- 1\r\na1 <- 0\r\na0 <- -0.25\r\ny0 <- 1\r\ny1 <- 3\r\nt <- 10\r\n\r\n\r\n\r\nSimulando essa série:\r\n\r\n\r\norbita_2o(a0 = a0, y0 = y0, a1 = a1, y1 = y1, t = t) %>%\r\n  ts() %>%\r\n  autoplot()\r\n\r\n\r\n\r\n\r\nUsando a solução analítica:\r\n\r\n\r\n# Vetor de coeficientes do polinomio \r\ncoefs <- c(a0, a1, a2)\r\n# Raizes\r\nroots <- polyroot(coefs)\r\n# A parte real das raizes\r\nlambda = Re(roots)\r\n# Para achar A1 e A2\r\nA <- matrix(data = c(1, lambda[1], 1, lambda[2]), nrow = 2)\r\nB <- c(y0, y1)\r\nX <- solve(A, B)\r\nrbind(X, lambda)\r\n\r\n\r\n       [,1] [,2]\r\nX       3.5 -2.5\r\nlambda  0.5 -0.5\r\n\r\nTemos que:\r\n\\[\r\n\\begin{align}\r\n& y_t = A_1\\lambda_1^t + A_2\\lambda_2^t \\\\\r\n& y_t = 3.5(0.5)^t - 2.5(-0.5)^t\r\n\\end{align}\r\n\\]\r\n\r\n\r\n# Plot\r\norbita_parc(X = X, lambda = lambda, t = t) %>%\r\n  ts() %>%\r\n  autoplot(facets = F)\r\n\r\n\r\n\r\n\r\nRaízes reais e iguais\r\nSeja a equação, com \\(\\small y_0 = 1\\) e \\(\\small y_1 = 3\\):\r\n\\[\r\ny_t - 6y_{t-1} + 9y_{t-2} = 0\r\n\\]\r\ntemos que:\r\n\r\n\r\na2 <- 1\r\na1 <- -6\r\na0 <- 9\r\ny0 <- 1\r\ny1 <- 3\r\nt <- 10\r\n\r\n\r\n\r\nSimulando essa série:\r\n\r\n\r\norbita_2o(a0 = a0, y0 = y0, a1 = a1, y1 = y1, t = t) %>%\r\n  ts() %>%\r\n  autoplot()\r\n\r\n\r\n\r\n\r\nUsando a solução analítica:\r\n\r\n\r\n# Vetor de coeficientes do polinomio \r\ncoefs <- c(a0, a1, a2)\r\n# Raizes\r\nroots <- polyroot(coefs)\r\n# A parte real das raizes\r\nlambda = Re(roots)\r\nlambda\r\n\r\n\r\n[1] 3 3\r\n\r\n# Para achar A1 e A2\r\n# A <- matrix(data = c(1, lambda[1], 1, lambda[2]), nrow = 2)\r\n# B <- c(y0, y1)\r\n# X <- solve(A, B) não pode ser utilizado pois o Delta é igual a zero\r\n\r\n\r\n\r\nPara encontrar a forma analítica da solução, multiplicamos uma das raízes (que são iguais) por t, para que haja diferenciação:\r\n\\[\r\ny_t = (A_1 + A_2 \\times t)\\lambda^t\r\n\\]\r\nPara obter as constantes arbitrárias A1 e A2 a partir das condições inicias, e com isso, analisar os componentes da solução, construimos novamente um sistema linear com duas equações e duas incógnitas:\r\n\\[\r\n\\begin{cases}\r\n& y_0 = (A_1 + A_2 \\times 0) \\times (3)^0 = A_1 \\\\\r\n& y_1 = (A_1 + A_2 \\times 1) \\times (3)^1 = 3A_1 + 3A_2 \r\n\\end{cases}\r\n\\]\r\nNa forma geral, para qualque lambda (qualquer polinômio com raizes iguals):\r\n\\[\r\n\\begin{cases}\r\n& y_0 = A_1 \\\\\r\n& y_1 = A_1\\lambda + A_2\\lambda \r\n\\end{cases}\r\n\\]\r\nLogo,\r\n\\[\r\nA_2 = \\frac{y_1}{\\lambda} - A_1\r\n\\]\r\n\r\n\r\n# identificando as constantes arbitrarias\r\nX = y0\r\nX[2] = y1/lambda[1] - X[1]\r\n\r\n\r\n\r\nComo mudamos a forma funcional da solução, precisamos alterar a função que gera essas séries, acrescentando a multipliação de A2 por t:\r\n\r\n\r\n# Função que calcula a orbita de cada Eq em diferença de ordem 2\r\norbita_parc_delta0 <- function(X, lambda, t) {\r\n  \r\n  raiz1 <- vector(mode = \"numeric\", length = t)\r\n  raiz2 <- vector(mode = \"numeric\", length = t)\r\n  soma <- vector(mode = \"numeric\", length = t)\r\n  for (i in 1:t) {\r\n    raiz1[i] <- X[1]*lambda[1]^i\r\n    raiz2[i] <- X[2]*i*lambda[2]^i\r\n    soma[i] <- raiz1[i] + raiz2[i]\r\n  }\r\n  \r\n  out <- cbind(raiz1, raiz2, soma)\r\n  colnames(out) <- c(\"Raiz 1\", \"Raiz 2\", \"y\")\r\n  \r\n  return(out)\r\n  \r\n}\r\n\r\n\r\n\r\n\r\n\r\n# Plot\r\norbita_parc_delta0(X = X, lambda = lambda, t = t) %>%\r\n  ts() %>%\r\n  autoplot(facets = F)\r\n\r\n\r\n\r\n\r\nRaízes Complexas\r\nPrecisamos utilizar Euler e Moivre para reescrever a solução homogênea.\r\nPor exemplo, seja a equação, com \\(\\small y_0 = 1\\) e \\(\\small y_1 = 3\\)\r\n\\[\r\ny_t - y_{t-1} + \\frac{5}{4}y_{t-2} = 0\r\n\\]\r\nou\r\n\\[\r\n1y_{t+2} - 1y_{t+1} + \\frac{5}{4}y_{t-0} = 0\r\n\\]\r\ntemos que:\r\n\r\n\r\na2 <- 1\r\na1 <- -1\r\na0 <- 5/4\r\ny0 <- 1\r\ny1 <- 3\r\nt <- 20\r\n\r\n\r\n\r\nSimulando essa série:\r\n\r\n\r\norbita_2o(a0 = a0, y0 = y0, a1 = a1, y1 = y1, t = t) %>%\r\n  ts() %>%\r\n  autoplot()\r\n\r\n\r\n\r\n\r\nUsando a solução analítica:\r\n\\[\r\ny_t^h = R^t [(A_1+A_2)\\times cos(\\theta t) + (A_1-A_2) \\times i \\times sin(\\theta t)]\r\n\\]\r\n\r\n\r\n# Vetor de coeficientes do polinomio \r\ncoefs <- c(a0, a1, a2)\r\n# Raizes\r\nroots <- polyroot(coefs)\r\nroots\r\n\r\n\r\n[1] 0.5+1i 0.5-1i\r\n\r\n# A parte real das raizes\r\n# lambda = Re(roots)\r\n# lambda\r\n# Para achar A1 e A2\r\n# A <- matrix(data = c(1, lambda[1], 1, lambda[2]), nrow = 2)\r\n# B <- c(y0, y1)\r\n# X <- solve(A, B) não pode ser utilizado pois o Delta é igual a zero\r\n\r\n\r\n\r\nComo as raízes apresentam componentes imaginários:\r\nPrimeira Raiz\r\n\r\n\r\n# Módulo do complexo\r\nR <- Mod(roots[1]) %>% round(digits = 2)\r\n# Argumento do complexo\r\ntheta <- Arg(roots[1]) %>% round(digits = 2)\r\nrbind(R, theta)\r\n\r\n\r\n      [,1]\r\nR     1.12\r\ntheta 1.11\r\n\r\n\\[\r\ny_t = (1.12)^t \\times (A_1 cos(1.11t) + A_2 sin(1.11t))\r\n\\]\r\nComo o módulo dessa raiz é maior que a unidade, \\(\\small R = 1.12 > 1\\), teremos uma série temporal com ciclos explosivos no longo prazo\r\n\r\n\r\n# Função que calcula a orbita de cada Eq em diferença de ordem 2\r\norbita_parc_complx <- function(R, theta, t) {\r\n  \r\n  out <- vector(mode = \"numeric\", length = t)\r\n  out[1] <- y0\r\n  out[2] <- y1\r\n  for (i in 1:t) {\r\n    out[i+2] <- R^t\r\n  }\r\n  \r\n  return(out)\r\n  \r\n}\r\n\r\n\r\n\r\nPq só usou 1 das raízes? Esse último gráfico diz respeito ao comportamento geral da série ou ao comportamento dessa raíz em específico? Pq nao mostrou o gráfico com as duas raizes e a soma delas, igual para os outros casos? cOmo calcular o A1 e o A2?\r\n\r\n\r\n\r\n",
      "last_modified": "2021-04-30T19:58:05-03:00"
    },
    {
      "path": "ordemsup.html",
      "title": "Eq. Ordem Superior",
      "description": "Essa aula estuda Equações em Diferença de ordem superior.\n",
      "author": [
        {
          "name": "Rafael Peixoto",
          "url": {}
        }
      ],
      "date": "04-30-2021",
      "contents": "\r\n\r\nContents\r\nEquações de Ordem Superior\r\nExercício 1\r\nExercício 2\r\n\r\nO Modelo de Hansen-Samuelson\r\nAnálise das raízes\r\nAnálise qualitativa\r\n\r\nO modelo de Hicks\r\nAnálise de estabilidade\r\n\r\n\r\n\r\n\r\nd-article p {\r\n  text-align: justify;\r\n  font-size: 16px;\r\n}\r\n\r\nd-article p code {\r\n  background: rgba(236, 236, 236, 0.8);\r\n}\r\n\r\nd-article div.sourceCode {\r\n  overflow: auto !important;\r\n}\r\n\r\n\r\nEquações de Ordem Superior\r\nComo já vimos, a equação linear em diferença de ordem n terá a sua solução analítica e estabilidade dependentes das n raízes do seu polinômio característico. Ainda, a condição do módulo de todas as raízes ser menor que a unidade continua a ser necessária para garantir a estabilidade da série no longo prazo.\r\nExercício 1\r\nSeja a equação de ordem 3, com \\(\\small y_0 = 400\\), \\(\\small y_1 = 420\\), \\(\\small y_2 = 450\\):\r\n\\[\r\n1y_{t+3} -4y_{t+2} +4.8y_{t+1} -1.6y_{t+0} = 100\r\n\\]\r\nEla possuirá três raízes características. Simulando, notamos que a série \\(\\small y_t\\) apresenta uma trajetória explosiva não oscilatória e sem ciclos. Logo, as raízes serão reais e positivas e haverá ao menos uma raíz com módulo maior que a unidade.\r\nTemos que:\r\n\r\n\r\na3 <- 1\r\na2 <- -4\r\na1 <- 4.8\r\na0 <- -1.6\r\ny0 <- 400\r\ny1 <- 420\r\ny2 <- 450\r\ng <- 100\r\nt <- 10\r\n\r\n\r\n\r\nPara simular essa série vamos, antes, construir a função de órbita de terceira ordem:\r\n\r\n\r\n# Função que calcula a orbita de cada Eq em diferença de ordem 3\r\norbita_3o <- function(a2, a1, a0, y0, y1, y2, g, t) {\r\n  \r\n  out <- vector(mode = \"numeric\", length = t)\r\n  out[1] <- y0\r\n  out[2] <- y1\r\n  out[3] <- y2\r\n  for (i in 1:(t-3)) {\r\n    out[i+3] <- -a2*out[i+2] -a1*out[i+1] -a0*out[i+0] + g\r\n  }\r\n  \r\n  return(out)\r\n  \r\n}\r\n\r\n\r\n\r\nSimulando a série:\r\n\r\n\r\norbita_3o(a2 = a2, a1 = a1, a0 = a0, y0 = y0, y1 = y1, y2 = y2, g = g, t = t) %>%\r\n  ts() %>%\r\n  autoplot() +\r\n  theme_hc() +\r\n  scale_x_continuous(breaks = 1:10) +\r\n  scale_y_continuous(breaks = seq(0, 18000, 2500))\r\n\r\n\r\n\r\n\r\nAnalisando as raízes (do polinômio característico):\r\n\r\n\r\n# Vetor de coeficientes do polinomio \r\ncoefs <- c(a0, a1, a2, a3)\r\n# Raizes\r\nroots <- polyroot(coefs) %>% round(digits = 3)\r\nroots\r\n\r\n\r\n[1] 0.553+0i 1.447+0i 2.000+0i\r\n\r\n# A parte real das raizes\r\nlambda = Re(roots)\r\nlambda\r\n\r\n\r\n[1] 0.553 1.447 2.000\r\n\r\nO steady state é dado por:\r\n\r\n\r\nyp <- g / (a0 + a1 + a2 + a3)\r\nyp\r\n\r\n\r\n[1] 500\r\n\r\nComo há 2 raízes maiores que a unidade, a série é explosiva. Logo, o ponto fixo é um repulsor. Além disso, as três raízes são reais e positivas, o que descarta a existência de oscilações ou de ciclos (como já havíamos previsto, dado o comportamento do gráfico).\r\nAssim, a solução explícita será dada pela combinação linear dos termos exponenciais tal que:\r\n\\[\r\n\\begin{align}\r\n& y_t = A_1(\\lambda_1)^t + A_2(\\lambda_2)^t + A_3(\\lambda_3)^t + g \\\\\r\n& y_t = A_1(0.553)^t + A_2(1.447)^t + A_3(2.000)^t + 500\r\n\\end{align}\r\n\\]\r\nonde os \\(\\small \\lambda_i\\) são as raízes. Com as três condições iniciais, determinamos as constantes arbitrárias A1, A2 e A3, por meio do sistema determinado resultante da substituição de y0, y1, y2 para t = 0, 1, 2 na solução explícita:\r\n\\[\r\n\\begin{cases}\r\ny_0 = A_1(0.553)^0+A_2(1.447)^0+A_3(2.000)^0 + 500 \\\\\r\ny_1 = A_1(0.553)^1+A_2(1.447)^1+A_3(2.000)^1 + 500 \\\\\r\ny_2 = A_1(0.553)^2+A_2(1.447)^2+A_3(2.000)^2 + 500 \\\\\r\n\\end{cases}\r\n\\]\r\nou\r\n\\[\r\n\\begin{equation}\r\n  \\begin{bmatrix}\r\n    y_0 \\\\\r\n    y_1 \\\\\r\n    y_2\r\n  \\end{bmatrix}\r\n  =\r\n  \\begin{bmatrix}\r\n    A_1 \\\\\r\n    A_2 \\\\\r\n    A_3\r\n  \\end{bmatrix}\r\n  \\cdot\r\n \\begin{bmatrix}\r\n    \\lambda_1^0 & \\lambda_2^0 & \\lambda_3^0  \\\\\r\n    \\lambda_1^1 & \\lambda_2^1 & \\lambda_3^1  \\\\\r\n    \\lambda_1^2 & \\lambda_2^2 & \\lambda_3^2  \\\\\r\n  \\end{bmatrix}\r\n\\end{equation}\r\n\\]\r\n\r\n\r\n# Para achar A1, A2 e A3\r\nv <- c(lambda[1]^0, lambda[1]^1, lambda[1]^2, \r\n       lambda[2]^0, lambda[2]^1, lambda[2]^2,\r\n       lambda[3]^0, lambda[3]^1, lambda[3]^2)\r\n# L: matrix com os lambdas\r\nL <- matrix(data = v, ncol = 3)\r\n# B: vetor com as condições inicias\r\nB <- c(y0, y1, y2) - yp\r\n# X: Vetor com os A_i \r\nX <- solve(L, B)\r\nX\r\n\r\n\r\n[1] -49.19536 -88.27182  37.46718\r\n\r\nPortanto:\r\n\\[\r\n\\begin{equation}\r\n  \\begin{bmatrix}\r\n    A_1 \\\\\r\n    A_2 \\\\\r\n    A_3\r\n  \\end{bmatrix}\r\n    =\r\n  \\begin{bmatrix}\r\n    -49.19 \\\\\r\n    -88.27 \\\\\r\n    37.46\r\n  \\end{bmatrix}\r\n\\end{equation}\r\n\\]\r\nSimulando os três componentes de forma independente:\r\n\r\n\r\n# Função que calcula a orbita de cada Eq em diferença de ordem 3\r\norbita_parc_3 <- function(X, lambda, t) {\r\n  \r\n  raiz1 <- vector(mode = \"numeric\", length = t)\r\n  raiz2 <- vector(mode = \"numeric\", length = t)\r\n  raiz3 <- vector(mode = \"numeric\", length = t)\r\n  soma <- vector(mode = \"numeric\", length = t)\r\n  for (i in 1:t) {\r\n    raiz1[i] <- X[1]*lambda[1]^i\r\n    raiz2[i] <- X[2]*lambda[2]^i\r\n    raiz3[i] <- X[3]*lambda[3]^i\r\n    soma[i] <- raiz1[i] + raiz2[i] + raiz3[i]\r\n  }\r\n  \r\n  out <- cbind(raiz1, raiz2, raiz3, soma)\r\n  colnames(out) <- c(\"Raiz 1\", \"Raiz 2\", \"Raiz 3\", \"y\")\r\n  \r\n  return(out)\r\n  \r\n}\r\n\r\n\r\n\r\n\r\n\r\norbita_parc_3(X = X, lambda = lambda, t = t) %>%\r\n  ts() %>%\r\n  autoplot(facets = F) +\r\n  theme_hc() +\r\n  scale_x_continuous(breaks = 1:10) +\r\n  scale_y_continuous(breaks = seq(-5000, 40000, 5000)) +\r\n  scale_colour_discrete(\"\") +\r\n  theme(legend.position = \"top\")\r\n\r\n\r\n\r\n\r\nExercício 2\r\nSeja a seguinte equação em diferença (também de ordem 3), com \\(\\small y_0 = 0\\), \\(\\small y_1 = 2\\), \\(\\small y_2 = 4\\):\r\n\\[\r\n1y_{t+3} - 1y_{t+2} - 2y_{t+1} +2y_{t+0} = 0 \r\n\\]\r\nTemos que:\r\n\r\n\r\na3 <- 1\r\na2 <- -1\r\na1 <- -2\r\na0 <- 2\r\ny0 <- 0\r\ny1 <- 2\r\ny2 <- 4\r\ng <- 0\r\nt <- 10\r\n\r\n\r\n\r\nComo já possuímos a função de órbita de terceira ordem, basta usá-la:\r\n\r\n\r\norbita_3o(a2 = a2, a1 = a1, a0 = a0, y0 = y0, y1 = y1, y2 = y2, g = g, t = t) %>%\r\n  ts() %>%\r\n  autoplot() +\r\n  theme_hc() +\r\n  scale_x_continuous(breaks = 1:10) +\r\n  scale_y_continuous(breaks = seq(0, 100, 10))\r\n\r\n\r\n\r\n\r\nO gráfico nos leva a inferir que temos novamente uma série explosiva e sem oscilações nem ciclos, o que indica a presença de raízes reais; e ao menos uma raíz unitária (maior que 1).\r\nAnalisando as raízes (do polinômio característico):\r\n\r\n\r\n# Vetor de coeficientes do polinomio \r\ncoefs <- c(a0, a1, a2, a3)\r\n# Raizes\r\nroots <- polyroot(coefs) %>% round(digits = 3)\r\nroots\r\n\r\n\r\n[1]  1.000+0i -1.414+0i  1.414+0i\r\n\r\n\r\n\r\n# A parte real das raizes\r\nlambda = Re(roots)\r\nlambda\r\n\r\n\r\n[1]  1.000 -1.414  1.414\r\n\r\nNote que temos uma raiz com módulo unitário e outras duas com módulo maior que a unidade. Além disso, temos uma raiz negativa, o que produziria oscilações (e explosivas). Mas esas oscilações não aparecem no gráfico. Haveria uma explicação?\r\nComo a equação é homogêna (\\(\\small g(t) = 0\\)), o steady state é 0, portanto:\r\n\r\n\r\n# Para achar A1, A2 e A3\r\nv <- c(lambda[1]^0, lambda[1]^1, lambda[1]^2, \r\n       lambda[2]^0, lambda[2]^1, lambda[2]^2,\r\n       lambda[3]^0, lambda[3]^1, lambda[3]^2)\r\n# L: matrix com os lambdas\r\nL <- matrix(data = v, ncol = 3)\r\n# B: vetor com as condições inicias\r\nB <- c(y0, y1, y2) # yp = 0 (steady state)\r\n# X: Vetor com os A_i \r\nX <- solve(L, B)\r\nX\r\n\r\n\r\n[1] -4.0024175 -0.1212868  4.1237043\r\n\r\nPara simular os três componentes de forma independente, usamos a função orbita_parc_3, que construimos anteriormente:\r\n\r\n\r\norbita_parc_3(X = X, lambda = lambda, t = t) %>%\r\n  ts() %>%\r\n  autoplot(facets = F) +\r\n  theme_hc() +\r\n  scale_x_continuous(breaks = 1:10) +\r\n  scale_y_continuous(breaks = seq(-20, 130, 10)) +\r\n  scale_color_discrete(\"\") +\r\n  theme(legend.position = \"top\")\r\n\r\n\r\n\r\n\r\nVemos que a raíz 2 de fato oscila. Contudo, como a série é explosiva, esse comportamento é pouco identificável no comportamento da série.\r\nO Modelo de Hansen-Samuelson\r\nO Modelo econômico de Hansen-Samuelson é dado pelas equações:\r\n\\[\r\n\\begin{align}\r\n& C_t = bY_{t-1} \\\\\r\n& I_t = k(C_t-C_{t-1}) \\\\\r\n& G_t = G>0 \\\\\r\n& Y_t = C_t + I_t + G_t\r\n\\end{align}\r\n\\]\r\nonde,\r\n\\(\\small b \\in (0,1)\\): propensão marginal a consumir\r\n\\(\\small k\\): coeficiente de aceleração do investimento\r\n\\(\\small G\\): gastos públicos (consumo autônomo)\r\nPodemos analisar o comportamento da renda nacional e por substituição, do consumo das famílias \\(\\small C_t\\) e dos investimentos \\(\\small I_t\\) nessa economia hipotética.\r\nPrimeiramente, definimos os parâmetros (como dentre as equações acima aparece um termo \\(\\small Y_{t-1}\\) e um \\(\\small C_{t-1}\\), esses devem ser fornecidos para a inicialização do modelo):\r\n\r\n\r\nb <- 0.9\r\nk <- 0.7\r\nG <- 10\r\nt <- 100\r\nY0 <- 10\r\nC0 <- 2\r\n\r\n\r\n\r\nSabemos que esses são os parâmetros que servem de input para a função que vamos construir para analisar esse modelo que, por sua vez, retorna os valores das séries para \\(\\small C_t\\), \\(\\small I_t\\) e \\(\\small Y_t\\). Adicionalmente, construiremos, também, uma série para os valores de \\(\\small I = I_{ind} + G\\) (na função a seguir, Iind corresponde ao \\(\\small I_t\\) nas equações do modelo acima):\r\n\r\n\r\n# Função que calcula a orbita do modelo de Hansen-Samuelson\r\norbita_HS <- function(b, k, G, Y0, C0, t) {\r\n  \r\n  Y <- vector(mode = \"numeric\", length = t)\r\n  C <- vector(mode = \"numeric\", length = t)\r\n  I <- vector(mode = \"numeric\", length = t)\r\n  Iind <- vector(mode = \"numeric\", length = t)\r\n  \r\n  C[1] <- b * Y0\r\n  Iind[1] <- k * (C[1] - C0)\r\n  Y[1] <- C[1] + Iind[1] + G\r\n\r\n  for (i in 2:t) {\r\n    C[i] <- b * Y[i-1]\r\n    Iind[i] <- k * (C[i] - C[i-1])\r\n    Y[i] <- C[i] + Iind[i] + G\r\n    I[i] <- Iind[i] + G\r\n  }\r\n  \r\n  out <- cbind(C, I, Iind, Y)\r\n  \r\n  return(out)\r\n  \r\n}\r\n\r\n\r\n\r\n\r\n\r\norbita_HS(b = b, k = k, G = G, Y0 = Y0, C0 = C0, t = t) %>%\r\n  ts() %>%\r\n  autoplot(facets = F) +\r\n  theme_hc() +\r\n  scale_x_continuous(breaks = seq(0, 100, 10)) +\r\n  scale_y_continuous(breaks = seq(0, 110, 10)) +\r\n  scale_color_discrete(\"\") +\r\n  theme(legend.position = \"top\")\r\n\r\n\r\n\r\n\r\nObservando o gráfico e a evolução as séries podemos inferir um padrão estável. Para validar tal inferência, podemos analisar o estado estacionário, em que \\(\\small Y_t = Y_{t−1}\\) e portanto, se espera que que \\(\\small C_t = C_{t−1}\\), \\(\\small I_t = I_{t−1}\\) etc. Olhando novamente as equações do sistema no longo prazo:\r\n\\[\r\n\\begin{cases}\r\nC^* = b\\cdot Y^* \\\\\r\nI_{ind}^* = 0 \\\\\r\nI^* = G \\\\\r\nY^* = C^* + I^*\r\n\\end{cases}\r\n\\]\r\nSubstituindo \\(\\small C^*\\) e \\(\\small I^*\\) em \\(\\small Y^*\\):\r\n\\[\r\nY^* = b \\cdot Y^* + G\r\n\\]\r\nLogo,\r\n\\[\r\nY^* = \\frac{G}{1-b}\r\n\\]\r\nSubstituindo os valores atribuídos aos parâmetros na simulação, temos que:\r\n\\[\r\n\\begin{cases}\r\nY^* = 100 \\\\\r\nI^* = 10 \\\\\r\nC^* = 90\r\n\\end{cases}\r\n\\]\r\nque são justamente os valores para os quais as séries convergiram. Portanto, podemos afirmar que se trata de um modelo estável.\r\nAnálise das raízes\r\nManipulando as equações que definem o modelo de Hansen-Samuelson, obtemos uma equação em diferença de ordem 2 em \\(\\small Y_t\\), que como já vimos, deve produzir uma série com comportamento convergente no longo prazo a \\(\\small Y^∗ = 100\\) (o atrator):\r\n\\[\r\nY_t - b\\cdot (k+1)\\cdot Y_{t-1} + b \\cdot k \\cdot Y_{t-2} = G\r\n\\]\r\nPara realizar a análise dinâmica, precisamos avaliar as raízes do polinômio característico:\r\n\\[\r\np(\\lambda) = \\lambda^2 + a_1\\lambda + a_0 = 0\r\n\\]\r\nonde,\r\n\\[\r\n\\begin{cases}\r\na_2 = 1 \\\\\r\na_1 = -b(k+1) \\\\\r\na_0 = bk\r\n\\end{cases}\r\n\\]\r\nA análise qualitativa a partir dos coeficientes considera as três restrições (para que o sistema seja estável) a seguir:\r\n\\[\r\n\\begin{cases}\r\n a_0 + a_1 +  1 & > 0 \\\\\r\n a_0 - a_1 + 1 & > 0 \\\\\r\n a_0 & < 1\r\n\\end{cases}\r\n\\]\r\nAntes de fazer essa análise qualitativa, entretanto, vamos analisar essas raízes de forma quantitativa, igual feito nos exercícios anteriores:\r\n\r\n\r\na2 <- 1\r\na1 <- -b * (k + 1)\r\na0 <- b * k\r\n\r\n\r\n\r\n\r\n\r\n# Vetor de coeficientes do polinomio \r\ncoefs <- c(a0, a1, a2)\r\ncoefs\r\n\r\n\r\n[1]  0.63 -1.53  1.00\r\n\r\n# Raizes\r\nroots <- polyroot(coefs) %>% round(digits = 3)\r\nroots\r\n\r\n\r\n[1] 0.765+0.212i 0.765-0.212i\r\n\r\nComo as raízes apresentam componentes complexos, vamos calcular o módulo e o ângulo (só é preciso usar uma das raízes pois as raízes complexas sempre aparecem em conjuntos de 2 e essas possuem o mesmo módulo):\r\n\r\n\r\nR <- Mod(roots[1])\r\ntheta <- Arg(roots[1])\r\nrbind(R, theta) %>% round(digits = 3)\r\n\r\n\r\n       [,1]\r\nR     0.794\r\ntheta 0.270\r\n\r\nComo o módulo é menor que a unidade, as séries apresentam ciclos amortecidos (não explosivos).\r\nAnálise qualitativa\r\nVoltando, agora, à análise qualitativa das raízes, vamos ver se satisfazem as restrições apontadas. Relembrando que:\r\n\\(\\small \\Delta > 0\\): Raízes reais e diferentes\r\n\\(\\small \\Delta = 0\\): Raízes reais e iguais\r\n\\(\\small \\Delta < 0\\): Raízes complexas\r\nIndependente da natureza das raízes, a estabilidade é garantida quando as raízes não são maiores que a unidade.\r\nPorém, a partir do polinômio característico, é possível estabelecer condições de estabilidade para o caso de raízes reais a partir da análise dos coeficientes:\r\n\\(\\small \\Delta = 0 \\implies a_0 < 1\\)\r\n\\(\\small \\Delta > 0 \\implies a_1-2 < \\pm \\sqrt{\\Delta} < a_1+2\\):\r\n\\(a_0 > a_1 -1\\)\r\n\\(a_0 > -a_1 -1\\)\r\n\r\n\\(\\small \\Delta < 0 \\implies a_0 < 1\\)\r\nJuntando:\r\n\\[\r\n\\begin{equation}\r\n\\begin{cases}\r\n a_0 + a_1 +  1 & > 0 \\\\\r\n a_0 - a_1 + 1 & > 0 \\\\\r\n a_0 & < 1\r\n\\end{cases}\r\n\\end{equation}\r\n\\]\r\n\r\n\r\nrest1 <- 1 + a1 + a0 > 0\r\nrest2 <- 1- a1 + a0 > 0\r\nrest3 <- a0 < 1\r\ncbind(rest1, rest2, rest3)\r\n\r\n\r\n     rest1 rest2 rest3\r\n[1,]  TRUE  TRUE  TRUE\r\n\r\nComo podemos ver, as três condições são atendidas.\r\nPorém, esse é o caso para os b e k definidos no início do exercício. Podemos analisar essas condições de forma geral, para quaisquer b e k. Como já mostrado:\r\n\\[\r\n\\begin{cases}\r\na_2 = 1 \\\\\r\na_1 = -b(k+1) \\\\\r\na_0 = bk\r\n\\end{cases}\r\n\\]\r\nJuntando essas restrições e condições, temos que para o sistema ser estável:\r\n\\[\r\nb < \\frac{1}{k}\r\n\\]\r\nDo polinômio característico, temos que as raízes são tais que:\r\n\\[\r\n\\lambda_1, \\lambda_2 = \\frac{b(k+1)}{2} \\pm \\frac{\\sqrt{\\Delta}}{2}\r\n\\]\r\nonde \\(\\small \\Delta = b^2(k+1)^2 - 4bk\\).\r\nPara identificar a características dinâmicas da renda, precisamos analisar \\(\\small \\Delta\\):\r\n\\[\r\n\\Delta = b^2(k+1)^2 - 4bk \\gtreqqless 0\r\n\\]\r\nisolando b:\r\n\\[\r\nb \\gtreqqless \\frac{4k}{(k+1)^2}\r\n\\]\r\nAssim, para analisar essas condições sobre b, podemos plotar as seguintes equações:\r\n\\[\r\n\\begin{cases}\r\nb = \\frac{1}{k} \\\\\r\nb = \\frac{4k}{(k+1)^2}\r\n\\end{cases}\r\n\\]\r\n\r\n\r\nfunc1 <- function(x) 1 / x\r\nfunc2 <- function(x) (4 * x) / (x + 1)^2\r\n\r\n\r\n\r\n\r\n\r\nggplot(data = data.frame(x = 0)) +\r\n  aes(x = x) +\r\n  xlim(0, 4) + \r\n  xlab(\"k\") +\r\n  ylim(0, 1.6) +\r\n  ylab(\"b\") +\r\n  ggtitle(\"Localização das raízes\") +\r\n  stat_function(fun = func1, aes(colour = \"func1\")) +\r\n  stat_function(fun = func2, aes(colour = \"func2\")) +\r\n  geom_hline(yintercept = 1, linetype = \"dashed\") +\r\n  geom_vline(xintercept = 1, linetype = \"dashed\") +\r\n  annotate(\"text\", x = 0, y = 0.9, label = \"A\", size = 5) +\r\n  annotate(\"text\", x = 1.2, y = 0.5, label = \"B\", size = 5) +\r\n  annotate(\"text\", x = 2.4, y = 0.7, label = \"C\", size = 5) +\r\n  annotate(\"text\", x = 3.2, y = 0.9, label = \"D\", size = 5) +\r\n  theme_hc() +\r\n  scale_y_continuous(breaks = seq(0, 1.6, 0.2), limits = c(0, 1.6)) +\r\n  scale_color_manual(\"\", values = c(\"red\", \"blue\"), \r\n                     labels = c(~frac(1,k),~frac(4*k,(k+1)^2))) +\r\n  theme(plot.title = element_text(size = 18, hjust = 0.5, colour = \"black\"),\r\n        legend.position = \"top\") \r\n\r\n\r\n\r\n\r\nComo apontado no gráfico, há 4 regiões possíveis:\r\nA: \\(\\small b < \\frac{1}{k}\\) e \\(\\small b > \\frac{4k}{(1+k)^2}\\)\r\nB: \\(\\small b < \\frac{1}{k}\\) e \\(\\small b < \\frac{4k}{(1+k)^2}\\)\r\nC: \\(\\small b > \\frac{1}{k}\\) e \\(\\small b < \\frac{4k}{(1+k)^2}\\)\r\nD: \\(\\small b > \\frac{1}{k}\\) e \\(\\small b > \\frac{4k}{(1+k)^2}\\)\r\nComo havíamos dito, a primeira restrição para a estabilidade do sistema é que \\(\\small b < \\frac{1}{k}\\), critério que apenas as regiões A e B atendem. Na região A, em que \\(\\small \\Delta > 0\\), as condições de estabilidade são que \\(\\small a_0 > a_1 - 1\\) e \\(\\small a_0 > -a_1 - 1\\). Na região B, em que \\(\\small \\Delta < 0\\), a condição de estabilidade é que \\(\\small a_0 < 1\\).\r\nO modelo de Hicks\r\nO modelo de Hicks é uma alteração do modelo de Hansen-Samuelson (HS), e é dado pelas seguintes equações:\r\n\\[\r\n\\begin{align}\r\n& Y_t = C_t + I_t  \\\\\r\n& C_t = bY_{t-1} \\\\\r\n& I_t = I'_t + I''_t \\\\\r\n& I'_t = k(Y_{t-1}-Y_{t-2}) \\\\\r\n& I''_t = A_0(1+g)^2 \\\\\r\n\\end{align}\r\n\\]\r\nonde,\r\n\\(\\small I''\\): Investimento autônomo, que cresce a uma taxa exógena \\(\\small g\\)\r\n\\(\\small I'\\): Investimento induzido pelo acelerador e dependente da demanda agregada.\r\n\\(\\small k < 1\\): condição de estabilidade\r\nAssim como para o modelo de HS, primeiramente definimos os parâmetros de inicialização da simulação:\r\n\r\n\r\nb <- 0.5  # propensão marginal a consumir\r\nk <- 0.2  # acelerador do investimento\r\ng <- 0.05 # taxa de investimento autônomo\r\nA0 <- 1\r\nY0 <- 20\r\nY1 <- 5\r\nt <- 80\r\n\r\n\r\n\r\nSabemos que esses são os parâmetros que servem de input para a função que vamos construir para analisar esse modelo que, por sua vez, retorna os valores das séries para \\(\\small C_t\\), \\(\\small I_t\\) e \\(\\small Y_t\\). Adicionalmente, construiremos, também, séries para os valores de \\(\\small I' = I_{ind}\\) e \\(\\small I'' = I_{aut}\\).\r\n\r\n\r\n# Função que calcula a orbita do modelo de Hicks\r\norbita_hicks <- function(b, k, g, A0, Y0, Y1, t) {\r\n  \r\n  C <- vector(mode = \"numeric\", length = t)\r\n  Iind <- vector(mode = \"numeric\", length = t)\r\n  Iaut <- vector(mode = \"numeric\", length = t)\r\n  I <- vector(mode = \"numeric\", length = t)\r\n  Y <- vector(mode = \"numeric\", length = t)\r\n  \r\n  C[1] <- b * Y0\r\n  Iind[1] <- k * (Y1 - Y0)\r\n  Iaut[1] <- A0 * (1 + g)^1\r\n  I[1] <- Iind[1] + Iaut[1]\r\n  Y[1] <- C[1] + I[1]\r\n  \r\n  C[2] <- b * Y1\r\n  Iind[2] <- k * (Y[1] - Y1)\r\n  Iaut[2] <- A0 * (1 + g)^2\r\n  I[2] <- Iind[2] + Iaut[2]\r\n  Y[2] <- C[2] + I[2]\r\n  \r\n  for (i in 3:t) {\r\n    C[i] <- b * Y[i-1]\r\n    Iind[i] <- k * (Y[i-1] - Y[i-2])\r\n    Iaut[i] <- A0 * (1 + g)^i\r\n    I[i] <- Iind[i] + Iaut[i]\r\n    Y[i] <- C[i] + I[i]\r\n  }\r\n  \r\n  out <- cbind(C, I, Iind, Iaut, Y)\r\n  \r\n  return(out)\r\n  \r\n}\r\n\r\n\r\n\r\n\r\n\r\norbita_hicks(b = b, k = k, g = g, A0 = A0, Y0 = Y0, Y1 = Y1, t = t) %>%\r\n  ts() %>%\r\n  autoplot(facets = F) +\r\n  theme_hc() +\r\n  scale_x_continuous(breaks = seq(0, 80, 10)) +\r\n  scale_y_continuous(breaks = seq(0, 100, 10)) +\r\n  scale_color_discrete(\"\") +\r\n  theme(legend.position = \"top\")\r\n\r\n\r\n\r\n\r\nNote que as séries parecem explodir. Contudo, devemos considerar que \\(\\small I_t = A0 \\cdot (1 + g)^t\\) cresce exponencialmente a uma taxa g constante. Logo, havendo um padrão de convergência, não podemos esperar que o equilíbrio seja fixo, pois todas as variáveis interagem entre si.\r\nAnálise de estabilidade\r\nPor substituição, obtemos a equação em diferenças de ordem 2 em \\(\\small Y_t\\):\r\n\\[\r\n1Y_t − (b + k)Y_{t−1} + kY_{t−2} = A_0(1 + g)^t\r\n\\]\r\ncujo polinômio característico é dado por:\r\n\\[\r\n\\lambda^2 - (b+k)\\lambda + k = 0\r\n\\]\r\nAssim:\r\n\\[\r\n\\begin{cases}\r\na_2 = 1 \\\\\r\na_1 = -(b+k) \\\\\r\na_0 = k\r\n\\end{cases}\r\n\\]\r\nSejam as condições de estabilidade:\r\n\\[\r\n\\begin{equation}\r\n\\begin{cases}\r\n a_0 + a_1 +  1 & > 0 \\\\\r\n a_0 - a_1 + 1 & > 0 \\\\\r\n a_0 & < 1\r\n\\end{cases}\r\n\\end{equation}\r\n\\]\r\nAplicando os valores do exercícios:\r\n\r\n\r\na2 <- 1\r\na1 <- -(b+k)\r\na0 <- k\r\n\r\n\r\n\r\n\r\n\r\nrest1 <- 1 + a1 + a0 > 0\r\nrest2 <- 1- a1 + a0 > 0\r\nrest3 <- a0 < 1\r\ncbind(rest1, rest2, rest3)\r\n\r\n\r\n     rest1 rest2 rest3\r\n[1,]  TRUE  TRUE  TRUE\r\n\r\nLogo, para o conjunto de valores dos parâmetros usados na simulação, teremos um sistema estável, com um equilíbrio móvel, dada a forma de \\(\\small g(t)=A_0(1+g)^t\\).\r\nCalculando o discriminante e as raízes temos que:\r\n\r\n\r\n# Vetor de coeficientes do polinomio \r\ncoefs <- c(a0, a1, a2)\r\ncoefs\r\n\r\n\r\n[1]  0.2 -0.7  1.0\r\n\r\n\r\n\r\n# Raizes\r\nroots <- polyroot(coefs) %>% round(digits = 3)\r\nroots\r\n\r\n\r\n[1] 0.35+0.278i 0.35-0.278i\r\n\r\nComo as raízes apresentam componentes complexos, vamos calcular o módulo e o ângulo:\r\n\r\n\r\nR <- Mod(roots[1])\r\ntheta <- Arg(roots[1])\r\nrbind(R, theta) %>% round(digits = 3)\r\n\r\n\r\n       [,1]\r\nR     0.447\r\ntheta 0.671\r\n\r\nComo o módulo é menor que a unidade, as séries apresentam ciclos amortecidos (não explosivos)\r\nA solução particular será dada por:\r\n\\[\r\nY^p_t = K(1 + g)^t\r\n\\]\r\nSubstituindo \\(\\small Y^p_t\\), \\(\\small Y^p_{t−1}\\) e \\(\\small Y^p_{t−2}\\) na eq. em diferenças, temos que:\r\n\\[\r\nK = \\frac{A_0(1+g)^2}{(1 + g)^2 − (b + k)(1 + g) + k}\r\n\\]\r\ncondicionado a um denominador positivo \\(\\small \\forall t\\). Assim, neste caso, temos a solução homogênea e particular dadas por:\r\n\r\n\r\n# Calculando K\r\nK <- (A0 * (1 + g)^2) / ((1 + g)^2 - (b + k) * (1 + g) + k)\r\nK\r\n\r\n\r\n[1] 1.942731\r\n\r\n\r\n\r\n# Talvez usar Y[1] e Y[2] mesmo\r\nA3 <- Y0 - K\r\nA4 <- (1 / sin(theta)) * ((Y1 - K * (1 + g)) / R - A3 * cos(theta))\r\nrbind(A3, A4)\r\n\r\n\r\n        [,1]\r\nA3  18.05727\r\nA4 -12.08601\r\n\r\n\r\n\r\norbita_hicks_analitica <- function(A3, A4, R, theta, t) {\r\n    \r\n  Yh <- vector(mode = \"numeric\", length = t)\r\n  Yp <- vector(mode = \"numeric\", length = t)\r\n  Y2 <- vector(mode = \"numeric\", length = t)\r\n  \r\n  for (i in 1:t) {\r\n    Yh[i] <- (R^i) * (A3 * cos(theta * i) + A4 * sin(theta * i))\r\n    Yp[i] <- K * (1 + g)^i\r\n    Y2[i] <- Yh[i] + Yp[i]\r\n  }\r\n  \r\n  out <- cbind(Yh, Yp, Y2)\r\n  \r\n  return(out)\r\n} \r\n\r\n\r\n\r\n\r\n\r\norbita_hicks_analitica(A3 = A3, A4 = A4, R = R, theta = theta, t = t) %>%\r\n  ts() %>%\r\n  autoplot(facets = F) +\r\n  theme_hc() +\r\n  scale_x_continuous(breaks = seq(0, 80, 10)) +\r\n  scale_y_continuous(breaks = seq(0, 100, 10)) +\r\n  scale_color_discrete(\"\") +\r\n  theme(legend.position = \"top\")\r\n\r\n\r\n\r\n\r\nComparando os dois resultados (simulação e analítico) para Y:\r\n\r\n\r\nY <- orbita_hicks(b = b, k = k, g = g, A0 = A0, Y0 = Y0, Y1 = Y1, t = t)[,5]\r\nanalit <- orbita_hicks_analitica(A3 = A3, A4 = A4, R = R, theta = theta, t = t)\r\n\r\nresult <- cbind(analit, Y)\r\nhead(result, n = 10)\r\n\r\n\r\n                Yh       Yp        Y2        Y\r\n [1,]  2.960132159 2.039868 5.0000000 8.050000\r\n [2,] -1.535460863 2.141861 0.6064004 4.212500\r\n [3,] -1.666209648 2.248954 0.5827446 2.496375\r\n [4,] -0.859586240 2.361402 1.5018158 2.120469\r\n [5,] -0.268828340 2.479472 2.2106438 2.261335\r\n [6,] -0.016448261 2.603446 2.5869975 2.498936\r\n [7,]  0.042193819 2.733618 2.7758118 2.704089\r\n [8,]  0.032821772 2.870299 2.9031207 2.870530\r\n [9,]  0.014545591 3.013814 3.0283594 3.019882\r\n[10,]  0.003624649 3.164505 3.1681292 3.168706\r\n\r\nresult %>%\r\n  ts() %>%\r\n  autoplot(facets = F) +\r\n  theme_hc() +\r\n  scale_x_continuous(breaks = seq(0, 80, 10)) +\r\n  scale_y_continuous(breaks = seq(0, 100, 10)) +\r\n  scale_color_discrete(\"\") +\r\n  theme(legend.position = \"top\")\r\n\r\n\r\n\r\n\r\nUtilizando Y[1] e Y[2] ao invés de Y0 e Y1:\r\n\r\n\r\nY <- orbita_hicks(b = b, k = k, g = g, A0 = A0, Y0 = Y0, Y1 = Y1, t = t)[,5]\r\n\r\nA3 <- Y[1] - K\r\nA4 <- (1 / sin(theta)) * ((Y[2] - K * (1 + g)) / R - A3 * cos(theta))\r\nrbind(A3, A4)\r\n\r\n\r\n        [,1]\r\nA3 6.1072687\r\nA4 0.1262162\r\n\r\n\r\n\r\nanalit <- orbita_hicks_analitica(A3 = A3, A4 = A4, R = R, theta = theta, t = t)\r\n\r\nresult <- cbind(analit, Y)\r\nhead(result, n = 10)\r\n\r\n\r\n                 Yh       Yp       Y2        Y\r\n [1,]  2.1726321586 2.039868 4.212500 8.050000\r\n [2,]  0.3007079366 2.141861 2.442569 4.212500\r\n [3,] -0.2235615876 2.248954 2.025393 2.496375\r\n [4,] -0.2165697457 2.361402 2.144832 2.120469\r\n [5,] -0.1069347938 2.479472 2.372537 2.261335\r\n [6,] -0.0315871856 2.603446 2.571859 2.498936\r\n [7,] -0.0007471691 2.733618 2.732871 2.704089\r\n [8,]  0.0057875959 2.870299 2.876086 2.870530\r\n [9,]  0.0042005896 3.013814 3.018014 3.019882\r\n[10,]  0.0017841436 3.164505 3.166289 3.168706\r\n\r\nresult %>%\r\n  ts() %>%\r\n  autoplot(facets = F) +\r\n  theme_hc() +\r\n  scale_x_continuous(breaks = seq(0, 80, 10)) +\r\n  scale_y_continuous(breaks = seq(0, 100, 10)) +\r\n  scale_color_discrete(\"\") +\r\n  theme(legend.position = \"top\")\r\n\r\n\r\n\r\n\r\nEm ambos os casos, a séries de Y da simulação e da forma analítica se sobrepôem, mesmo que apresente valoris inicias divergentes.\r\n\r\n\r\n\r\n",
      "last_modified": "2021-05-05T23:17:41-03:00"
    }
  ],
  "collections": []
}
